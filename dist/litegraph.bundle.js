/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["LiteGraphJS"] = factory();
	else
		root["LiteGraphJS"] = factory();
})(window, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/contextmenu.js":
/*!****************************!*\
  !*** ./src/contextmenu.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextMenu: () => (/* binding */ ContextMenu)\n/* harmony export */ });\n/* harmony import */ var _litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./litegraph.js */ \"./src/litegraph.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\n\nvar _ContextMenu_brand = /*#__PURE__*/new WeakSet();\nvar ContextMenu = /*#__PURE__*/function () {\n  /**\r\n  * @constructor\r\n  * @param {Array<Object>} values (allows object { title: \"Nice text\", callback: function ... })\r\n  * @param {Object} options [optional] Some options:\\\r\n  * - title: title to show on top of the menu\r\n  * - callback: function to call when an option is clicked, it receives the item information\r\n  * - ignore_item_callbacks: ignores the callback inside the item, it just calls the options.callback\r\n  * - event: you can pass a MouseEvent, this way the ContextMenu appears in that position\r\n  *\r\n  *   Rendering notes: This is only relevant to rendered graphs, and is rendered using HTML+CSS+JS.\r\n  */\n  function ContextMenu(values) {\n    var _options$scroll_speed;\n    var _options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, ContextMenu);\n    _classPrivateMethodInitSpec(this, _ContextMenu_brand);\n    this.options = _options;\n    (_options$scroll_speed = _options.scroll_speed) !== null && _options$scroll_speed !== void 0 ? _options$scroll_speed : _options.scroll_speed = 0.1;\n    this.menu_elements = [];\n    _assertClassBrand(_ContextMenu_brand, this, _linkToParent).call(this);\n    _assertClassBrand(_ContextMenu_brand, this, _validateEventClass).call(this);\n    _assertClassBrand(_ContextMenu_brand, this, _createRoot).call(this);\n    _assertClassBrand(_ContextMenu_brand, this, _bindEvents).call(this);\n    this.setTitle(this.options.title);\n    this.addItems(values);\n    _assertClassBrand(_ContextMenu_brand, this, _insertMenu).call(this);\n    _assertClassBrand(_ContextMenu_brand, this, _calculateBestPosition).call(this);\n  }\n  return _createClass(ContextMenu, [{\n    key: \"setTitle\",\n    value:\n    /**\r\n     * Creates a title element if it doesn't have one.\r\n     * Sets the title of the menu.\r\n     * @param {string} title - The title to be set.\r\n     */\n    function setTitle(title) {\n      var _this$titleElement;\n      if (!title) return;\n      (_this$titleElement = this.titleElement) !== null && _this$titleElement !== void 0 ? _this$titleElement : this.titleElement = document.createElement(\"div\");\n      var element = this.titleElement;\n      element.className = \"litemenu-title\";\n      element.innerHTML = title;\n      if (!this.root.parentElement) this.root.appendChild(element);\n    }\n\n    /**\r\n     * Adds a set of values to the menu.\r\n     * @param {Array<string|object>} values - An array of values to be added.\r\n     */\n  }, {\n    key: \"addItems\",\n    value: function addItems(values) {\n      for (var i = 0; i < values.length; i++) {\n        var name = values[i];\n        if (typeof name !== 'string') {\n          name = name && name.content !== undefined ? String(name.content) : String(name);\n        }\n        var value = values[i];\n        this.menu_elements.push(this.addItem(name, value, this.options));\n      }\n    }\n  }, {\n    key: \"addItem\",\n    value:\n    /**\r\n     * Adds an item to the menu.\r\n     * @param {string} name - The name of the item.\r\n     * @param {object | null} value - The value associated with the item.\r\n     * @param {object} [options={}] - Additional options for the item.\r\n     * @returns {HTMLElement} - The created HTML element representing the added item.\r\n     */\n    function addItem(name, value) {\n      var _this = this;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var element = document.createElement(\"div\");\n      element.className = \"litemenu-entry submenu\";\n      var disabled = false;\n      if (value === null) {\n        element.classList.add(\"separator\");\n      } else {\n        var _value$title;\n        element.innerHTML = (_value$title = value === null || value === void 0 ? void 0 : value.title) !== null && _value$title !== void 0 ? _value$title : name;\n        element.value = value;\n        if (value) {\n          if (value.disabled) {\n            disabled = true;\n            element.classList.add(\"disabled\");\n          }\n          if (value.submenu || value.has_submenu) {\n            element.classList.add(\"has_submenu\");\n          }\n        }\n        if (typeof value == \"function\") {\n          element.dataset[\"value\"] = name;\n          element.onclick_callback = value;\n        } else {\n          element.dataset[\"value\"] = value;\n        }\n        if (value.className) {\n          element.className += \" \" + value.className;\n        }\n      }\n      this.root.appendChild(element);\n      if (!disabled) {\n        element.addEventListener(\"click\", handleMenuItemClick);\n      }\n      if (!disabled && options.autoopen) {\n        element.addEventListener(\"pointerenter\", function (event) {\n          var value = _this.value;\n          if (!value || !value.has_submenu) {\n            return;\n          }\n          // if it is a submenu, autoopen like the item was clicked\n          handleMenuItemClick.call(_this, event);\n        });\n      }\n      var that = this;\n      function handleMenuItemClick(event) {\n        var _LiteGraph$debug, _that$current_submenu;\n        var value = this.value;\n        var closeParent = true;\n        (_LiteGraph$debug = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug === void 0 || _LiteGraph$debug.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"ContextMenu handleMenuItemClick\", value, options, closeParent, this.current_submenu, this);\n\n        // Close any current submenu\n        (_that$current_submenu = that.current_submenu) === null || _that$current_submenu === void 0 || _that$current_submenu.close(event);\n\n        // Execute global callback\n        if (options.callback) {\n          var _LiteGraph$debug2;\n          (_LiteGraph$debug2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug2 === void 0 || _LiteGraph$debug2.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"ContextMenu handleMenuItemClick callback\", this, value, options, event, that, options.node);\n          var globalCallbackResult = options.callback.call(this, value, options, event, that, options.node);\n          if (globalCallbackResult === true) {\n            closeParent = false;\n          }\n        }\n\n        // Handle special cases\n        if (value) {\n          if (value.callback && !options.ignore_item_callbacks && value.disabled !== true) {\n            var _LiteGraph$debug3;\n            (_LiteGraph$debug3 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug3 === void 0 || _LiteGraph$debug3.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"ContextMenu using value callback and !ignore_item_callbacks\", this, value, options, event, that, options.node);\n            var itemCallbackResult = value.callback.call(this, value, options, event, that, options.extra);\n            if (itemCallbackResult === true) {\n              closeParent = false;\n            }\n          }\n          if (value.submenu) {\n            var _LiteGraph$debug4;\n            (_LiteGraph$debug4 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug4 === void 0 || _LiteGraph$debug4.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"ContextMenu SUBMENU\", this, value, value.submenu.options, e, that, options);\n            if (!value.submenu.options) {\n              throw new Error(\"ContextMenu submenu needs options\");\n            }\n            // Recursively create submenu\n            new that.constructor(value.submenu.options, {\n              callback: value.submenu.callback,\n              event: event,\n              parentMenu: that,\n              ignore_item_callbacks: value.submenu.ignore_item_callbacks,\n              title: value.submenu.title,\n              extra: value.submenu.extra,\n              autoopen: options.autoopen\n            });\n            closeParent = false;\n          }\n        }\n\n        // Close parent menu if necessary and not locked\n        if (closeParent && !that.lock) {\n          that.close();\n        }\n      }\n      return element;\n    }\n\n    /**\r\n     * Closes this menu.\r\n     * @param {Event} [e] - The event that triggered the close action.\r\n     * @param {boolean} [ignore_parent_menu=false] - Whether to ignore the parent menu when closing.\r\n     */\n  }, {\n    key: \"close\",\n    value: function close(e, ignore_parent_menu) {\n      var _this$current_submenu;\n      if (this.root.f_textfilter) {\n        var doc = document;\n        doc.removeEventListener('keydown', this.root.f_textfilter, true);\n        doc.removeEventListener('keydown', this.root.f_textfilter, false);\n        if (e && e.target) {\n          doc = e.target.ownerDocument;\n        }\n        if (!doc) {\n          doc = document;\n        }\n        doc.removeEventListener('keydown', this.root.f_textfilter, true);\n        doc.removeEventListener('keydown', this.root.f_textfilter, false);\n      }\n      if (this.parentMenu && !ignore_parent_menu) {\n        this.parentMenu.lock = false;\n        this.parentMenu.current_submenu = null;\n        if (e === undefined) {\n          this.parentMenu.close();\n        } else if (e && !ContextMenu.isCursorOverElement(e, this.parentMenu.root)) {\n          ContextMenu.trigger(this.parentMenu.root, \"pointerleave\", e);\n        }\n      }\n      (_this$current_submenu = this.current_submenu) === null || _this$current_submenu === void 0 || _this$current_submenu.close(e, true);\n      if (this.root.closing_timer) {\n        clearTimeout(this.root.closing_timer);\n      }\n      if (this.root.parentNode) {\n        this.root.parentNode.removeChild(this.root);\n      }\n    }\n\n    /**\r\n     * Closes all open ContextMenus in the specified window.\r\n     * @param {Window} [ref_window=window] - The window object to search for open menus.\r\n     */\n  }, {\n    key: \"getTopMenu\",\n    value:\n    // returns the top most menu\n    function getTopMenu() {\n      var _this$options$parentM, _this$options$parentM2;\n      return (_this$options$parentM = (_this$options$parentM2 = this.options.parentMenu) === null || _this$options$parentM2 === void 0 ? void 0 : _this$options$parentM2.getTopMenu()) !== null && _this$options$parentM !== void 0 ? _this$options$parentM : this;\n    }\n  }, {\n    key: \"getFirstEvent\",\n    value: function getFirstEvent() {\n      var _this$options$parentM3, _this$options$parentM4;\n      return (_this$options$parentM3 = (_this$options$parentM4 = this.options.parentMenu) === null || _this$options$parentM4 === void 0 ? void 0 : _this$options$parentM4.getFirstEvent()) !== null && _this$options$parentM3 !== void 0 ? _this$options$parentM3 : this.options.event;\n    }\n  }], [{\n    key: \"trigger\",\n    value:\n    /**\r\n     * Triggers an event on the specified element with the given event name and parameters.\r\n     * @param {HTMLElement} element - The element on which to trigger the event.\r\n     * @param {string} event_name - The name of the event to trigger.\r\n     * @param {Object} params - Additional parameters to include in the event.\r\n     * @param {HTMLElement} origin - The origin of the event <currently not supported as CustomEvent can't have a target!>\r\n     * @returns {CustomEvent} - The created CustomEvent instance.\r\n     * @BUG: Probable bug related to params, origin not being configured/populated correctly\r\n     */\n    function trigger(element, event_name, params, origin) {\n      var evt = new CustomEvent(event_name, {\n        bubbles: true,\n        cancelable: true,\n        detail: params\n      });\n      Object.defineProperty(evt, 'target', {\n        value: origin\n      });\n      if (element.dispatchEvent) {\n        element.dispatchEvent(evt);\n      } else if (element.__events) {\n        element.__events.dispatchEvent(evt);\n      }\n      return evt;\n    }\n  }, {\n    key: \"isCursorOverElement\",\n    value: function isCursorOverElement(event, element) {\n      return _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(event.clientX, event.clientY, element.left, element.top, element.width, element.height);\n    }\n  }]);\n}();\nfunction _createRoot() {\n  var root = this.root = document.createElement(\"div\");\n  if (this.options.className) {\n    root.className = this.options.className;\n  }\n  root.classList.add(\"litegraph\", \"litecontextmenu\", \"litemenubar-panel\");\n  root.style.minWidth = \"80px\";\n  root.style.minHeight = \"10px\";\n  return root;\n}\nfunction _bindEvents() {\n  var _this2 = this;\n  var root = this.root;\n  root.style.pointerEvents = \"none\";\n  setTimeout(function () {\n    root.style.pointerEvents = \"auto\";\n  }, 100); // delay so the mouse up event is not caught by this element\n\n  // this prevents the default context browser menu to open in case this menu was created when pressing right button\n  root.addEventListener(\"pointerup\", function (e) {\n    // LiteGraph.log?.(\"pointerevents: ContextMenu up root prevent\");\n    e.preventDefault();\n    return true;\n  });\n  root.addEventListener(\"contextmenu\", function (e) {\n    if (e.button != 2) {\n      // right button\n      return false;\n    }\n    e.preventDefault();\n    return false;\n  });\n  root.addEventListener(\"pointerdown\", function (e) {\n    // LiteGraph.log?.(\"pointerevents: ContextMenu down\");\n    if (e.button == 2) {\n      _this2.close();\n      e.preventDefault();\n      return true;\n    }\n  });\n  root.addEventListener(\"wheel\", function (e) {\n    var pos = parseInt(root.style.top);\n    root.style.top = (pos + e.deltaY * _this2.options.scroll_speed).toFixed() + \"px\";\n    e.preventDefault();\n    return true;\n  });\n  root.addEventListener(\"pointerenter\", function (_event) {\n    // LiteGraph.log?.(\"pointerevents: ContextMenu enter\");\n    if (root.closing_timer) {\n      clearTimeout(root.closing_timer);\n    }\n  });\n}\nfunction _linkToParent() {\n  var parentMenu = this.options.parentMenu;\n  if (!parentMenu) return;\n  if (parentMenu.constructor !== this.constructor) {\n    var _LiteGraph$error;\n    (_LiteGraph$error = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.error) === null || _LiteGraph$error === void 0 || _LiteGraph$error.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"parentMenu must be of class ContextMenu, ignoring it\");\n    this.options.parentMenu = null;\n    return;\n  }\n  this.parentMenu = parentMenu;\n  this.parentMenu.lock = true;\n  this.parentMenu.current_submenu = this;\n}\nfunction _validateEventClass() {\n  if (!this.options.event) return;\n\n  // use strings because comparing classes between windows doesnt work\n  var eventClass = this.options.event.constructor.name;\n  if (eventClass !== \"MouseEvent\" && eventClass !== \"CustomEvent\" && eventClass !== \"PointerEvent\") {\n    var _LiteGraph$error2;\n    (_LiteGraph$error2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.error) === null || _LiteGraph$error2 === void 0 || _LiteGraph$error2.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it. (\".concat(eventClass, \")\"));\n    this.options.event = null;\n  }\n}\nfunction _insertMenu() {\n  var _this$options$event$t, _this$options$event, _doc$fullscreenElemen;\n  var doc = (_this$options$event$t = (_this$options$event = this.options.event) === null || _this$options$event === void 0 ? void 0 : _this$options$event.target.ownerDocument) !== null && _this$options$event$t !== void 0 ? _this$options$event$t : document;\n  var parent = (_doc$fullscreenElemen = doc.fullscreenElement) !== null && _doc$fullscreenElemen !== void 0 ? _doc$fullscreenElemen : doc.body;\n  var root = this.root;\n  var that = this;\n\n  // Atlasan's code: @BUG: Variable names will mismatch\n  if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.context_menu_filter_enabled) {\n    if (doc) {\n      // TEXT FILTER by KEYPRESS\n      // TODO FIX THIS :: need to remove correctly events !! getting multiple\n      if (root.f_textfilter) {\n        doc.removeEventListener(\"keydown\", root.f_textfilter, false);\n        doc.removeEventListener(\"keydown\", root.f_textfilter, true);\n        root.f_textfilter = false;\n      }\n      root.f_textfilter = function (e) {\n        var _LiteGraph$debug10;\n        // LiteGraph.debug?.(\"keyPressInsideContext\",e,that,this,options);\n        if (that.current_submenu) {\n          var _LiteGraph$debug5;\n          // removing listeners is buggy, this prevent parent menus to process the key event\n          (_LiteGraph$debug5 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug5 === void 0 || _LiteGraph$debug5.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Prevent filtering on ParentMenu\", that);\n          return;\n        }\n        if (!that.allOptions) {\n          that.allOptions = that.menu_elements; // combo_options;\n          that.selectedOption = false;\n        }\n        if (!that.currentOptions) {\n          that.currentOptions = that.allOptions; // initialize filtered to all\n        }\n        if (!that.filteringText) {\n          that.filteringText = \"\";\n        }\n        if (e.key) {\n          var kdone = false;\n          // DBG(\"KeyEv\",e.key);\n          switch (e.key) {\n            case \"Backspace\":\n              if (that.filteringText.length) {\n                that.filteringText = that.filteringText.substring(0, that.filteringText.length - 1);\n                kdone = true;\n              }\n              break;\n            case \"Escape\":\n              // should close ContextMenu\n              if (root.f_textfilter) {\n                doc.removeEventListener(\"keydown\", root.f_textfilter, false);\n                doc.removeEventListener(\"keydown\", root.f_textfilter, true);\n                root.f_textfilter = false;\n              }\n              that.close();\n              break;\n            case \"ArrowDown\":\n              do {\n                that.selectedOption = that.selectedOption !== false ? Math.min(Math.max(that.selectedOption + 1, 0), that.allOptions.length - 1) // currentOptions vs allOptions\n                : 0;\n              } while (that.allOptions[that.selectedOption] && that.allOptions[that.selectedOption].hidden && that.selectedOption < that.allOptions.length - 1);\n              // fix last filtered pos\n              if (that.allOptions[that.selectedOption] && that.allOptions[that.selectedOption].hidden) {\n                that.selectedOption = that.currentOptions[that.currentOptions.length - 1].menu_index;\n              }\n              kdone = true;\n              break;\n            case \"ArrowUp\":\n              do {\n                that.selectedOption = that.selectedOption !== false ? Math.min(Math.max(that.selectedOption - 1, 0), that.allOptions.length - 1) : 0;\n              } while (that.allOptions[that.selectedOption] && that.allOptions[that.selectedOption].hidden && that.selectedOption > 0);\n              // fix first filtered pos\n              if (that.allOptions[that.selectedOption] && that.allOptions[that.selectedOption].hidden) {\n                if (that.currentOptions && that.currentOptions.length) {\n                  that.selectedOption = that.currentOptions[0].menu_index;\n                } else {\n                  that.selectedOption = false;\n                }\n              }\n              kdone = true;\n              break;\n            case \"ArrowLeft\":\n              // should close submenu and jump back to parent\n              // that.close(e, true);\n              // NEED restoring events and resetting current_submenu on child close ?\n              break;\n            case \"ArrowRight\": // right do same as enter\n            case \"Enter\":\n              if (that.selectedOption !== false) {\n                if (that.allOptions[that.selectedOption]) {\n                  var _LiteGraph$debug6;\n                  (_LiteGraph$debug6 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug6 === void 0 || _LiteGraph$debug6.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"ContextElement simCLICK\", that.allOptions[iO]);\n                  // checking because of bad event removal :: FIX\n                  if (that.allOptions[that.selectedOption].do_click) {\n                    that.allOptions[that.selectedOption].do_click(that.options.event, ignore_parent_menu);\n                  }\n                } else {\n                  var _LiteGraph$debug7;\n                  (_LiteGraph$debug7 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug7 === void 0 || _LiteGraph$debug7.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"ContextElement selection wrong\", that.selectedOption);\n                  // selection fix when filtering\n                  that.selectedOption = that.selectedOption !== false ? Math.min(Math.max(that.selectedOption, 0), that.allOptions.length - 1) // currentOptions vs allOptions\n                  : 0;\n                }\n              } else {\n                if (that.filteringText.length) {\n                  for (var _iO in that.allOptions) {\n                    if (that.allOptions[_iO].style.display !== \"none\" // filtering for visible\n                    && !(that.allOptions[_iO].classList + \"\").includes(\"separator\")\n                    // && that.allOptions[iO].textContent !== \"Add Node\"\n                    && that.allOptions[_iO].textContent !== \"Search\") {\n                      var _LiteGraph$debug8;\n                      (_LiteGraph$debug8 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug8 === void 0 || _LiteGraph$debug8.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"ContextElement simCLICK\", that.allOptions[_iO]);\n                      // try cleaning parent listeners\n                      if (root.f_textfilter) {\n                        if (doc) {\n                          var _LiteGraph$debug9;\n                          doc.removeEventListener('keydown', root.f_textfilter, false);\n                          doc.removeEventListener('keydown', root.f_textfilter, true);\n                          (_LiteGraph$debug9 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug9 === void 0 || _LiteGraph$debug9.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Cleaned ParentContextMenu listener\", doc, that);\n                        }\n                      }\n                      var ignore_parent_menu = false; // ?\n                      that.allOptions[_iO].do_click(e, ignore_parent_menu); // .click();\n                      // return; //break;\n                      break;\n                    }\n                  }\n                }\n              }\n              kdone = true;\n              break;\n            default:\n              (_LiteGraph$debug10 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug10 === void 0 || _LiteGraph$debug10.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"ContextMenu filter: keyEvent\", e.keyCode, e.key);\n              if (String.fromCharCode(e.key).match(/(\\w|\\s)/g)) {\n                // pressed key is a char\n              } else {\n                // pressed key is a non-char\n                // DBG (\"--not char break--\")\n                // do not return\n                // ?? kdone = true;\n              }\n              break;\n          }\n          if (!kdone && e.key.length == 1) {\n            that.filteringText += e.key;\n            if (that.parentMenu) {\n              // that.lock = true; // ??\n              // that.parentMenu.close(e, true); // clean parent ?? lock ??\n            }\n          }\n        }\n\n        // process text filtering\n        if (that.filteringText && that.filteringText !== \"\") {\n          var aFilteredOpts = [];\n          that.currentOptions = []; // reset filtered\n          for (var _iO2 in that.allOptions) {\n            // if(that.allOptions[iO].textContent){ //.startWith(that.filteringText)){\n            var txtCont = that.allOptions[_iO2].textContent;\n            var doesContainW = txtCont.toLocaleLowerCase().includes(that.filteringText.toLocaleLowerCase());\n            var isStartW = txtCont.toLocaleLowerCase().startsWith(that.filteringText.toLocaleLowerCase());\n            var wSplits = txtCont.split(\"/\");\n            var isStartLast = false;\n            // DBG(\"check splits\",wSplits);\n            isStartLast = wSplits.length > 1 && wSplits[wSplits.length - 1].toLocaleLowerCase().startsWith(that.filteringText.toLocaleLowerCase()) || wSplits.length == 1 && isStartW;\n            var isExtra = (that.allOptions[_iO2].classList + \"\").includes(\"separator\")\n            // || txtCont === \"Add Node\"\n            || txtCont === \"Search\";\n            that.allOptions[_iO2].menu_index = _iO2; // original allOptions index\n            if (doesContainW && !isExtra) {\n              aFilteredOpts.push(that.allOptions[_iO2]);\n              that.allOptions[_iO2].style.display = \"block\";\n              that.allOptions[_iO2].hidden = false;\n              that.currentOptions.push(that.allOptions[_iO2]); // push filtered options\n              that.allOptions[_iO2].filtered_index = that.currentOptions.length - 1; // filtered index\n            } else {\n              that.allOptions[_iO2].hidden = true;\n              that.allOptions[_iO2].style.display = \"none\";\n              that.allOptions[_iO2].filtered_index = false;\n            }\n            if (isStartLast) {\n              // DBG(\"isStartLast\"+that.filteringText,that.allOptions[iO].textContent);\n              that.allOptions[_iO2].style.fontWeight = \"bold\";\n            } else if (isStartW) {\n              // DBG(\"isStartW\"+that.filteringText,that.allOptions[iO].textContent);\n              that.allOptions[_iO2].style.fontStyle = \"italic\";\n            }\n            // }\n          }\n          // selection clamp fix when filtering\n          that.selectedOption = that.selectedOption !== false ? Math.min(Math.max(that.selectedOption, 0), that.allOptions.length - 1) // currentOptions vs allOptions\n          : 0;\n          // fix first filtered pos\n          if (that.allOptions[that.selectedOption] && that.allOptions[that.selectedOption].hidden && that.currentOptions.length) {\n            that.selectedOption = that.currentOptions[0].menu_index;\n          }\n        } else {\n          aFilteredOpts = that.allOptions; // combo_options\n          that.currentOptions = that.allOptions; // no filtered options\n          for (var _iO3 in that.allOptions) {\n            that.allOptions[_iO3].style.display = \"block\";\n            that.allOptions[_iO3].style.fontStyle = \"inherit\";\n            that.allOptions[_iO3].style.fontWeight = \"inherit\";\n            that.allOptions[_iO3].hidden = false;\n            that.allOptions[_iO3].filtered_index = false;\n            that.allOptions[_iO3].menu_index = _iO3;\n          }\n        }\n        // process selection (up down)\n        var hasSelected = that.selectedOption !== false;\n        if (hasSelected) {\n          var _LiteGraph$debug11;\n          (_LiteGraph$debug11 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug11 === void 0 || _LiteGraph$debug11.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"ContextMenu selection: \", that.selectedOption);\n          for (var _iO4 in that.allOptions) {\n            var isSelected = that.selectedOption + \"\" === _iO4 + \"\";\n            // LiteGraph.debug?.(\"ContextMenu check sel: \",that.selectedOption,iO);\n            if (isSelected) {\n              // that.allOptions[iO].style.backgroundColor = \"#333\";\n              that.allOptions[_iO4].classList.add(\"selected\");\n              // that.allOptions[iO].style.fontStyle = \"italic\";\n            } else {\n              that.allOptions[_iO4].classList.remove(\"selected\");\n              // that.allOptions[iO].style.backgroundColor = \"none\";\n            }\n          }\n        }\n\n        // height reset\n        var body_rect = document.body.getBoundingClientRect();\n        var root_rect = root.getBoundingClientRect();\n        root.style.top = that.top_original + \"px\";\n        // if (body_rect.height && top > body_rect.height - root_rect.height - 10) {\n        // var new_top = body_rect.height - root_rect.height - 10;\n        // root.style.top = this.top_original + \"px\";\n        // }\n\n        // DBG(\"filtered for \",that.filteringText);\n\n        // do not return, do not prevent\n        // e.preventDefault();\n        // return false;\n      };\n      doc.addEventListener(\"keydown\", root.f_textfilter, true);\n    } else {\n      var _LiteGraph$warn;\n      (_LiteGraph$warn = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn === void 0 || _LiteGraph$warn.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"NO root document to add context menu and event\", doc, options);\n    }\n  }\n  parent.appendChild(this.root);\n}\nfunction _calculateBestPosition() {\n  var options = this.options;\n  var root = this.root;\n  var left = options.left || 0;\n  var top = options.top || 0;\n  this.top_original = top;\n  if (options.event) {\n    var _LiteGraph$error3;\n    left = options.event.clientX - 10;\n    top = options.event.clientY - 10;\n    if (options.title) {\n      top -= 20;\n    }\n    this.top_original = top;\n    if (options.parentMenu) {\n      var rect = options.parentMenu.root.getBoundingClientRect();\n      left = rect.left + rect.width;\n    }\n    var body_rect = document.body.getBoundingClientRect();\n    var root_rect = root.getBoundingClientRect();\n    if (body_rect.height === 0) (_LiteGraph$error3 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.error) === null || _LiteGraph$error3 === void 0 || _LiteGraph$error3.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"document.body height is 0. That is dangerous, set html,body { height: 100%; }\");\n    if (body_rect.width && left > body_rect.width - root_rect.width - 10) {\n      left = body_rect.width - root_rect.width - 10;\n    }\n    if (body_rect.height && top > body_rect.height - root_rect.height - 10) {\n      top = body_rect.height - root_rect.height - 10;\n    }\n  }\n  root.style.left = \"\".concat(left, \"px\");\n  root.style.top = \"\".concat(top, \"px\");\n  if (options.scale) {\n    root.style.transform = \"scale(\".concat(options.scale, \")\");\n  }\n}\n_defineProperty(ContextMenu, \"closeAll\", function () {\n  var ref_window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n  var elements = ref_window.document.querySelectorAll(\".litecontextmenu\");\n  if (!elements.length) return;\n  elements.forEach(function (element) {\n    if (element.close) {\n      element.close();\n    } else {\n      var _element$parentNode;\n      (_element$parentNode = element.parentNode) === null || _element$parentNode === void 0 || _element$parentNode.removeChild(element);\n    }\n  });\n});\n\n//# sourceURL=webpack://LiteGraphJS/./src/contextmenu.js?");

/***/ }),

/***/ "./src/dragandscale.js":
/*!*****************************!*\
  !*** ./src/dragandscale.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragAndScale: () => (/* binding */ DragAndScale)\n/* harmony export */ });\n/* harmony import */ var _litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./litegraph.js */ \"./src/litegraph.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\r\n * Class responsible for handling scale and offset transformations for an HTML element,\r\n * enabling zooming and dragging functionalities.\r\n */\nvar DragAndScale = /*#__PURE__*/function () {\n  /**\r\n   * Creates an instance of DragAndScale.\r\n   * @param {HTMLElement} element - The HTML element to apply scale and offset transformations.\r\n   * @param {boolean} skip_events - Flag indicating whether to skip binding mouse and wheel events.\r\n   *\r\n   * Rendering:\r\n   * toCanvasContext() is HTMLCanvas, and onredraw is probably also.  The rest is all HTML+CSS+JS\r\n   */\n\n  function DragAndScale(element, skip_events) {\n    var _this = this;\n    _classCallCheck(this, DragAndScale);\n    _defineProperty(this, \"onMouseDown\", function (event) {\n      if (!_this.enabled) {\n        return;\n      }\n      var canvas = _this.element;\n      var rect = canvas.getBoundingClientRect();\n      var x = event.clientX - rect.left;\n      var y = event.clientY - rect.top;\n      event.canvasx = x;\n      event.canvasy = y;\n      event.dragging = _this.dragging;\n      var is_inside = !_this.viewport || _this.viewport && x >= _this.viewport[0] && x < _this.viewport[0] + _this.viewport[2] && y >= _this.viewport[1] && y < _this.viewport[1] + _this.viewport[3];\n      if (is_inside) {\n        _this.dragging = true;\n        _this.abortController = new AbortController();\n        document.addEventListener(\"pointermove\", _this.onMouseMove, {\n          signal: _this.abortController.signal\n        });\n        document.addEventListener(\"pointerup\", _this.onMouseUp, {\n          signal: _this.abortController.signal\n        });\n      }\n      _this.last_mouse[0] = x;\n      _this.last_mouse[1] = y;\n    });\n    _defineProperty(this, \"onMouseMove\", function (event) {\n      if (!_this.enabled) {\n        return;\n      }\n      var canvas = _this.element;\n      var rect = canvas.getBoundingClientRect();\n      var x = event.clientX - rect.left;\n      var y = event.clientY - rect.top;\n      event.canvasx = x;\n      event.canvasy = y;\n      event.dragging = _this.dragging;\n      var deltax = x - _this.last_mouse[0];\n      var deltay = y - _this.last_mouse[1];\n      if (_this.dragging) {\n        _this.mouseDrag(deltax, deltay);\n      }\n      _this.last_mouse[0] = x;\n      _this.last_mouse[1] = y;\n    });\n    _defineProperty(this, \"onMouseUp\", function (_event) {\n      var _this$abortController;\n      _this.dragging = false;\n      (_this$abortController = _this.abortController) === null || _this$abortController === void 0 || _this$abortController.abort();\n    });\n    _defineProperty(this, \"onWheel\", function (event) {\n      event.wheel = -event.deltaY;\n\n      // from stack overflow\n      event.delta = event.wheelDelta ? event.wheelDelta / 40 : event.deltaY ? -event.deltaY / 3 : 0;\n      _this.changeDeltaScale(1.0 + event.delta * 0.05);\n    });\n    this.offset = new Float32Array([0, 0]);\n    this.scale = 1;\n    this.max_scale = 10;\n    this.min_scale = 0.1;\n    this.onredraw = null;\n    this.enabled = true;\n    this.last_mouse = [0, 0];\n    this.element = null;\n    this.visible_area = new Float32Array(4);\n    if (element) {\n      this.element = element;\n      if (!skip_events) {\n        this.bindEvents(element);\n      }\n    }\n  }\n\n  /**\r\n   * Binds mouse and wheel events to the specified HTML element.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element to bind the events to.\r\n   */\n  return _createClass(DragAndScale, [{\n    key: \"bindEvents\",\n    value: function bindEvents(element) {\n      this.last_mouse = new Float32Array(2);\n      element.addEventListener(\"pointerdown\", this.onMouseDown);\n      element.addEventListener(\"wheel\", this.onWheel);\n    }\n  }, {\n    key: \"computeVisibleArea\",\n    value:\n    /**\r\n     * Computes the visible area of the DragAndScale element based on the viewport.\r\n     *\r\n     * If the element is not set, the visible area will be reset to zero.\r\n     *\r\n     * @param {Array<number>} [viewport] - The viewport configuration to calculate the visible area.\r\n     */\n    function computeVisibleArea(viewport) {\n      if (!this.element) {\n        this.visible_area.set([0, 0, 0, 0]);\n        return;\n      }\n      var width = this.element.width;\n      var height = this.element.height;\n      var startx = -this.offset[0];\n      var starty = -this.offset[1];\n      if (viewport) {\n        startx += viewport[0] / this.scale;\n        starty += viewport[1] / this.scale;\n        var _viewport$slice = viewport.slice(2),\n          _viewport$slice2 = _slicedToArray(_viewport$slice, 2),\n          vpWidth = _viewport$slice2[0],\n          vpHeight = _viewport$slice2[1];\n        width = vpWidth;\n        height = vpHeight;\n      }\n      var endx = startx + width / this.scale;\n      var endy = starty + height / this.scale;\n      this.visible_area.set([startx, starty, endx - startx, endy - starty]);\n    }\n\n    /**\r\n     * Applies the scale and offset transformations to the given 2D canvas rendering context.\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx - The 2D canvas rendering context to apply transformations to.\r\n     */\n  }, {\n    key: \"toCanvasContext\",\n    value: function toCanvasContext(ctx) {\n      ctx.scale(this.scale, this.scale);\n      ctx.translate(this.offset[0], this.offset[1]);\n    }\n\n    /**\r\n     * Converts a position from DragAndScale offset coordinates to canvas coordinates.\r\n     *\r\n     * @param {Array<number>} pos - The position in DragAndScale offset coordinates to convert.\r\n     * @returns {Array<number>} The converted position in canvas coordinates.\r\n     */\n  }, {\n    key: \"convertOffsetToCanvas\",\n    value: function convertOffsetToCanvas(pos) {\n      return [(pos[0] + this.offset[0]) * this.scale, (pos[1] + this.offset[1]) * this.scale];\n    }\n\n    /**\r\n     * Converts a position from canvas coordinates to DragAndScale offset coordinates.\r\n     *\r\n     * @param {Array<number>} pos - The position in canvas coordinates to convert.\r\n     * @param {Array<number>} [out=[0, 0]] - The output array to store the converted position in DragAndScale offset coordinates.\r\n     * @returns {Array<number>} The converted position in DragAndScale offset coordinates.\r\n     */\n  }, {\n    key: \"convertCanvasToOffset\",\n    value: function convertCanvasToOffset(pos) {\n      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];\n      out[0] = pos[0] / this.scale - this.offset[0];\n      out[1] = pos[1] / this.scale - this.offset[1];\n      return out;\n    }\n  }, {\n    key: \"mouseDrag\",\n    value: function mouseDrag(x, y) {\n      var _this$onredraw;\n      this.offset[0] += x / this.scale;\n      this.offset[1] += y / this.scale;\n      (_this$onredraw = this.onredraw) === null || _this$onredraw === void 0 || _this$onredraw.call(this, this);\n    }\n\n    /**\r\n     * Changes the scale of the DragAndScale element to the specified value around the zooming center.\r\n     *\r\n     * @param {number} value - The new scale value to set, clamped between min_scale and max_scale.\r\n     * @param {Array<number>} zooming_center - The center point for zooming, defaulting to the middle of the element.\r\n     */\n  }, {\n    key: \"changeScale\",\n    value: function changeScale(value, zooming_center) {\n      var _this$onredraw2;\n      value = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.clamp(value, this.min_scale, this.max_scale);\n      if (value == this.scale || !this.element) {\n        return;\n      }\n      var rect = this.element.getBoundingClientRect();\n      if (!rect) {\n        return;\n      }\n      zooming_center = zooming_center || [rect.width * 0.5, rect.height * 0.5];\n      var center = this.convertCanvasToOffset(zooming_center);\n      this.scale = value;\n      if (Math.abs(this.scale - 1) < 0.01) {\n        this.scale = 1;\n      }\n      var new_center = this.convertCanvasToOffset(zooming_center);\n      var delta_offset = [new_center[0] - center[0], new_center[1] - center[1]];\n      this.offset[0] += delta_offset[0];\n      this.offset[1] += delta_offset[1];\n      (_this$onredraw2 = this.onredraw) === null || _this$onredraw2 === void 0 || _this$onredraw2.call(this, this);\n    }\n\n    /**\r\n     * Changes the scale of the DragAndScale element by a delta value relative to the current scale.\r\n     *\r\n     * @param {number} value - The delta value by which to scale the element.\r\n     * @param {Array<number>} zooming_center - The center point for zooming the element.\r\n     */\n  }, {\n    key: \"changeDeltaScale\",\n    value: function changeDeltaScale(value, zooming_center) {\n      this.changeScale(this.scale * value, zooming_center);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.scale = 1;\n      this.offset[0] = 0;\n      this.offset[1] = 0;\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://LiteGraphJS/./src/dragandscale.js?");

/***/ }),

/***/ "./src/lgraph.js":
/*!***********************!*\
  !*** ./src/lgraph.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LGraph: () => (/* binding */ LGraph)\n/* harmony export */ });\n/* harmony import */ var _litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./litegraph.js */ \"./src/litegraph.js\");\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\r\n * LGraph is the class that contain a full graph. We instantiate one and add nodes to it, and then we can run the execution loop.\r\n * supported callbacks:\r\n    + onNodeAdded: when a new node is added to the graph\r\n    + onNodeRemoved: when a node inside this graph is removed\r\n    + onNodeConnectionChange: some connection has changed in the graph (connected or disconnected)\r\n */\nvar LGraph = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   * @param {Object} o data from previous serialization [optional]} o\r\n   */\n  function LGraph(o) {\n    var _LiteGraph$log;\n    _classCallCheck(this, LGraph);\n    (_LiteGraph$log = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log === void 0 || _LiteGraph$log.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Graph created\");\n    this.list_of_graphcanvas = null;\n    this.clear();\n    if (o) {\n      this.configure(o);\n    }\n  }\n\n  /**\r\n   * Gets the supported types of the LGraph class, falling back to the default supported types if not defined for the instance.\r\n   * @returns {Array} An array of supported types for the LGraph class.\r\n   */\n  return _createClass(LGraph, [{\n    key: \"getSupportedTypes\",\n    value: function getSupportedTypes() {\n      var _this$supported_types;\n      return (_this$supported_types = this.supported_types) !== null && _this$supported_types !== void 0 ? _this$supported_types : LGraph.supported_types;\n    }\n\n    /**\r\n     * Removes all nodes from this graph\r\n     * @method clear\r\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this$_nodes;\n      this.stop();\n      this.status = LGraph.STATUS_STOPPED;\n      this.last_node_id = 0;\n      this.last_link_id = 0;\n      this._version = -1; // used to detect changes\n\n      // safe clear\n      (_this$_nodes = this._nodes) === null || _this$_nodes === void 0 || _this$_nodes.forEach(function (node) {\n        var _node$onRemoved;\n        (_node$onRemoved = node.onRemoved) === null || _node$onRemoved === void 0 || _node$onRemoved.call(node);\n      });\n\n      // nodes\n      this._nodes = [];\n      this._nodes_by_id = {};\n      this._nodes_in_order = []; // nodes sorted in execution order\n      this._nodes_executable = null; // nodes that contain onExecute sorted in execution order\n\n      // other scene stuff\n      this._groups = [];\n\n      // links\n      this.links = {}; // container with all the links\n\n      // iterations\n      this.iteration = 0;\n\n      // custom data\n      this.config = {};\n      this.configApplyDefaults();\n      this.vars = {};\n      this.extra = {}; // to store custom data\n\n      // timing\n      this.globaltime = 0;\n      this.runningtime = 0;\n      this.fixedtime = 0;\n      this.fixedtime_lapse = 0.01;\n      this.elapsed_time = 0.01;\n      this.last_update_time = 0;\n      this.starttime = 0;\n      this.catch_errors = true;\n\n      // savings\n      this.history = {\n        actionHistory: [],\n        actionHistoryVersions: [],\n        actionHistoryPtr: 0\n      };\n      this.nodes_executing = [];\n      this.nodes_actioning = [];\n      this.node_ancestorsCalculated = [];\n      this.nodes_executedAction = [];\n\n      // subgraph_data\n      this.inputs = {};\n      this.outputs = {};\n\n      // notify canvas to redraw\n      this.change();\n      this.sendActionToCanvas(\"clear\");\n    }\n\n    /**\r\n    * Apply config values to LGraph config object\r\n    * @method configApply\r\n     * @param {object} opts options to merge\r\n    */\n  }, {\n    key: \"configApply\",\n    value: function configApply(opts) {\n      /*\r\n      align_to_grid\r\n      links_ontop\r\n      */\n      this.config = Object.assign(this.config, opts);\n    }\n\n    /**\r\n    * Apply config values to LGraph config object\r\n    * @method configApply\r\n     * @param {object} opts options to merge\r\n    */\n  }, {\n    key: \"configApplyDefaults\",\n    value: function configApplyDefaults() {\n      var opts = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.graphDefaultConfig;\n      this.configApply(opts);\n    }\n\n    /**\r\n     * Attach Canvas to this graph\r\n     * @method attachCanvas\r\n     * @param {GraphCanvas} graph_canvas\r\n     */\n  }, {\n    key: \"attachCanvas\",\n    value: function attachCanvas(graphcanvas) {\n      var _this$list_of_graphca;\n      if (!graphcanvas instanceof _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LGraphCanvas) {\n        throw new Error(\"attachCanvas expects a LiteGraph.LGraphCanvas instance\");\n      }\n      if (graphcanvas.graph && graphcanvas.graph != this) {\n        graphcanvas.graph.detachCanvas(graphcanvas);\n      }\n      graphcanvas.graph = this;\n      (_this$list_of_graphca = this.list_of_graphcanvas) !== null && _this$list_of_graphca !== void 0 ? _this$list_of_graphca : this.list_of_graphcanvas = [];\n      this.list_of_graphcanvas.push(graphcanvas);\n    }\n\n    /**\r\n     * Detach Canvas from this graph\r\n     * @method detachCanvas\r\n     * @param {GraphCanvas} graph_canvas\r\n     */\n  }, {\n    key: \"detachCanvas\",\n    value: function detachCanvas(graphcanvas) {\n      if (!this.list_of_graphcanvas) {\n        return;\n      }\n      var pos = this.list_of_graphcanvas.indexOf(graphcanvas);\n      if (pos == -1) {\n        return;\n      }\n      graphcanvas.graph = null;\n      this.list_of_graphcanvas.splice(pos, 1);\n    }\n\n    /**\r\n     * Starts running this graph every interval milliseconds.\r\n     * @method start\r\n     * @param {number} interval amount of milliseconds between executions, if 0 then it renders to the monitor refresh rate\r\n     */\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this$onPlayEvent,\n        _this = this;\n      var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (this.status === LGraph.STATUS_RUNNING) {\n        return;\n      }\n      this.status = LGraph.STATUS_RUNNING;\n      (_this$onPlayEvent = this.onPlayEvent) === null || _this$onPlayEvent === void 0 || _this$onPlayEvent.call(this);\n      this.sendEventToAllNodes(\"onStart\");\n      this.starttime = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getTime();\n      this.last_update_time = this.starttime;\n      var onAnimationFrame = function onAnimationFrame() {\n        var _this$onBeforeStep, _this$onAfterStep;\n        if (_this.execution_timer_id !== -1) {\n          return;\n        }\n        window.requestAnimationFrame(onAnimationFrame);\n        (_this$onBeforeStep = _this.onBeforeStep) === null || _this$onBeforeStep === void 0 || _this$onBeforeStep.call(_this);\n        _this.runStep(1, !_this.catch_errors);\n        (_this$onAfterStep = _this.onAfterStep) === null || _this$onAfterStep === void 0 || _this$onAfterStep.call(_this);\n      };\n      if (interval === 0 && (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\" && window.requestAnimationFrame) {\n        this.execution_timer_id = -1;\n        onAnimationFrame();\n      } else {\n        this.execution_timer_id = setInterval(function () {\n          var _this$onBeforeStep2, _this$onAfterStep2;\n          (_this$onBeforeStep2 = _this.onBeforeStep) === null || _this$onBeforeStep2 === void 0 || _this$onBeforeStep2.call(_this);\n          _this.runStep(1, !_this.catch_errors);\n          (_this$onAfterStep2 = _this.onAfterStep) === null || _this$onAfterStep2 === void 0 || _this$onAfterStep2.call(_this);\n        }, interval);\n      }\n    }\n\n    /**\r\n     * Stops the execution loop of the graph\r\n     * @method stop execution\r\n     */\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _this$onStopEvent;\n      if (this.status == LGraph.STATUS_STOPPED) {\n        return;\n      }\n      this.status = LGraph.STATUS_STOPPED;\n      (_this$onStopEvent = this.onStopEvent) === null || _this$onStopEvent === void 0 || _this$onStopEvent.call(this);\n      if (this.execution_timer_id != null) {\n        if (this.execution_timer_id != -1) {\n          clearInterval(this.execution_timer_id);\n        }\n        this.execution_timer_id = null;\n      }\n      this.sendEventToAllNodes(\"onStop\");\n    }\n\n    /**\r\n     * Run N steps (cycles) of the graph\r\n     * @method runStep\r\n     * @param {number} num number of steps to run, default is 1\r\n     * @param {Boolean} do_not_catch_errors [optional] if you want to try/catch errors\r\n     * @param {number} limit max number of nodes to execute (used to execute from start to a node)\r\n     */\n  }, {\n    key: \"runStep\",\n    value: function runStep() {\n      var _this$_nodes_executab;\n      var num = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var do_not_catch_errors = arguments.length > 1 ? arguments[1] : undefined;\n      var limit = arguments.length > 2 ? arguments[2] : undefined;\n      var start = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getTime();\n      this.globaltime = 0.001 * (start - this.starttime);\n      var nodes = (_this$_nodes_executab = this._nodes_executable) !== null && _this$_nodes_executab !== void 0 ? _this$_nodes_executab : this._nodes;\n      if (!nodes) {\n        return;\n      }\n      limit || (limit = nodes.length);\n      if (do_not_catch_errors) {\n        var _this$onAfterExecute;\n        for (var i = 0; i < num; i++) {\n          var _this$onExecuteStep;\n          nodes.forEach(function (node) {\n            var _node$_waiting_action;\n            if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.use_deferred_actions && (_node$_waiting_action = node._waiting_actions) !== null && _node$_waiting_action !== void 0 && _node$_waiting_action.length) {\n              node.executePendingActions();\n            }\n            if (node.mode === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ALWAYS) {\n              var _node$doExecute;\n              (_node$doExecute = node.doExecute) === null || _node$doExecute === void 0 || _node$doExecute.call(node);\n            }\n          });\n          this.fixedtime += this.fixedtime_lapse;\n          (_this$onExecuteStep = this.onExecuteStep) === null || _this$onExecuteStep === void 0 || _this$onExecuteStep.call(this);\n        }\n        (_this$onAfterExecute = this.onAfterExecute) === null || _this$onAfterExecute === void 0 || _this$onAfterExecute.call(this);\n      } else {\n        // catch errors\n        try {\n          var _this$onAfterExecute2;\n          for (var _i = 0; _i < num; _i++) {\n            var _this$onExecuteStep2;\n            nodes.forEach(function (node) {\n              var _node$_waiting_action2;\n              if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.use_deferred_actions && (_node$_waiting_action2 = node._waiting_actions) !== null && _node$_waiting_action2 !== void 0 && _node$_waiting_action2.length) {\n                node.executePendingActions();\n              }\n              if (node.mode === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ALWAYS) {\n                var _node$doExecute2;\n                (_node$doExecute2 = node.doExecute) === null || _node$doExecute2 === void 0 || _node$doExecute2.call(node);\n              }\n            });\n            this.fixedtime += this.fixedtime_lapse;\n            (_this$onExecuteStep2 = this.onExecuteStep) === null || _this$onExecuteStep2 === void 0 || _this$onExecuteStep2.call(this);\n          }\n          (_this$onAfterExecute2 = this.onAfterExecute) === null || _this$onAfterExecute2 === void 0 || _this$onAfterExecute2.call(this);\n          this.errors_in_execution = false;\n        } catch (err) {\n          var _LiteGraph$log2;\n          this.errors_in_execution = true;\n          if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.throw_errors) {\n            throw err;\n          }\n          (_LiteGraph$log2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log2 === void 0 || _LiteGraph$log2.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Error during execution: \".concat(err));\n          this.stop();\n        }\n      }\n      var now = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getTime();\n      var elapsed = now - start;\n      if (elapsed == 0) {\n        elapsed = 1;\n      }\n      this.execution_time = 0.001 * elapsed;\n      this.globaltime += 0.001 * elapsed;\n      this.iteration += 1;\n      this.elapsed_time = (now - this.last_update_time) * 0.001;\n      this.last_update_time = now;\n      this.nodes_executing = [];\n      this.nodes_actioning = [];\n      this.node_ancestorsCalculated = [];\n      this.nodes_executedAction = [];\n    }\n\n    /**\r\n     * Updates the graph execution order according to relevance of the nodes (nodes with only outputs have more relevance than\r\n     * nodes with only inputs.\r\n     * @method updateExecutionOrder\r\n     */\n  }, {\n    key: \"updateExecutionOrder\",\n    value: function updateExecutionOrder() {\n      this._nodes_in_order = this.computeExecutionOrder(false);\n      this._nodes_executable = [];\n      for (var i = 0; i < this._nodes_in_order.length; ++i) {\n        if (this._nodes_in_order[i].onExecute) {\n          this._nodes_executable.push(this._nodes_in_order[i]);\n        }\n      }\n    }\n\n    /**\r\n     * Computes the execution order of nodes in the flow graph based on their connections and levels.\r\n     * @param {boolean} only_onExecute - Indicates whether to consider only nodes with an onExecute method.\r\n     * @param {boolean} set_level - If true, assigns levels to the nodes based on their connections.\r\n     * @returns {Array} An array of nodes in the calculated execution order.\r\n     *\r\n     * @TODO:This whole concept is a mistake.  Should call graph back from output nodes\r\n     */\n  }, {\n    key: \"computeExecutionOrder\",\n    value: function computeExecutionOrder(only_onExecute, set_level) {\n      var L = [];\n      var S = [];\n      var M = {};\n      var visited_links = {}; // to avoid repeating links\n      var remaining_links = {}; // to a\n\n      // search for the nodes without inputs (starting nodes)\n      for (var i = 0, _l = this._nodes.length; i < _l; ++i) {\n        var _node = this._nodes[i];\n        if (only_onExecute && !_node.onExecute) {\n          continue;\n        }\n        M[_node.id] = _node; // add to pending nodes\n\n        var num = 0; // num of input connections\n        if (_node.inputs) {\n          for (var j = 0, l2 = _node.inputs.length; j < l2; j++) {\n            if (_node.inputs[j] && _node.inputs[j].link != null) {\n              num += 1;\n            }\n          }\n        }\n        if (num == 0) {\n          // is a starting node\n          S.push(_node);\n          if (set_level) {\n            _node._level = 1;\n          }\n        } else {\n          // num of input links\n          if (set_level) {\n            _node._level = 0;\n          }\n          remaining_links[_node.id] = num;\n        }\n      }\n      while (S.length != 0) {\n        // get an starting node\n        var node = S.shift();\n        L.push(node); // add to ordered list\n        delete M[node.id]; // remove from the pending nodes\n\n        if (!node.outputs) {\n          continue;\n        }\n\n        // for every output\n        for (var _i2 = 0; _i2 < node.outputs.length; _i2++) {\n          var output = node.outputs[_i2];\n          // not connected\n          if (output == null || output.links == null || output.links.length == 0) {\n            continue;\n          }\n\n          // for every connection\n          for (var _j = 0; _j < output.links.length; _j++) {\n            var link_id = output.links[_j];\n            var link = this.links[link_id];\n            if (!link) {\n              continue;\n            }\n\n            // already visited link (ignore it)\n            if (visited_links[link.id]) {\n              continue;\n            }\n            var target_node = this.getNodeById(link.target_id);\n            if (target_node == null) {\n              visited_links[link.id] = true;\n              continue;\n            }\n            if (set_level && (!target_node._level || target_node._level <= node._level)) {\n              target_node._level = node._level + 1;\n            }\n            visited_links[link.id] = true; // mark as visited\n            remaining_links[target_node.id] -= 1; // reduce the number of links remaining\n            if (remaining_links[target_node.id] == 0) {\n              S.push(target_node);\n            } // if no more links, then add to starters array\n          }\n        }\n      }\n\n      // the remaining ones (loops)\n      for (var _i3 in M) {\n        L.push(M[_i3]);\n      }\n      if (L.length != this._nodes.length && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) {\n        var _LiteGraph$warn;\n        (_LiteGraph$warn = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn === void 0 || _LiteGraph$warn.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"something went wrong, nodes missing\");\n      }\n      var l = L.length;\n\n      // save order number in the node\n      for (var _i4 = 0; _i4 < l; ++_i4) {\n        L[_i4].order = _i4;\n      }\n\n      // sort now by priority\n      L = L.sort(function (A, B) {\n        var Ap = A.constructor.priority || A.priority || 0;\n        var Bp = B.constructor.priority || B.priority || 0;\n        if (Ap == Bp) {\n          // if same priority, sort by order\n          return A.order - B.order;\n        }\n        return Ap - Bp; // sort by priority\n      });\n\n      // save order number in the node, again...\n      for (var _i5 = 0; _i5 < l; ++_i5) {\n        L[_i5].order = _i5;\n      }\n      return L;\n    }\n\n    /**\r\n     * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs recursively.\r\n     * It doesn't include the node itself\r\n     * @method getAncestors\r\n     * @return {Array} an array with all the LiteGraph.LGraphNodes that affect this node, in order of execution\r\n     */\n  }, {\n    key: \"getAncestors\",\n    value: function getAncestors(node) {\n      var optsIn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var optsDef = {\n        modesSkip: [],\n        modesOnly: [],\n        typesSkip: [],\n        typesOnly: []\n      };\n      var opts = Object.assign(optsDef, optsIn);\n      var ancestors = [];\n      var ancestorsIds = [];\n      var pending = [node];\n      var visited = {};\n      while (pending.length) {\n        var current = pending.shift();\n        if (!current) {\n          continue;\n        }\n        if (visited[current.id]) {\n          continue;\n        }\n        // mark as visited\n        visited[current.id] = true;\n\n        // add to ancestors\n        if (current.id != node.id) {\n          // mode check\n          if (opts.modesSkip && opts.modesSkip.length) {\n            if (opts.modesSkip.indexOf(current.mode) != -1) {\n              // DBG(\"mode skip \"+current.id+\":\"+current.order+\" :: \"+current.mode);\n              continue;\n            }\n          }\n          if (opts.modesOnly && opts.modesOnly.length) {\n            if (opts.modesOnly.indexOf(current.mode) == -1) {\n              // DBG(\"mode only \"+current.id+\":\"+current.order+\" :: \"+current.mode);\n              continue;\n            }\n          }\n          if (ancestorsIds.indexOf(current.id) == -1) {\n            ancestors.push(current);\n            ancestorsIds.push(current.id);\n            // DBG(\"push current \"+current.id+\":\"+current.order);\n          }\n        }\n\n        // get its inputs\n        if (!current.inputs) {\n          continue;\n        }\n        for (var i = 0; i < current.inputs.length; ++i) {\n          var input = current.getInputNode(i);\n          if (!input) continue;\n          var inputType = current.inputs[i].type;\n\n          // type check\n          if (opts.typesSkip && opts.typesSkip.length) {\n            if (opts.typesSkip.indexOf(inputType) != -1) {\n              // DBG(\"type skip \"+input.id+\":\"+input.order+\" :: \"+inputType);\n              continue;\n            }\n          }\n          if (opts.typesOnly && opts.typesOnly.length) {\n            if (opts.typesOnly.indexOf(input.mode) == -1) {\n              // DBG(\"type only \"+input.id+\":\"+input.order+\" :: \"+inputType);\n              continue;\n            }\n          }\n\n          // DBG(\"input \"+i+\" \"+input.id+\":\"+input.order);\n          // push em in\n          if (ancestorsIds.indexOf(input.id) == -1) {\n            if (!visited[input.id]) {\n              pending.push(input);\n              // DBG(\"push input \"+input.id+\":\"+input.order);\n            }\n          }\n        }\n      }\n      ancestors.sort(function (a, b) {\n        return a.order - b.order;\n      });\n      return ancestors;\n    }\n\n    /**\r\n     * Positions every node in a more readable manner\r\n     * @method arrange\r\n     */\n  }, {\n    key: \"arrange\",\n    value: function arrange() {\n      var margin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n      var layout = arguments.length > 1 ? arguments[1] : undefined;\n      var nodes = this.computeExecutionOrder(false, true);\n      var columns = [];\n      for (var i = 0; i < nodes.length; ++i) {\n        var _columns$col;\n        var node = nodes[i];\n        var col = node._level || 1;\n        (_columns$col = columns[col]) !== null && _columns$col !== void 0 ? _columns$col : columns[col] = [];\n        columns[col].push(node);\n      }\n      var x = margin;\n      for (var _i6 = 0; _i6 < columns.length; ++_i6) {\n        var column = columns[_i6];\n        if (!column) {\n          continue;\n        }\n        var max_size = 100;\n        var y = margin + _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT;\n        for (var j = 0; j < column.length; ++j) {\n          var _node2 = column[j];\n          _node2.pos[0] = layout == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.VERTICAL_LAYOUT ? y : x;\n          _node2.pos[1] = layout == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.VERTICAL_LAYOUT ? x : y;\n          var max_size_index = layout == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.VERTICAL_LAYOUT ? 1 : 0;\n          if (_node2.size[max_size_index] > max_size) {\n            max_size = _node2.size[max_size_index];\n          }\n          var node_size_index = layout == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.VERTICAL_LAYOUT ? 0 : 1;\n          y += _node2.size[node_size_index] + margin + _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT;\n        }\n        x += max_size + margin;\n      }\n      this.setDirtyCanvas(true, true);\n    }\n\n    /**\r\n     * Returns the amount of time the graph has been running in milliseconds\r\n     * @method getTime\r\n     * @return {number} number of milliseconds the graph has been running\r\n     */\n  }, {\n    key: \"getTime\",\n    value: function getTime() {\n      return this.globaltime;\n    }\n\n    /**\r\n     * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in context where the time increments should be constant\r\n     * @method getFixedTime\r\n     * @return {number} number of milliseconds the graph has been running\r\n     */\n  }, {\n    key: \"getFixedTime\",\n    value: function getFixedTime() {\n      return this.fixedtime;\n    }\n\n    /**\r\n     * Returns the amount of time it took to compute the latest iteration. Take into account that this number could be not correct\r\n     * if the nodes are using graphical actions\r\n     * @method getElapsedTime\r\n     * @return {number} number of milliseconds it took the last cycle\r\n     */\n  }, {\n    key: \"getElapsedTime\",\n    value: function getElapsedTime() {\n      return this.elapsed_time;\n    }\n\n    /**\r\n     * Sends an event to all the nodes, useful to trigger stuff\r\n     * @method sendEventToAllNodes\r\n     * @param {String} eventname the name of the event (function to be called)\r\n     * @param {Array} params parameters in array format\r\n     */\n  }, {\n    key: \"sendEventToAllNodes\",\n    value: function sendEventToAllNodes(eventname, params) {\n      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ALWAYS;\n      var nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;\n      if (!nodes) {\n        return;\n      }\n      for (var j = 0, l = nodes.length; j < l; ++j) {\n        var node = nodes[j];\n        if (node.constructor === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.Subgraph && eventname !== \"onExecute\") {\n          if (node.mode == mode) {\n            node.sendEventToAllNodes(eventname, params, mode);\n          }\n          continue;\n        }\n        if (!node[eventname] || node.mode !== mode) {\n          continue;\n        }\n        if (params === undefined) {\n          node[eventname]();\n        } else if (Array.isArray(params)) {\n          node[eventname].apply(node, params);\n        } else {\n          node[eventname](params);\n        }\n      }\n    }\n\n    /**\r\n     * Sends an action with parameters to the connected GraphCanvas instances for processing.\r\n     * @param {string} action - The action to be performed on the GraphCanvas instances.\r\n     * @param {Array} params - An array of parameters to be passed to the action method.\r\n     */\n  }, {\n    key: \"sendActionToCanvas\",\n    value: function sendActionToCanvas(action, params) {\n      if (!this.list_of_graphcanvas) {\n        return;\n      }\n      var _iterator = _createForOfIteratorHelper(this.list_of_graphcanvas),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var c = _step.value;\n          if (c[action] && params) {\n            c[action].apply(c, _toConsumableArray(params));\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    /**\r\n     * Adds a new node instance to this graph\r\n     * @method add\r\n     * @param {LiteGraph.LGraphNode} node the instance of the node\r\n     */\n  }, {\n    key: \"add\",\n    value: function add(node, skip_compute_order) {\n      var _node$onAdded, _this$onNodeAdded;\n      var optsIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var optsDef = {\n        doProcessChange: true,\n        doCalcSize: true\n      };\n      var opts = Object.assign(optsDef, optsIn);\n      if (!node) {\n        return;\n      }\n\n      // groups\n      if (node.constructor === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LGraphGroup) {\n        this._groups.push(node);\n        this.setDirtyCanvas(true);\n        this.change();\n        node.graph = this;\n        this.onGraphChanged({\n          action: \"groupAdd\",\n          doSave: opts.doProcessChange\n        });\n        return;\n      }\n\n      // nodes\n      if (node.id != -1 && this._nodes_by_id[node.id] != null) {\n        var _LiteGraph$warn2;\n        (_LiteGraph$warn2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn2 === void 0 || _LiteGraph$warn2.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"LiteGraph: there is already a node with this ID, changing it\");\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.use_uuids) {\n          node.id = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.uuidv4();\n        } else {\n          node.id = ++this.last_node_id;\n        }\n      }\n      if (this._nodes.length >= _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.MAX_NUMBER_OF_NODES) {\n        throw new Error(\"LiteGraph: max number of nodes in a graph reached\");\n      }\n\n      // give him an id\n      if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.use_uuids) {\n        if (node.id == null || node.id == -1) node.id = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.uuidv4();\n      } else {\n        if (node.id == null || node.id == -1) {\n          node.id = ++this.last_node_id;\n        } else if (this.last_node_id < node.id) {\n          this.last_node_id = node.id;\n        }\n      }\n      node.graph = this;\n      this.onGraphChanged({\n        action: \"nodeAdd\",\n        doSave: opts.doProcessChange\n      });\n      this._nodes.push(node);\n      this._nodes_by_id[node.id] = node;\n      (_node$onAdded = node.onAdded) === null || _node$onAdded === void 0 || _node$onAdded.call(node, this);\n      if (this.config.align_to_grid) {\n        node.alignToGrid();\n      }\n      if (!skip_compute_order) {\n        this.updateExecutionOrder();\n      }\n      (_this$onNodeAdded = this.onNodeAdded) === null || _this$onNodeAdded === void 0 || _this$onNodeAdded.call(this, node);\n      if (opts.doCalcSize) {\n        node.setSize(node.computeSize());\n      }\n      this.setDirtyCanvas(true);\n      this.change();\n      return node; // to chain actions\n    }\n\n    /**\r\n     * Removes a node from the graph\r\n     * @method remove\r\n     * @param {LiteGraph.LGraphNode} node the instance of the node\r\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      var _node$onRemoved2, _this$onNodeRemoved;\n      if (node.constructor === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LGraphGroup) {\n        var index = this._groups.indexOf(node);\n        if (index != -1) {\n          this._groups.splice(index, 1);\n        }\n        node.graph = null;\n        this.onGraphChanged({\n          action: \"groupRemove\"\n        });\n        this.setDirtyCanvas(true, true);\n        this.change();\n        return;\n      }\n      if (this._nodes_by_id[node.id] == null) {\n        return;\n      } // not found\n\n      if (node.ignore_remove) {\n        return;\n      } // cannot be removed\n\n      // this.beforeChange(); // sure? - almost sure is wrong\n\n      // disconnect inputs\n      if (node.inputs) {\n        for (var i = 0; i < node.inputs.length; i++) {\n          var slot = node.inputs[i];\n          if (slot.link != null) {\n            node.disconnectInput(i, {\n              doProcessChange: false\n            });\n          }\n        }\n      }\n\n      // disconnect outputs\n      if (node.outputs) {\n        for (var _i7 = 0; _i7 < node.outputs.length; _i7++) {\n          var _slot = node.outputs[_i7];\n          if (_slot.links != null && _slot.links.length) {\n            node.disconnectOutput(_i7, false, {\n              doProcessChange: false\n            });\n          }\n        }\n      }\n\n      // node.id = -1; //why?\n\n      // callback\n      (_node$onRemoved2 = node.onRemoved) === null || _node$onRemoved2 === void 0 || _node$onRemoved2.call(node);\n      node.graph = null;\n      this.onGraphChanged({\n        action: \"nodeRemove\"\n      });\n\n      // remove from canvas render\n      if (this.list_of_graphcanvas) {\n        for (var _i8 = 0; _i8 < this.list_of_graphcanvas.length; ++_i8) {\n          var canvas = this.list_of_graphcanvas[_i8];\n          if (canvas.selected_nodes[node.id]) {\n            delete canvas.selected_nodes[node.id];\n          }\n          if (canvas.node_dragged == node) {\n            canvas.node_dragged = null;\n          }\n        }\n      }\n\n      // remove from containers\n      var pos = this._nodes.indexOf(node);\n      if (pos != -1) {\n        this._nodes.splice(pos, 1);\n      }\n      delete this._nodes_by_id[node.id];\n      (_this$onNodeRemoved = this.onNodeRemoved) === null || _this$onNodeRemoved === void 0 || _this$onNodeRemoved.call(this, node);\n\n      // close panels\n      this.sendActionToCanvas(\"checkPanels\");\n      this.setDirtyCanvas(true, true);\n      // this.afterChange(); // sure? - almost sure is wrong\n      this.change();\n      this.updateExecutionOrder();\n    }\n\n    /**\r\n     * Returns a node by its id.\r\n     * @method getNodeById\r\n     * @param {Number} id\r\n     */\n  }, {\n    key: \"getNodeById\",\n    value: function getNodeById(id) {\n      if (id == null) {\n        return null;\n      }\n      return this._nodes_by_id[id];\n    }\n\n    /**\r\n     * Returns a list of nodes that matches a class\r\n     * @method findNodesByClass\r\n     * @param {Class} classObject the class itself (not an string)\r\n     * @return {Array} a list with all the nodes of this type\r\n     */\n  }, {\n    key: \"findNodesByClass\",\n    value: function findNodesByClass(classObject) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      result = this._nodes.filter(function (node) {\n        return node.constructor === classObject;\n      });\n      return result;\n    }\n\n    /**\r\n     * Returns a list of nodes that matches a type\r\n     * @method findNodesByType\r\n     * @param {String} type the name of the node type\r\n     * @return {Array} a list with all the nodes of this type\r\n     */\n  }, {\n    key: \"findNodesByType\",\n    value: function findNodesByType(type) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var lowerCaseType = type.toLowerCase();\n      result = this._nodes.filter(function (node) {\n        return node.type.toLowerCase() === lowerCaseType;\n      });\n      return result;\n    }\n\n    /**\r\n     * Returns the first node that matches a name in its title\r\n     * @method findNodeByTitle\r\n     * @param {String} name the name of the node to search\r\n     * @return {Node} the node or null\r\n     */\n  }, {\n    key: \"findNodeByTitle\",\n    value: function findNodeByTitle(title) {\n      var _this$_nodes$find;\n      return (_this$_nodes$find = this._nodes.find(function (node) {\n        return node.title === title;\n      })) !== null && _this$_nodes$find !== void 0 ? _this$_nodes$find : null;\n    }\n\n    /**\r\n     * Returns a list of nodes that matches a name\r\n     * @method findNodesByTitle\r\n     * @param {String} name the name of the node to search\r\n     * @return {Array} a list with all the nodes with this name\r\n     */\n  }, {\n    key: \"findNodesByTitle\",\n    value: function findNodesByTitle(title) {\n      return this._nodes.filter(function (node) {\n        return node.title === title;\n      });\n    }\n\n    /**\r\n     * Returns the top-most node in this position of the canvas\r\n     * @method getNodeOnPos\r\n     * @param {number} x the x coordinate in canvas space\r\n     * @param {number} y the y coordinate in canvas space\r\n     * @param {Array} nodes_list a list with all the nodes to search from, by default is all the nodes in the graph\r\n     * @return {LiteGraph.LGraphNode} the node at this position or null\r\n     */\n  }, {\n    key: \"getNodeOnPos\",\n    value: function getNodeOnPos(x, y) {\n      var _nodes_list$reverse$f;\n      var nodes_list = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._nodes;\n      var margin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      return (_nodes_list$reverse$f = nodes_list.reverse().find(function (node) {\n        return node.isPointInside(x, y, margin);\n      })) !== null && _nodes_list$reverse$f !== void 0 ? _nodes_list$reverse$f : null;\n    }\n\n    /**\r\n     * Returns the top-most group in that position\r\n     * @method getGroupOnPos\r\n     * @param {number} x the x coordinate in canvas space\r\n     * @param {number} y the y coordinate in canvas space\r\n     * @return {LiteGraph.LGraphGroup} the group or null\r\n     */\n  }, {\n    key: \"getGroupOnPos\",\n    value: function getGroupOnPos(x, y) {\n      var _this$_groups$find;\n      return (_this$_groups$find = this._groups.find(function (group) {\n        return group.isPointInside(x, y, 2, true);\n      })) !== null && _this$_groups$find !== void 0 ? _this$_groups$find : null;\n    }\n\n    /**\r\n     * Checks that the node type matches the node type registered, used when replacing a nodetype by a newer version during execution\r\n     * this replaces the ones using the old version with the new version\r\n     * @method checkNodeTypes\r\n     */\n  }, {\n    key: \"checkNodeTypes\",\n    value: function checkNodeTypes() {\n      for (var i = 0; i < this._nodes.length; i++) {\n        var _LiteGraph$log3;\n        var node = this._nodes[i];\n        var ctor = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registered_node_types[node.type];\n        if (node.constructor == ctor) {\n          continue;\n        }\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) (_LiteGraph$log3 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log3 === void 0 || _LiteGraph$log3.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"node being replaced by newer version: \".concat(node.type));\n        var newnode = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.createNode(node.type);\n        this._nodes[i] = newnode;\n        newnode.configure(node.serialize());\n        newnode.graph = this;\n        this._nodes_by_id[newnode.id] = newnode;\n        if (node.inputs) {\n          newnode.inputs = node.inputs.concat();\n        }\n        if (node.outputs) {\n          newnode.outputs = node.outputs.concat();\n        }\n      }\n      this.updateExecutionOrder();\n    }\n\n    /**\r\n     * Executes an action on the GraphInput nodes based on the provided action name and parameters.\r\n     * @param {string} action - The name of the action to be executed on the GraphInput nodes.\r\n     * @param {any} param - The parameter to pass to the action method.\r\n     * @param {object} options - Additional options for the action.\r\n     */\n  }, {\n    key: \"onAction\",\n    value: function onAction(action, param, options) {\n      this._input_nodes = this.findNodesByClass(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.GraphInput, this._input_nodes);\n      for (var i = 0; i < this._input_nodes.length; ++i) {\n        var node = this._input_nodes[i];\n        if (node.properties.name != action) {\n          continue;\n        }\n        // wrap node.onAction(action, param);\n        node.actionDo(action, param, options);\n        break;\n      }\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(action, param) {\n      var _this$onTrigger;\n      (_this$onTrigger = this.onTrigger) === null || _this$onTrigger === void 0 || _this$onTrigger.call(this, action, param);\n    }\n\n    /**\r\n     * Tell this graph it has a global graph input of this type\r\n     * @method addGlobalInput\r\n     * @param {String} name\r\n     * @param {String} type\r\n     * @param {*} value [optional]\r\n     */\n  }, {\n    key: \"addInput\",\n    value: function addInput(name, type, value) {\n      var _this$onInputAdded, _this$onInputsOutputs;\n      var input = this.inputs[name];\n      if (input) {\n        // already exist\n        return;\n      }\n      this.beforeChange();\n      this.inputs[name] = {\n        name: name,\n        type: type,\n        value: value\n      };\n      this.onGraphChanged({\n        action: \"addInput\"\n      });\n      this.afterChange();\n      (_this$onInputAdded = this.onInputAdded) === null || _this$onInputAdded === void 0 || _this$onInputAdded.call(this, name, type);\n      (_this$onInputsOutputs = this.onInputsOutputsChange) === null || _this$onInputsOutputs === void 0 || _this$onInputsOutputs.call(this);\n    }\n\n    /**\r\n     * Assign a data to the global graph input\r\n     * @method setGlobalInputData\r\n     * @param {String} name\r\n     * @param {*} data\r\n     */\n  }, {\n    key: \"setInputData\",\n    value: function setInputData(name, data) {\n      var input = this.inputs[name];\n      if (!input) {\n        return;\n      }\n      input.value = data;\n    }\n\n    /**\r\n     * Returns the current value of a global graph input\r\n     * @method getInputData\r\n     * @param {String} name\r\n     * @return {*} the data\r\n     */\n  }, {\n    key: \"getInputData\",\n    value: function getInputData(name) {\n      var input = this.inputs[name];\n      if (!input) {\n        return null;\n      }\n      return input.value;\n    }\n\n    /**\r\n     * Changes the name of a global graph input\r\n     * @method renameInput\r\n     * @param {String} old_name\r\n     * @param {String} new_name\r\n     */\n  }, {\n    key: \"renameInput\",\n    value: function renameInput(old_name, name) {\n      var _this$onInputRenamed, _this$onInputsOutputs2;\n      if (name == old_name) {\n        return;\n      }\n      if (!this.inputs[old_name]) {\n        return false;\n      }\n      if (this.inputs[name]) {\n        var _LiteGraph$error;\n        (_LiteGraph$error = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.error) === null || _LiteGraph$error === void 0 || _LiteGraph$error.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"there is already one input with that name\");\n        return false;\n      }\n      this.inputs[name] = this.inputs[old_name];\n      delete this.inputs[old_name];\n      this.onGraphChanged({\n        action: \"renameInput\"\n      });\n      (_this$onInputRenamed = this.onInputRenamed) === null || _this$onInputRenamed === void 0 || _this$onInputRenamed.call(this, old_name, name);\n      (_this$onInputsOutputs2 = this.onInputsOutputsChange) === null || _this$onInputsOutputs2 === void 0 || _this$onInputsOutputs2.call(this);\n    }\n\n    /**\r\n     * Changes the type of a global graph input\r\n     * @method changeInputType\r\n     * @param {String} name\r\n     * @param {String} type\r\n     */\n  }, {\n    key: \"changeInputType\",\n    value: function changeInputType(name, type) {\n      var _this$onInputTypeChan;\n      if (!this.inputs[name]) {\n        return false;\n      }\n      if (this.inputs[name].type && String(this.inputs[name].type).toLowerCase() == String(type).toLowerCase()) {\n        return;\n      }\n      this.inputs[name].type = type;\n      this.onGraphChanged({\n        action: \"changeInputType\"\n      });\n      (_this$onInputTypeChan = this.onInputTypeChanged) === null || _this$onInputTypeChan === void 0 || _this$onInputTypeChan.call(this, name, type);\n    }\n\n    /**\r\n     * Removes a global graph input\r\n     * @method removeInput\r\n     * @param {String} name\r\n     * @param {String} type\r\n     */\n  }, {\n    key: \"removeInput\",\n    value: function removeInput(name) {\n      var _this$onInputRemoved, _this$onInputsOutputs3;\n      if (!this.inputs[name]) {\n        return false;\n      }\n      delete this.inputs[name];\n      this.onGraphChanged({\n        action: \"graphRemoveInput\"\n      });\n      (_this$onInputRemoved = this.onInputRemoved) === null || _this$onInputRemoved === void 0 || _this$onInputRemoved.call(this, name);\n      (_this$onInputsOutputs3 = this.onInputsOutputsChange) === null || _this$onInputsOutputs3 === void 0 || _this$onInputsOutputs3.call(this);\n      return true;\n    }\n\n    /**\r\n     * Creates a global graph output\r\n     * @method addOutput\r\n     * @param {String} name\r\n     * @param {String} type\r\n     * @param {*} value\r\n     */\n  }, {\n    key: \"addOutput\",\n    value: function addOutput(name, type, value) {\n      var _this$onOutputAdded, _this$onInputsOutputs4;\n      this.outputs[name] = {\n        name: name,\n        type: type,\n        value: value\n      };\n      this.onGraphChanged({\n        action: \"addOutput\"\n      });\n      (_this$onOutputAdded = this.onOutputAdded) === null || _this$onOutputAdded === void 0 || _this$onOutputAdded.call(this, name, type);\n      (_this$onInputsOutputs4 = this.onInputsOutputsChange) === null || _this$onInputsOutputs4 === void 0 || _this$onInputsOutputs4.call(this);\n    }\n\n    /**\r\n     * Assign a data to the global output\r\n     * @method setOutputData\r\n     * @param {String} name\r\n     * @param {String} value\r\n     */\n  }, {\n    key: \"setOutputData\",\n    value: function setOutputData(name, value) {\n      var output = this.outputs[name];\n      if (!output) {\n        return;\n      }\n      output.value = value;\n    }\n\n    /**\r\n     * Returns the current value of a global graph output\r\n     * @method getOutputData\r\n     * @param {String} name\r\n     * @return {*} the data\r\n     */\n  }, {\n    key: \"getOutputData\",\n    value: function getOutputData(name) {\n      var output = this.outputs[name];\n      if (!output) {\n        return null;\n      }\n      return output.value;\n    }\n\n    /**\r\n     * Renames a global graph output\r\n     * @method renameOutput\r\n     * @param {String} old_name\r\n     * @param {String} new_name\r\n     */\n  }, {\n    key: \"renameOutput\",\n    value: function renameOutput(old_name, name) {\n      var _this$onOutputRenamed, _this$onInputsOutputs5;\n      if (!this.outputs[old_name]) {\n        return false;\n      }\n      if (this.outputs[name]) {\n        var _LiteGraph$error2;\n        (_LiteGraph$error2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.error) === null || _LiteGraph$error2 === void 0 || _LiteGraph$error2.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"there is already one output with that name\");\n        return false;\n      }\n      this.outputs[name] = this.outputs[old_name];\n      delete this.outputs[old_name];\n      this._version++;\n      (_this$onOutputRenamed = this.onOutputRenamed) === null || _this$onOutputRenamed === void 0 || _this$onOutputRenamed.call(this, old_name, name);\n      (_this$onInputsOutputs5 = this.onInputsOutputsChange) === null || _this$onInputsOutputs5 === void 0 || _this$onInputsOutputs5.call(this);\n    }\n\n    /**\r\n     * Changes the type of a global graph output\r\n     * @method changeOutputType\r\n     * @param {String} name\r\n     * @param {String} type\r\n     */\n  }, {\n    key: \"changeOutputType\",\n    value: function changeOutputType(name, type) {\n      var _this$onOutputTypeCha;\n      if (!this.outputs[name]) {\n        return false;\n      }\n      if (this.outputs[name].type && String(this.outputs[name].type).toLowerCase() == String(type).toLowerCase()) {\n        return;\n      }\n      this.outputs[name].type = type;\n      this.onGraphChanged({\n        action: \"changeOutputType\"\n      });\n      (_this$onOutputTypeCha = this.onOutputTypeChanged) === null || _this$onOutputTypeCha === void 0 || _this$onOutputTypeCha.call(this, name, type);\n    }\n\n    /**\r\n     * Removes a global graph output\r\n     * @method removeOutput\r\n     * @param {String} name\r\n     */\n  }, {\n    key: \"removeOutput\",\n    value: function removeOutput(name) {\n      var _this$onOutputRemoved, _this$onInputsOutputs6;\n      if (!this.outputs[name]) {\n        return false;\n      }\n      delete this.outputs[name];\n      this.onGraphChanged({\n        action: \"removeOutput\"\n      });\n      (_this$onOutputRemoved = this.onOutputRemoved) === null || _this$onOutputRemoved === void 0 || _this$onOutputRemoved.call(this, name);\n      (_this$onInputsOutputs6 = this.onInputsOutputsChange) === null || _this$onInputsOutputs6 === void 0 || _this$onInputsOutputs6.call(this);\n      return true;\n    }\n\n    /**\r\n     * Triggers the 'onTrigger' method on nodes with a specific title by passing a value to them.\r\n     * @param {string} name - The title of the nodes to trigger.\r\n     * @param {any} value - The value to pass to the 'onTrigger' method of the nodes.\r\n     */\n  }, {\n    key: \"triggerInput\",\n    value: function triggerInput(name, value) {\n      var nodes = this.findNodesByTitle(name);\n      for (var i = 0; i < nodes.length; ++i) {\n        nodes[i].onTrigger(value);\n      }\n    }\n\n    /**\r\n     * Sets a callback function on nodes with a specific title by invoking their 'setTrigger' method.\r\n     * @param {string} name - The title of the nodes to set the callback function on.\r\n     * @param {Function} func - The callback function to be set on the nodes.\r\n     */\n  }, {\n    key: \"setCallback\",\n    value: function setCallback(name, func) {\n      var nodes = this.findNodesByTitle(name);\n      for (var i = 0; i < nodes.length; ++i) {\n        nodes[i].setTrigger(func);\n      }\n    }\n\n    /**\r\n     * Executes actions before a change with the provided information detail.\r\n     * Calls the 'onBeforeChange' function on the class instance and sends the action to connected GraphCanvas instances.\r\n     * @param {object} info - The information detail about the change.\r\n     */\n  }, {\n    key: \"beforeChange\",\n    value: function beforeChange(info) {\n      var _this$onBeforeChange;\n      (_this$onBeforeChange = this.onBeforeChange) === null || _this$onBeforeChange === void 0 || _this$onBeforeChange.call(this, this, info);\n      this.sendActionToCanvas(\"onBeforeChange\", this);\n    }\n\n    /**\r\n     * Executes actions after a change with the provided information detail.\r\n     * Calls the 'onAfterChange' function on the class instance and sends the action to connected GraphCanvas instances.\r\n     * @param {object} info - The information detail about the change.\r\n     */\n  }, {\n    key: \"afterChange\",\n    value: function afterChange(info) {\n      var _this$onAfterChange;\n      (_this$onAfterChange = this.onAfterChange) === null || _this$onAfterChange === void 0 || _this$onAfterChange.call(this, this, info);\n      this.sendActionToCanvas(\"onAfterChange\", this);\n    }\n\n    /**\r\n     * Handles changes in node connections and triggers related actions.\r\n     * Updates the execution order, calls the 'onConnectionChange' function on the class instance and connected GraphCanvas instances, and increments the version.\r\n     * @param {object} node - The node where the connection change occurred.\r\n     * @param {object} link_info - Information about the changed connection.\r\n     */\n  }, {\n    key: \"connectionChange\",\n    value: function connectionChange(node) {\n      var _this$onConnectionCha;\n      this.updateExecutionOrder();\n      (_this$onConnectionCha = this.onConnectionChange) === null || _this$onConnectionCha === void 0 || _this$onConnectionCha.call(this, node);\n      this.onGraphChanged({\n        action: \"connectionChange\",\n        doSave: false\n      });\n      this.sendActionToCanvas(\"onConnectionChange\");\n    }\n\n    /**\r\n     * returns if the graph is in live mode\r\n     * @method isLive\r\n     */\n  }, {\n    key: \"isLive\",\n    value: function isLive() {\n      if (!this.list_of_graphcanvas) {\n        return false;\n      }\n      for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {\n        var c = this.list_of_graphcanvas[i];\n        if (c.live_mode) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\r\n     * clears the triggered slot animation in all links (stop visual animation)\r\n     * @method clearTriggeredSlots\r\n     */\n  }, {\n    key: \"clearTriggeredSlots\",\n    value: function clearTriggeredSlots() {\n      for (var i in this.links) {\n        var _link_info;\n        var link_info = this.links[i];\n        if (!link_info) {\n          continue;\n        }\n        (_link_info = link_info)._last_time && (_link_info._last_time = 0);\n      }\n    }\n\n    /**\r\n     * Indicates a visual change in the graph (not the structure) and triggers related actions.\r\n     * Logs a message if in debug mode, sends a 'setDirty' action with parameters to connected GraphCanvas instances, and calls the 'on_change' function on the class instance.\r\n     * @method change\r\n     */\n  }, {\n    key: \"change\",\n    value: function change() {\n      var _LiteGraph$log4, _this$on_change;\n      (_LiteGraph$log4 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log4 === void 0 || _LiteGraph$log4.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Graph visually changed\");\n      this.sendActionToCanvas(\"setDirty\", [true, true]);\n      (_this$on_change = this.on_change) === null || _this$on_change === void 0 || _this$on_change.call(this, this);\n    }\n  }, {\n    key: \"setDirtyCanvas\",\n    value: function setDirtyCanvas(fg, bg) {\n      this.sendActionToCanvas(\"setDirty\", [fg, bg]);\n    }\n\n    /**\r\n     * Destroys a link\r\n     * @method removeLink\r\n     * @param {Number} link_id\r\n     */\n  }, {\n    key: \"removeLink\",\n    value: function removeLink(link_id) {\n      var link = this.links[link_id];\n      if (!link) {\n        return;\n      }\n      var node = this.getNodeById(link.target_id);\n      if (node) {\n        this.beforeChange();\n        node.disconnectInput(link.target_slot); /* , optsIn */\n        this.afterChange();\n      }\n    }\n\n    /**\r\n     * Creates a Object containing all the info about this graph, it can be serialized\r\n     * @method serialize\r\n     * @return {Object} value of the node\r\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var _this$onSerialize;\n      var nodesInfo = this._nodes.map(function (node) {\n        return node.serialize();\n      });\n\n      // pack link info into a non-verbose format\n      var links = [];\n      for (var i in this.links) {\n        // links is an OBJECT\n        var link = this.links[i];\n        if (!link.serialize) {\n          var _LiteGraph$warn3;\n          // weird bug I havent solved yet\n          (_LiteGraph$warn3 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn3 === void 0 || _LiteGraph$warn3.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"weird LLink bug, link info is not a LLink but a regular object\");\n          var link2 = new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LLink();\n          for (var j in link) {\n            link2[j] = link[j];\n          }\n          this.links[i] = link2;\n          link = link2;\n        }\n        links.push(link.serialize());\n      }\n      var groupsInfo = this._groups.map(function (group) {\n        return group.serialize();\n      });\n      var data = {\n        last_node_id: this.last_node_id,\n        last_link_id: this.last_link_id,\n        nodes: nodesInfo,\n        links: links,\n        groups: groupsInfo,\n        config: this.config,\n        extra: this.extra,\n        version: _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.VERSION\n      };\n      (_this$onSerialize = this.onSerialize) === null || _this$onSerialize === void 0 || _this$onSerialize.call(this, data);\n      return data;\n    }\n\n    /**\r\n     * Configure a graph from a JSON string\r\n     * @method configure\r\n     * @param {String} str configure a graph from a JSON string\r\n     * @param {Boolean} returns if there was any error parsing\r\n     */\n  }, {\n    key: \"configure\",\n    value: function configure(data, keep_old) {\n      var _this2 = this,\n        _data$extra,\n        _this$onConfigure;\n      if (!data) {\n        return;\n      }\n      if (!keep_old) {\n        this.clear();\n      }\n      var nodes = data.nodes;\n\n      // decode links info (they are very verbose)\n      if (data.links && data.links.constructor === Array) {\n        var links = [];\n        for (var i = 0; i < data.links.length; ++i) {\n          var link_data = data.links[i];\n          if (!link_data) {\n            var _LiteGraph$warn4;\n            // @BUG: \"weird bug\" originally\n            (_LiteGraph$warn4 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn4 === void 0 || _LiteGraph$warn4.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"serialized graph link data contains errors, skipping.\");\n            continue;\n          }\n          var link = new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LLink();\n          link.configure(link_data);\n          links[link.id] = link;\n        }\n        data.links = links;\n      }\n\n      // copy all stored fields\n      for (var _i9 in data) {\n        if ([\"nodes\", \"groups\"].includes(_i9)) continue; // Accepts \"nodes\" and \"groups\"\n        this[_i9] = data[_i9];\n      }\n      var error = false;\n\n      // create nodes\n      this._nodes = [];\n      if (nodes) {\n        for (var _i10 = 0, l = nodes.length; _i10 < l; ++_i10) {\n          var n_info = nodes[_i10]; // stored info\n          var node = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.createNode(n_info.type, n_info.title);\n          if (!node) {\n            var _LiteGraph$log5;\n            (_LiteGraph$log5 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log5 === void 0 || _LiteGraph$log5.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Node not found or has errors: \".concat(n_info.type));\n\n            // in case of error we create a replacement node to avoid losing info\n            node = new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LGraphNode();\n            node.last_serialization = n_info;\n            node.has_errors = true;\n            error = true;\n            // continue;\n          }\n          node.id = n_info.id; // id it or it will create a new id\n          this.add(node, true, {\n            doProcessChange: false\n          }); // add before configure, otherwise configure cannot create links\n        }\n\n        // configure nodes afterwards so they can reach each other\n        nodes.forEach(function (n_info) {\n          var node = _this2.getNodeById(n_info.id);\n          node === null || node === void 0 || node.configure(n_info);\n        });\n      }\n\n      // groups\n      this._groups.length = 0;\n      if (data.groups) {\n        data.groups.forEach(function (groupData) {\n          var group = new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LGraphGroup();\n          group.configure(groupData);\n          _this2.add(group, true, {\n            doProcessChange: false\n          });\n        });\n      }\n      this.updateExecutionOrder();\n      this.extra = (_data$extra = data.extra) !== null && _data$extra !== void 0 ? _data$extra : {};\n      (_this$onConfigure = this.onConfigure) === null || _this$onConfigure === void 0 || _this$onConfigure.call(this, data);\n      // TODO implement: when loading (configuring) a whole graph, skip calling graphChanged on every single configure\n      if (!data._version) {\n        this.onGraphChanged({\n          action: \"graphConfigure\",\n          doSave: false\n        }); // this._version++;\n      } else {\n        var _LiteGraph$debug;\n        (_LiteGraph$debug = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug === void 0 || _LiteGraph$debug.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"skip onGraphChanged when configure passing version too!\"); // atlasan DEBUG REMOVE\n      }\n      this.setDirtyCanvas(true, true);\n      return error;\n    }\n\n    /**\r\n     * Loads graph data from a given URL or file and configures the graph accordingly.\r\n     * @param {string | File | Blob} url - The URL or file to load the graph data from.\r\n     * @param {Function} callback - An optional callback function to be executed after loading and configuring the graph.\r\n     */\n  }, {\n    key: \"load\",\n    value: function load(url, callback) {\n      var that = this;\n\n      // from file\n      if (url.constructor === File || url.constructor === Blob) {\n        var reader = new FileReader();\n        reader.addEventListener('load', function (event) {\n          var data = JSON.parse(event.target.result);\n          that.configure(data);\n          callback === null || callback === void 0 || callback();\n        });\n        reader.readAsText(url);\n        return;\n      }\n\n      // is a string, then an URL\n      var req = new XMLHttpRequest();\n      req.open(\"GET\", url, true);\n      req.send(null);\n      req.onload = function (_event) {\n        if (req.status !== 200) {\n          var _LiteGraph$error3;\n          (_LiteGraph$error3 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.error) === null || _LiteGraph$error3 === void 0 || _LiteGraph$error3.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Error loading graph:\", req.status, req.response);\n          return;\n        }\n        var data = JSON.parse(req.response);\n        that.configure(data);\n        callback === null || callback === void 0 || callback();\n      };\n      req.onerror = function (err) {\n        var _LiteGraph$error4;\n        (_LiteGraph$error4 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.error) === null || _LiteGraph$error4 === void 0 || _LiteGraph$error4.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Error loading graph:\", err);\n      };\n    }\n\n    /**\r\n    * Meant to serve the history-saving mechanism\r\n    * @method onGraphSaved\r\n    * @param {object} optsIn options\r\n    */\n  }, {\n    key: \"onGraphSaved\",\n    value: function onGraphSaved() {\n      var optsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var optsDef = {};\n      var opts = Object.assign(optsDef, optsIn);\n      this.savedVersion = this._version;\n    }\n\n    /**\r\n    * Meant to serve the history-saving mechanism\r\n    * @method onGraphSaved\r\n    * @param {object} optsIn options\r\n    */\n  }, {\n    key: \"onGraphLoaded\",\n    value: function onGraphLoaded() {\n      var optsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var optsDef = {};\n      var opts = Object.assign(optsDef, optsIn);\n      this.savedVersion = this._version;\n    }\n\n    /**\r\n    * Ment to be the history and prevent-exit mechanism, call to change _version\r\n    * @method onGraphChanged\r\n    * @param {object} optsIn options\r\n    */\n  }, {\n    key: \"onGraphChanged\",\n    value: function onGraphChanged() {\n      var optsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var optsDef = {\n        action: \"\",\n        doSave: true,\n        // log action in graph.history\n        doSaveGraph: true // save\n      };\n      var opts = Object.assign(optsDef, optsIn);\n      this._version++;\n      if (opts.action) {\n        var _LiteGraph$debug2;\n        (_LiteGraph$debug2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug2 === void 0 || _LiteGraph$debug2.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Graph change\", opts.action);\n      } else {\n        var _LiteGraph$debug3;\n        (_LiteGraph$debug3 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug3 === void 0 || _LiteGraph$debug3.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Graph change, no action\", opts);\n      }\n      if (opts.doSave && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.actionHistory_enabled) {\n        var _LiteGraph$debug4, _LiteGraph$debug7;\n        (_LiteGraph$debug4 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug4 === void 0 || _LiteGraph$debug4.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"onGraphChanged SAVE :: \" + opts.action); // debug history\n\n        var oHistory = {\n          actionName: opts.action\n        };\n        if (opts.doSaveGraph) {\n          oHistory = Object.assign(oHistory, {\n            graphSave: this.serialize()\n          } // this is a heavy method, but the alternative is way more complex: every action has to have its contrary\n          );\n        }\n        var obH = this.history;\n\n        // check if pointer has gone back: remove newest\n        while (obH.actionHistoryPtr < obH.actionHistoryVersions.length - 1) {\n          var _LiteGraph$debug5;\n          (_LiteGraph$debug5 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug5 === void 0 || _LiteGraph$debug5.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"popping: gone back? \" + (obH.actionHistoryPtr + \" < \" + (obH.actionHistoryVersions.length - 1))); // debug history\n          obH.actionHistoryVersions.pop();\n        }\n        // check if maximum saves\n        if (obH.actionHistoryVersions.length >= _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.actionHistoryMaxSave) {\n          var _LiteGraph$debug6;\n          var olderSave = obH.actionHistoryVersions.shift();\n          (_LiteGraph$debug6 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug6 === void 0 || _LiteGraph$debug6.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"maximum saves reached: \" + obH.actionHistoryVersions.length + \", remove older: \" + olderSave); // debug history\n          obH.actionHistory[olderSave] = false; // unset\n        }\n\n        // update pointer\n        obH.actionHistoryPtr = obH.actionHistoryVersions.length;\n        obH.actionHistoryVersions.push(obH.actionHistoryPtr);\n\n        // save to pointer\n        obH.actionHistory[obH.actionHistoryPtr] = oHistory;\n        (_LiteGraph$debug7 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug7 === void 0 || _LiteGraph$debug7.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"history saved: \" + obH.actionHistoryPtr, oHistory.actionName); // debug history\n      }\n    }\n\n    /**\r\n    * Go back in action history\r\n    * @method actionHistoryBack\r\n    * @param {object} optsIn options\r\n    */\n  }, {\n    key: \"actionHistoryBack\",\n    value: function actionHistoryBack() {\n      var optsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var optsDef = {};\n      var opts = Object.assign(optsDef, optsIn);\n      var obH = this.history;\n      if (obH.actionHistoryPtr != undefined && obH.actionHistoryPtr >= 0) {\n        var _LiteGraph$debug8;\n        obH.actionHistoryPtr--;\n        (_LiteGraph$debug8 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug8 === void 0 || _LiteGraph$debug8.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"history step back: \" + obH.actionHistoryPtr); // debug history\n        if (!this.actionHistoryLoad({\n          iVersion: obH.actionHistoryPtr\n        })) {\n          var _LiteGraph$warn5;\n          (_LiteGraph$warn5 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn5 === void 0 || _LiteGraph$warn5.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"historyLoad failed, restore pointer? \" + obH.actionHistoryPtr); // debug history\n          // history not found?\n          obH.actionHistoryPtr++;\n          return false;\n        } else {\n          var _LiteGraph$debug9, _LiteGraph$debug10;\n          (_LiteGraph$debug9 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug9 === void 0 || _LiteGraph$debug9.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"history loaded back: \" + obH.actionHistoryPtr); // debug history\n          (_LiteGraph$debug10 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug10 === void 0 || _LiteGraph$debug10.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, this.history);\n          return true;\n        }\n      } else {\n        var _LiteGraph$debug11;\n        (_LiteGraph$debug11 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug11 === void 0 || _LiteGraph$debug11.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"history is already at older state\");\n        return false;\n      }\n    }\n\n    /**\r\n    * Go forward in action history\r\n    * @method actionHistoryForward\r\n    * @param {object} optsIn options\r\n    */\n  }, {\n    key: \"actionHistoryForward\",\n    value: function actionHistoryForward() {\n      var optsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var optsDef = {};\n      var opts = Object.assign(optsDef, optsIn);\n      var obH = this.history;\n      if (obH.actionHistoryPtr < obH.actionHistoryVersions.length) {\n        var _LiteGraph$debug12;\n        obH.actionHistoryPtr++;\n        (_LiteGraph$debug12 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug12 === void 0 || _LiteGraph$debug12.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"history step forward: \" + obH.actionHistoryPtr); // debug history\n        if (!this.actionHistoryLoad({\n          iVersion: obH.actionHistoryPtr\n        })) {\n          var _LiteGraph$warn6;\n          (_LiteGraph$warn6 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn6 === void 0 || _LiteGraph$warn6.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"historyLoad failed, restore pointer? \" + obH.actionHistoryPtr); // debug history\n          // history not found?\n          obH.actionHistoryPtr--;\n          return false;\n        } else {\n          var _LiteGraph$debug13;\n          (_LiteGraph$debug13 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug13 === void 0 || _LiteGraph$debug13.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"history loaded forward: \" + obH.actionHistoryPtr); // debug history\n          return true;\n        }\n      } else {\n        var _LiteGraph$debug14;\n        (_LiteGraph$debug14 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug14 === void 0 || _LiteGraph$debug14.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"history is already at newer state\");\n        return false;\n      }\n    }\n\n    /**\r\n    * Load from action history\r\n    * @method actionHistoryLoad\r\n    * @param {object} optsIn options\r\n    */\n  }, {\n    key: \"actionHistoryLoad\",\n    value: function actionHistoryLoad() {\n      var optsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var optsDef = {\n        iVersion: false,\n        backStep: false\n      };\n      var opts = Object.assign(optsDef, optsIn);\n      var obH = this.history;\n      if (obH.actionHistory[opts.iVersion] && obH.actionHistory[opts.iVersion].graphSave) {\n        var _LiteGraph$debug15;\n        var tmpHistory = JSON.stringify(this.history);\n        this.configure(obH.actionHistory[opts.iVersion].graphSave);\n        this.history = JSON.parse(tmpHistory);\n        (_LiteGraph$debug15 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug15 === void 0 || _LiteGraph$debug15.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"history loaded: \" + opts.iVersion, obH.actionHistory[opts.iVersion].actionName); // debug history\n        // no: this.onGraphLoaded();\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }]);\n}();\n// default supported types\n_defineProperty(LGraph, \"supported_types\", [\"number\", \"string\", \"boolean\"]);\n_defineProperty(LGraph, \"STATUS_STOPPED\", 1);\n_defineProperty(LGraph, \"STATUS_RUNNING\", 2);\n\n//# sourceURL=webpack://LiteGraphJS/./src/lgraph.js?");

/***/ }),

/***/ "./src/lgraphcanvas.js":
/*!*****************************!*\
  !*** ./src/lgraphcanvas.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LGraphCanvas: () => (/* binding */ LGraphCanvas)\n/* harmony export */ });\n/* harmony import */ var _litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./litegraph.js */ \"./src/litegraph.js\");\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\r\n * This class is in charge of rendering one graph inside a canvas. And provides all the interaction required.\r\n * Valid callbacks are: onNodeSelected, onNodeDeselected, onShowNodePanel, onNodeDblClicked\r\n *\r\n * @class LGraphCanvas\r\n * @constructor\r\n * @param {HTMLCanvas} canvas the canvas where you want to render (it accepts a selector in string format or the canvas element itself)\r\n * @param {LGraph} graph [optional]\r\n * @param {Object} options [optional] { skip_rendering, autoresize, viewport }\r\n */\nvar LGraphCanvas = /*#__PURE__*/function () {\n  function LGraphCanvas(canvas, graph, options) {\n    var _this = this,\n      _options;\n    _classCallCheck(this, LGraphCanvas);\n    /**\r\n     * Called when a mouse wheel event has to be processed\r\n     * @method processMouseWheel\r\n     **/\n    _defineProperty(this, \"processMouseWheel\", function (e) {\n      if (!_this.graph || !_this.allow_dragcanvas) {\n        return;\n      }\n      var delta = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;\n      _this.adjustMouseEvent(e);\n      var x = e.clientX;\n      var y = e.clientY;\n      var is_inside = !_this.viewport || _this.viewport && x >= _this.viewport[0] && x < _this.viewport[0] + _this.viewport[2] && y >= _this.viewport[1] && y < _this.viewport[1] + _this.viewport[3];\n      if (!is_inside) return;\n      var scale = _this.ds.scale;\n      if (delta > 0) {\n        scale *= 1.1;\n      } else if (delta < 0) {\n        scale *= 1 / 1.1;\n      }\n\n      // this.setZoom( scale, [ e.clientX, e.clientY ] );\n      _this.ds.changeScale(scale, [e.clientX, e.clientY]);\n      _this.graph.change();\n      e.preventDefault();\n      return false; // prevent default\n    });\n    /**\r\n     * process a key event\r\n     * @method processKey\r\n     **/\n    _defineProperty(this, \"processKey\", function (e) {\n      if (!_this.graph) {\n        return;\n      }\n      var block_default = false;\n      // LiteGraph.log?.(e); //debug\n\n      if (e.target.localName == \"input\") {\n        return;\n      }\n      if (e.type == \"keydown\") {\n        var _LiteGraph$debug;\n        if (e.keyCode == 32) {\n          // space\n          _this.dragging_canvas = true;\n          block_default = true;\n        }\n        if (e.keyCode == 27) {\n          // esc\n          if (_this.node_panel) _this.node_panel.close();\n          if (_this.options_panel) _this.options_panel.close();\n          block_default = true;\n        }\n\n        // select all Control A\n        if (e.keyCode == 65 && e.ctrlKey) {\n          _this.selectNodes();\n          block_default = true;\n        }\n        if (e.keyCode === 67 && (e.metaKey || e.ctrlKey) && !e.shiftKey) {\n          // copy\n          if (_this.selected_nodes) {\n            _this.copyToClipboard();\n            block_default = true;\n          }\n        }\n        if (e.keyCode === 86 && (e.metaKey || e.ctrlKey)) {\n          // paste\n          _this.pasteFromClipboard(e.shiftKey);\n        }\n\n        // delete or backspace\n        if (e.keyCode == 46 || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.backspace_delete && e.keyCode == 8) {\n          if (e.target.localName != \"input\" && e.target.localName != \"textarea\") {\n            _this.deleteSelectedNodes();\n            block_default = true;\n          }\n        }\n\n        // collapse\n        // ...\n\n        // control Z, control Y, ctlrZ, ctlrY\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.actionHistory_enabled) {\n          if (e.keyCode == 89 && e.ctrlKey || e.keyCode == 90 && e.ctrlKey && e.shiftKey) {\n            // Y\n            _this.graph.actionHistoryForward();\n          } else if (e.keyCode == 90 && e.ctrlKey) {\n            // Z\n            _this.graph.actionHistoryBack();\n          }\n        }\n        (_LiteGraph$debug = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug === void 0 || _LiteGraph$debug.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Canvas keydown \" + e.keyCode); // debug keydown\n\n        // TODO\n        if (_this.selected_nodes) {\n          for (var i in _this.selected_nodes) {\n            var _this$selected_nodes$, _this$selected_nodes$2;\n            (_this$selected_nodes$ = (_this$selected_nodes$2 = _this.selected_nodes[i]).onKeyDown) === null || _this$selected_nodes$ === void 0 || _this$selected_nodes$.call(_this$selected_nodes$2, e);\n          }\n        }\n      } else if (e.type == \"keyup\") {\n        if (e.keyCode == 32) {\n          // space\n          _this.dragging_canvas = false;\n        }\n        if (_this.selected_nodes) {\n          for (var _i in _this.selected_nodes) {\n            var _this$selected_nodes$3, _this$selected_nodes$4;\n            (_this$selected_nodes$3 = (_this$selected_nodes$4 = _this.selected_nodes[_i]).onKeyUp) === null || _this$selected_nodes$3 === void 0 || _this$selected_nodes$3.call(_this$selected_nodes$4, e);\n          }\n        }\n      }\n      _this.graph.change();\n      if (block_default) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n      }\n    });\n    /**\r\n     * process a item drop event on top the canvas\r\n     * @method processDrop\r\n     **/\n    _defineProperty(this, \"processDrop\", function (e) {\n      e.preventDefault();\n      _this.adjustMouseEvent(e);\n      var x = e.clientX;\n      var y = e.clientY;\n      var is_inside = !_this.viewport || _this.viewport && x >= _this.viewport[0] && x < _this.viewport[0] + _this.viewport[2] && y >= _this.viewport[1] && y < _this.viewport[1] + _this.viewport[3];\n      if (!is_inside) {\n        return;\n        // --- BREAK ---\n      }\n      x = e.localX;\n      y = e.localY;\n      var is_inside = !_this.viewport || _this.viewport && x >= _this.viewport[0] && x < _this.viewport[0] + _this.viewport[2] && y >= _this.viewport[1] && y < _this.viewport[1] + _this.viewport[3];\n      if (!is_inside) {\n        return;\n        // --- BREAK ---\n      }\n      var pos = [e.canvasX, e.canvasY];\n      var node = _this.graph ? _this.graph.getNodeOnPos(pos[0], pos[1]) : null;\n      if (!node) {\n        var r = null;\n        if (_this.onDropItem) {\n          r = _this.onDropItem(event);\n        }\n        if (!r) {\n          _this.checkDropItem(e);\n        }\n        return;\n      }\n      if (node.onDropFile || node.onDropData) {\n        var files = e.dataTransfer.files;\n        if (files && files.length) {\n          for (var i = 0; i < files.length; i++) {\n            var file = e.dataTransfer.files[0];\n            var filename = file.name;\n            // LiteGraph.log?.(file);\n\n            if (node.onDropFile) {\n              node.onDropFile(file);\n            }\n            if (node.onDropData) {\n              // prepare reader\n              var reader = new FileReader();\n              reader.onload = function (event) {\n                // LiteGraph.log?.(event.target);\n                var data = event.target.result;\n                node.onDropData(data, filename, file);\n              };\n\n              // read data\n              var type = file.type.split(\"/\")[0];\n              if (type == \"text\" || type == \"\") {\n                reader.readAsText(file);\n              } else if (type == \"image\") {\n                reader.readAsDataURL(file);\n              } else {\n                reader.readAsArrayBuffer(file);\n              }\n            }\n          }\n        }\n      }\n      if (node.onDropItem) {\n        if (node.onDropItem(event)) {\n          return true;\n        }\n      }\n      if (_this.onDropItem) {\n        return _this.onDropItem(event);\n      }\n      return false;\n    });\n    (_options = options) !== null && _options !== void 0 ? _options : options = {\n      skip_render: false,\n      autoresize: false,\n      clip_all_nodes: false\n    };\n    this.options = options;\n\n    // if(graph === undefined)\n    //\tthrow new Error(\"No graph assigned\");\n    this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE;\n    if (canvas && canvas.constructor === String) {\n      canvas = document.querySelector(canvas);\n    }\n    this.ds = new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.DragAndScale();\n    this.zoom_modify_alpha = true; // otherwise it generates ugly patterns when scaling down too much\n\n    this.title_text_font = \"\".concat(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TEXT_SIZE, \"px Arial\");\n    this.inner_text_font = \"normal \".concat(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_SUBTEXT_SIZE, \"px Arial\");\n    this.node_title_color = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_COLOR;\n    this.default_link_color = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LINK_COLOR;\n    this.default_connection_color = {\n      input_off: \"#778\",\n      input_on: \"#7F7\",\n      // \"#BBD\"\n      output_off: \"#778\",\n      output_on: \"#7F7\" // \"#BBD\"\n    };\n    this.default_connection_color_byType = {}; /* number: \"#7F7\", string: \"#77F\", boolean: \"#F77\",*/\n    this.default_connection_color_byTypeOff = {}; /* number: \"#474\", string: \"#447\", boolean: \"#744\",*/\n    this.drag_mode = false; // never used ?\n    this.dragging_rectangle = null;\n    this.filter = null; // allows to filter to only accept some type of nodes in a graph\n\n    this.highquality_render = true;\n    this.use_gradients = false; // set to true to render titlebar with gradients\n    this.editor_alpha = 1; // used for transition\n    this.pause_rendering = false;\n    this.clear_background = true;\n    this.clear_background_color = \"#222\";\n    this.read_only = false; // if set to true users cannot modify the graph\n    //  this.render_only_selected = true; // @TODO Atlasan figures this isn't used\n    this.live_mode = false;\n    this.show_info = true;\n    this.allow_dragcanvas = true;\n    this.allow_dragnodes = true;\n    this.allow_interaction = true; // allow to control widgets, buttons, collapse, etc\n    this.multi_select = false; // allow selecting multi nodes without pressing extra keys\n    this.allow_searchbox = true;\n    //  this.allow_reconnect_links = true; // @TODO: replaced by Atlasan.  Clean up.  allows to change a connection with having to redo it again\n    this.move_destination_link_without_shift = false;\n    this.align_to_grid = false; // snap to grid\n\n    this.drag_mode = false;\n    this.dragging_rectangle = null;\n    this.filter = null; // allows to filter to only accept some type of nodes in a graph\n\n    this.set_canvas_dirty_on_mouse_event = true; // forces to redraw the canvas if the mouse does anything\n    this.always_render_background = false;\n    this.render_shadows = true;\n    this.render_canvas_border = true;\n    this.render_connections_shadows = false; // too much cpu\n    this.render_connections_border = true;\n    this.render_curved_connections = true;\n    this.render_connection_arrows = false;\n    this.render_collapsed_slots = true;\n    this.render_execution_order = false;\n    this.render_title_colored = true;\n    this.render_link_tooltip = true;\n    this.free_resize = true;\n    this.links_render_mode = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.SPLINE_LINK;\n\n    // TODO refactor: options object do need refactoring .. all the options are actually outside of it\n    this.autoresize = options.autoresize;\n    this.skip_render = options.skip_render;\n    this.clip_all_nodes = options.clip_all_nodes;\n    this.free_resize = options.free_resize;\n    this.mouse = [0, 0]; // mouse in canvas coordinates, where 0,0 is the top-left corner of the blue rectangle\n    this.graph_mouse = [0, 0]; // mouse in graph coordinates, where 0,0 is the top-left corner of the blue rectangle\n    this.canvas_mouse = this.graph_mouse; // LEGACY: REMOVE THIS, USE GRAPH_MOUSE INSTEAD\n\n    // to personalize the search box\n    this.onSearchBox = null;\n    this.onSearchBoxSelection = null;\n\n    // callbacks\n    this.onMouse = null;\n    this.onDrawBackground = null; // to render background objects (behind nodes and connections) in the canvas affected by transform\n    this.onDrawForeground = null; // to render foreground objects (above nodes and connections) in the canvas affected by transform\n    this.onDrawOverlay = null; // to render foreground objects not affected by transform (for GUIs)\n    this.onDrawLinkTooltip = null; // called when rendering a tooltip\n    this.onNodeMoved = null; // called after moving a node\n    this.onSelectionChange = null; // called if the selection changes\n    this.onConnectingChange = null; // called before any link changes\n    this.onBeforeChange = null; // called before modifying the graph\n    this.onAfterChange = null; // called after modifying the graph\n\n    this.connections_width = 3;\n    this.round_radius = 8;\n    this.current_node = null;\n    this.node_widget = null; // used for widgets\n    this.over_link_center = null;\n    this.last_mouse_position = [0, 0];\n    this.visible_area = this.ds.visible_area;\n    this.visible_links = [];\n    this.viewport = options.viewport || null; // to constraint render area to a portion of the canvas\n    this.low_quality_rendering_threshold = 5; // amount of slow fps to switch to low quality rendering\n\n    // link canvas and graph\n    graph === null || graph === void 0 || graph.attachCanvas(this);\n    this.setCanvas(canvas, options.skip_events);\n    this.clear();\n    if (!this.skip_render && !options.skip_render) {\n      this.startRendering();\n    }\n  }\n\n  /**\r\n   * clears all the data inside\r\n   *\r\n   * @method clear\r\n   */\n  return _createClass(LGraphCanvas, [{\n    key: \"clear\",\n    value: function clear() {\n      var _this$onClear;\n      this.frame = 0;\n      this.last_draw_time = 0;\n      this.render_time = 0;\n      this.fps = 0;\n      this.low_quality_rendering_counter = 0;\n\n      // this.scale = 1;\n      // this.offset = [0,0];\n\n      this.dragging_rectangle = null;\n      this.selected_nodes = {};\n      this.selected_group = null;\n      this.visible_nodes = [];\n      this.node_dragged = null;\n      this.node_over = null;\n      this.node_capturing_input = null;\n      this.connecting_node = null;\n      this.highlighted_links = {};\n      this.dragging_canvas = false;\n      this.dirty_canvas = true;\n      this.dirty_bgcanvas = true;\n      this.dirty_area = null;\n      this.node_in_panel = null;\n      this.node_widget = null;\n      this.last_mouse = [0, 0];\n      this.last_mouseclick = 0;\n      this.pointer_is_down = false;\n      this.pointer_is_double = false;\n      this.visible_area.set([0, 0, 0, 0]);\n      (_this$onClear = this.onClear) === null || _this$onClear === void 0 || _this$onClear.call(this);\n    }\n\n    /**\r\n     * assigns a graph, you can reassign graphs to the same canvas\r\n     *\r\n     * @method setGraph\r\n     * @param {LGraph} graph\r\n     */\n  }, {\n    key: \"setGraph\",\n    value: function setGraph(graph, skip_clear) {\n      if (this.graph == graph) {\n        return;\n      }\n      if (!skip_clear) {\n        this.clear();\n      }\n      if (!graph) {\n        var _this$graph;\n        (_this$graph = this.graph) === null || _this$graph === void 0 || _this$graph.detachCanvas(this);\n        return;\n      }\n      graph.attachCanvas(this);\n\n      // remove the graph stack in case a subgraph was open\n      this._graph_stack && (this._graph_stack = null);\n      this.setDirty(true, true);\n    }\n\n    /**\r\n     * returns the top level graph (in case there are subgraphs open on the canvas)\r\n     *\r\n     * @method getTopGraph\r\n     * @return {LGraph} graph\r\n     */\n  }, {\n    key: \"getTopGraph\",\n    value: function getTopGraph() {\n      if (this._graph_stack.length) return this._graph_stack[0];\n      return this.graph;\n    }\n\n    /**\r\n     * opens a graph contained inside a node in the current graph\r\n     *\r\n     * @method openSubgraph\r\n     * @param {LGraph} graph\r\n     */\n  }, {\n    key: \"openSubgraph\",\n    value: function openSubgraph(graph) {\n      if (!graph) {\n        throw new Error(\"graph cannot be null\");\n      }\n      if (this.graph == graph) {\n        throw new Error(\"graph cannot be the same\");\n      }\n      this.clear();\n      if (this.graph) {\n        this._graph_stack || (this._graph_stack = []);\n        this._graph_stack.push(this.graph);\n      }\n      graph.attachCanvas(this);\n      this.checkPanels();\n      this.setDirty(true, true);\n    }\n\n    /**\r\n     * closes a subgraph contained inside a node\r\n     *\r\n     * @method closeSubgraph\r\n     * @param {LGraph} assigns a graph\r\n     */\n  }, {\n    key: \"closeSubgraph\",\n    value: function closeSubgraph() {\n      if (!this._graph_stack || this._graph_stack.length == 0) {\n        return;\n      }\n      var subgraph_node = this.graph._subgraph_node;\n      var graph = this._graph_stack.pop();\n      this.selected_nodes = {};\n      this.highlighted_links = {};\n      graph.attachCanvas(this);\n      this.setDirty(true, true);\n      if (subgraph_node) {\n        this.centerOnNode(subgraph_node);\n        this.selectNodes([subgraph_node]);\n      }\n      // when close sub graph back to offset [0, 0] scale 1\n      this.ds.offset = [0, 0];\n      this.ds.scale = 1;\n    }\n\n    /**\r\n     * returns the visually active graph (in case there are more in the stack)\r\n     * @method getCurrentGraph\r\n     * @return {LGraph} the active graph\r\n     */\n  }, {\n    key: \"getCurrentGraph\",\n    value: function getCurrentGraph() {\n      return this.graph;\n    }\n\n    /**\r\n     * assigns a canvas\r\n     *\r\n     * @method setCanvas\r\n     * @param {Canvas} assigns a canvas (also accepts the ID of the element (not a selector)\r\n     */\n  }, {\n    key: \"setCanvas\",\n    value: function setCanvas(canvas, skip_events) {\n      if (canvas) {\n        if (canvas.constructor === String) {\n          canvas = document.getElementById(canvas);\n          if (!canvas) {\n            throw new Error(\"Error creating LiteGraph canvas: Canvas not found\");\n          }\n        }\n      }\n      if (canvas === this.canvas) {\n        return;\n      }\n      if (!canvas && this.canvas) {\n        // maybe detach events from old_canvas\n        if (!skip_events) {\n          this.unbindEvents();\n        }\n      }\n      this.canvas = canvas;\n      this.ds.element = canvas;\n      if (!canvas) {\n        return;\n      }\n\n      // this.canvas.tabindex = \"1000\";\n      canvas.className += \" lgraphcanvas\";\n      canvas.data = this;\n      canvas.tabindex = \"1\"; // to allow key events\n\n      // bg canvas: used for non changing stuff\n      this.bgcanvas = document.createElement(\"canvas\");\n      this.bgcanvas.width = this.canvas.width;\n      this.bgcanvas.height = this.canvas.height;\n      if (canvas.getContext == null) {\n        if (canvas.localName != \"canvas\") {\n          throw new Error(\"Element supplied for LGraphCanvas must be a <canvas> element, you passed a \" + canvas.localName);\n        }\n        throw new Error(\"This browser doesn't support Canvas\");\n      }\n      var ctx = this.ctx = canvas.getContext(\"2d\");\n      if (ctx == null) {\n        if (!canvas.webgl_enabled) {\n          var _LiteGraph$info;\n          (_LiteGraph$info = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.info) === null || _LiteGraph$info === void 0 || _LiteGraph$info.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"This canvas seems to be WebGL, enabling WebGL renderer\");\n        }\n        this.enableWebGL();\n      }\n      if (!skip_events) {\n        this.bindEvents();\n      }\n    }\n\n    // used in some events to capture them\n  }, {\n    key: \"_doNothing\",\n    value: function _doNothing(e) {\n      // LiteGraph.debug?.(\"pointerevents: _doNothing \"+e.type);\n      e.preventDefault();\n      return false;\n    }\n  }, {\n    key: \"_doReturnTrue\",\n    value: function _doReturnTrue(e) {\n      e.preventDefault();\n      return true;\n    }\n\n    /**\r\n     * binds mouse, keyboard, touch and drag events to the canvas\r\n     * @method bindEvents\r\n     **/\n  }, {\n    key: \"bindEvents\",\n    value: function bindEvents() {\n      if (this._events_binded) {\n        var _LiteGraph$warn;\n        (_LiteGraph$warn = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn === void 0 || _LiteGraph$warn.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"LGraphCanvas: events already binded\");\n        return;\n      }\n      this._events_binded = true;\n      var canvas = this.canvas;\n      var ref_window = this.getCanvasWindow();\n      var document = ref_window.document; // hack used when moving canvas between windows\n\n      // Pointer\n      this._mousedown_callback = this.processMouseDown.bind(this);\n      this._mousemove_callback = this.processMouseMove.bind(this);\n      this._mouseup_callback = this.processMouseUp.bind(this);\n      canvas.addEventListener(\"pointerdown\", this._mousedown_callback, true);\n      canvas.addEventListener(\"pointermove\", this._mousemove_callback);\n      canvas.addEventListener(\"pointerup\", this._mouseup_callback, true);\n      canvas.addEventListener(\"contextmenu\", this._doNothing);\n\n      // Wheel\n      canvas.addEventListener(\"wheel\", this.processMouseWheel);\n\n      // Keyboard\n      canvas.addEventListener(\"keydown\", this.processKey);\n      document.addEventListener(\"keyup\", this.processKey); // in document, otherwise it doesn't fire keyup\n\n      // Drop\n      canvas.addEventListener(\"dragover\", this._doNothing, false);\n      canvas.addEventListener(\"dragend\", this._doNothing, false);\n      canvas.addEventListener(\"drop\", this.processDrop);\n      canvas.addEventListener(\"dragenter\", this._doReturnTrue, false);\n    }\n\n    /**\r\n     * unbinds mouse events from the canvas\r\n     * @method unbindEvents\r\n     **/\n  }, {\n    key: \"unbindEvents\",\n    value: function unbindEvents() {\n      if (!this._events_binded) {\n        var _LiteGraph$warn2;\n        (_LiteGraph$warn2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn2 === void 0 || _LiteGraph$warn2.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"LGraphCanvas: no events binded\");\n        return;\n      }\n      this._events_binded = false;\n      var canvas = this.canvas;\n      var ref_window = this.getCanvasWindow();\n      var document = ref_window.document;\n\n      // Pointer\n      canvas.removeEventListener(\"pointerdown\", this._mousedown_callback);\n      canvas.removeEventListener(\"pointermove\", this._mousemove_callback);\n      canvas.removeEventListener(\"pointerup\", this._mouseup_callback);\n      canvas.removeEventListener(\"contextmenu\", this._doNothing);\n\n      // Wheel\n      canvas.removeEventListener(\"wheel\", this.processMouseWheel);\n\n      // Keyboard\n      canvas.removeEventListener(\"keydown\", this.processKey);\n      document.removeEventListener(\"keyup\", this.processKey);\n\n      // Drop\n      canvas.removeEventListener(\"dragover\", this._doNothing, false);\n      canvas.removeEventListener(\"dragend\", this._doNothing, false);\n      canvas.removeEventListener(\"drop\", this.processDrop);\n      canvas.removeEventListener(\"dragenter\", this._doReturnTrue);\n      this._mousedown_callback = null;\n    }\n  }, {\n    key: \"enableWebGL\",\n    value:\n    /**\r\n     * this function allows to render the canvas using WebGL instead of Canvas2D\r\n     * this is useful if you plant to render 3D objects inside your nodes, it uses litegl.js for webgl and canvas2DtoWebGL to emulate the Canvas2D calls in webGL\r\n     * @method enableWebGL\r\n     **/\n    function enableWebGL() {\n      if (typeof GL === \"undefined\") {\n        throw new Error(\"litegl.js must be included to use a WebGL canvas\");\n      }\n      if (typeof enableWebGLCanvas === \"undefined\") {\n        throw new Error(\"webglCanvas.js must be included to use this feature\");\n      }\n      this.gl = this.ctx = enableWebGLCanvas(this.canvas);\n      this.ctx.webgl = true;\n      this.bgcanvas = this.canvas;\n      this.bgctx = this.gl;\n      this.canvas.webgl_enabled = true;\n\n      /*\r\n      GL.create({ canvas: this.bgcanvas });\r\n      this.bgctx = enableWebGLCanvas( this.bgcanvas );\r\n      window.gl = this.gl;\r\n      */\n    }\n\n    /**\r\n     * marks as dirty the canvas, this way it will be rendered again\r\n     *\r\n     * @class LGraphCanvas\r\n     * @method setDirty\r\n     * @param {bool} fgcanvas if the foreground canvas is dirty (the one containing the nodes)\r\n     * @param {bool} bgcanvas if the background canvas is dirty (the one containing the wires)\r\n     */\n  }, {\n    key: \"setDirty\",\n    value: function setDirty(fgcanvas, bgcanvas) {\n      if (fgcanvas) {\n        this.dirty_canvas = true;\n      }\n      if (bgcanvas) {\n        this.dirty_bgcanvas = true;\n      }\n    }\n\n    /**\r\n     * Used to attach the canvas in a popup\r\n     *\r\n     * @method getCanvasWindow\r\n     * @return {window} returns the window where the canvas is attached (the DOM root node)\r\n     */\n  }, {\n    key: \"getCanvasWindow\",\n    value: function getCanvasWindow() {\n      var _doc$defaultView;\n      if (!this.canvas) {\n        return window;\n      }\n      var doc = this.canvas.ownerDocument;\n      return (_doc$defaultView = doc.defaultView) !== null && _doc$defaultView !== void 0 ? _doc$defaultView : doc.parentWindow;\n    }\n\n    /**\r\n     * starts rendering the content of the canvas when needed\r\n     *\r\n     * @method startRendering\r\n     */\n  }, {\n    key: \"startRendering\",\n    value: function startRendering() {\n      if (this.is_rendering) {\n        return;\n      } // already rendering\n\n      this.is_rendering = true;\n      renderFrame.call(this);\n      function renderFrame() {\n        if (!this.pause_rendering) {\n          this.draw();\n        }\n        var window = this.getCanvasWindow();\n        if (this.is_rendering) {\n          window.requestAnimationFrame(renderFrame.bind(this));\n        }\n      }\n    }\n\n    /**\r\n     * stops rendering the content of the canvas (to save resources)\r\n     *\r\n     * @method stopRendering\r\n     */\n  }, {\n    key: \"stopRendering\",\n    value: function stopRendering() {\n      this.is_rendering = false;\n      /*\r\n      if(this.rendering_timer_id)\r\n      {\r\n      clearInterval(this.rendering_timer_id);\r\n      this.rendering_timer_id = null;\r\n      }\r\n      */\n    }\n\n    /* LiteGraphCanvas input */\n\n    // used to block future mouse events (because of im gui)\n  }, {\n    key: \"blockClick\",\n    value: function blockClick() {\n      this.block_click = true;\n      this.last_mouseclick = 0;\n    }\n  }, {\n    key: \"processUserInputDown\",\n    value: function processUserInputDown(e) {\n      var _LiteGraph$log;\n      if (this.pointer_is_down && e.isPrimary !== undefined && !e.isPrimary) {\n        this.userInput_isNotPrimary = true;\n        // DBG(\"pointerevents: userInput_isNotPrimary start\");\n      } else {\n        this.userInput_isNotPrimary = false;\n      }\n      this.userInput_type = e.pointerType ? e.pointerType : false;\n      this.userInput_id = e.pointerId ? e.pointerId : false;\n      if (e.pointerType) {\n        switch (e.pointerType) {\n          case \"mouse\":\n            break;\n          case \"pen\":\n            break;\n          case \"touch\":\n            break;\n          default:\n            (_LiteGraph$log = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log === void 0 || _LiteGraph$log.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"pointerType unknown \" + ev.pointerType);\n        }\n      }\n      if (e.button !== undefined) {\n        this.userInput_button = e.button;\n        // LiteGraph.debug?.(\"input button \",e.button);\n        switch (e.button) {\n          case -1: // no changes since last event\n          case 0: // Left Mouse, Touch Contact, Pen contact\n          case 1: // Middle Mouse\n          case 2: // Right Mouse, Pen barrel button\n          case 3: // X1 (back) Mouse\n          case 4: // X2 (forward) Mouse\n          case 5: // Pen eraser button\n          default: // ?? move without touches\n        }\n      }\n      if (e.buttons !== undefined) {\n        this.userInput_button_s = e.buttons;\n        // LiteGraph.debug?.(\"input button_S \",e.buttons);\n      }\n      this.userInput_touches = e.changedTouches !== undefined && e.changedTouches.length !== undefined ? e.changedTouches : false;\n      if (this.userInput_touches && this.userInput_touches.length) {\n        var _LiteGraph$debug2;\n        (_LiteGraph$debug2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug2 === void 0 || _LiteGraph$debug2.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"check multiTouches\", e.changedTouches);\n      }\n      return this.processMouseDown(e);\n    }\n  }, {\n    key: \"processMouseDown\",\n    value: function processMouseDown(e) {\n      var _LiteGraph$log2,\n        _this$onMouse,\n        _this2 = this,\n        _this$onMouseDown;\n      if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n      if (!this.graph) {\n        return;\n      }\n      this.adjustMouseEvent(e);\n      var ref_window = this.getCanvasWindow();\n      LGraphCanvas.active_canvas = this;\n      var x = e.clientX;\n      var y = e.clientY;\n      // LiteGraph.log?.(y,this.viewport);\n      (_LiteGraph$log2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log2 === void 0 || _LiteGraph$log2.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"pointerevents: processMouseDown pointerId:\" + e.pointerId + \" which:\" + e.which + \" isPrimary:\" + e.isPrimary + \" :: x y \" + x + \" \" + y, \"previousClick\", this.last_mouseclick, \"diffTimeClick\", this.last_mouseclick ? _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getTime() - this.last_mouseclick : \"notlast\");\n      this.ds.viewport = this.viewport;\n      var is_inside = !this.viewport || this.viewport && x >= this.viewport[0] && x < this.viewport[0] + this.viewport[2] && y >= this.viewport[1] && y < this.viewport[1] + this.viewport[3];\n\n      // move mouse move event to the window in case it drags outside of the canvas\n      if (!this.options.skip_events) {\n        this.canvas.removeEventListener(\"pointermove\", this._mousemove_callback);\n        ref_window.document.addEventListener(\"pointermove\", this._mousemove_callback, true); // catch for the entire window\n        ref_window.document.addEventListener(\"pointerup\", this._mouseup_callback, true);\n      }\n      if (!is_inside) {\n        return;\n      }\n      var node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes, 5);\n      var skip_action = false;\n      var now = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getTime();\n      var is_primary = e.isPrimary === undefined || e.isPrimary;\n      var is_double_click = now - this.last_mouseclick < 300 && is_primary;\n      this.mouse[0] = e.clientX;\n      this.mouse[1] = e.clientY;\n      this.graph_mouse[0] = e.canvasX;\n      this.graph_mouse[1] = e.canvasY;\n      this.last_click_position = [this.mouse[0], this.mouse[1]];\n      if (this.pointer_is_down && is_primary) {\n        this.pointer_is_double = true;\n        // LiteGraph.log?.(\"pointerevents: pointer_is_double start\");\n      } else {\n        this.pointer_is_double = false;\n      }\n      this.pointer_is_down = true;\n      this.canvas.focus();\n      _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu.closeAll(ref_window);\n      if ((_this$onMouse = this.onMouse) !== null && _this$onMouse !== void 0 && _this$onMouse.call(this, e)) return;\n\n      // left button mouse / single finger\n      if (e.which == 1 && !this.userInput_isNotPrimary) {\n        if (e.ctrlKey) {\n          this.dragging_rectangle = new Float32Array(4);\n          this.dragging_rectangle[0] = e.canvasX;\n          this.dragging_rectangle[1] = e.canvasY;\n          this.dragging_rectangle[2] = 1;\n          this.dragging_rectangle[3] = 1;\n          skip_action = true;\n        }\n\n        // clone node ALT dragging\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.alt_drag_do_clone_nodes && e.altKey && node && this.allow_interaction && !skip_action && !this.read_only) {\n          var original_node = node;\n          var cloned = node.clone();\n          if (cloned) {\n            cloned.pos[0] += 5;\n            cloned.pos[1] += 5;\n            this.graph.add(cloned, false, {\n              doCalcSize: false\n            });\n            node = cloned;\n            if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.alt_shift_drag_connect_clone_with_input && e.shiftKey) {\n              // process links\n              // DBG LiteGraph.debug?.(\"altCloned\",original_node,node);\n              if (original_node.inputs && original_node.inputs.length) {\n                // DBG(\"cycle original inputs\",original_node.inputs);\n                for (var j = 0; j < original_node.inputs.length; ++j) {\n                  var input = original_node.inputs[j];\n                  if (!input || input.link == null) {\n                    // DBG LiteGraph.debug?.(\"not input link\",input);\n                    continue;\n                  }\n                  var ob_link = this.graph.links[input.link];\n                  if (!ob_link) {\n                    // DBG LiteGraph.warn?.(\"not graph link info\",input);\n                    continue;\n                  }\n                  if (ob_link.type === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT) {\n                    // DBG LiteGraph.debug?.(\"skip moving events :: TODO put a sequencer in the middle or implement multi input\",input);\n                    continue;\n                  }\n                  // DBG LiteGraph.debug?.(\"find link node\",ob_link);\n                  var source_node;\n                  if (ob_link.origin_id) {\n                    source_node = this.graph.getNodeById(ob_link.origin_id);\n                  }\n                  var target_node = node;\n                  if (source_node && target_node) {\n                    // DBG LiteGraph.info?.(\"connect cloned node\",ob_link.origin_slot, target_node, ob_link.target_slot);\n                    source_node.connect(ob_link.origin_slot, target_node, ob_link.target_slot);\n                  }\n                }\n              }\n            }\n            skip_action = true;\n            if (!block_drag_node) {\n              if (this.allow_dragnodes) {\n                this.graph.beforeChange();\n                this.node_dragged = node;\n              }\n              if (!this.selected_nodes[node.id]) {\n                this.processNodeSelected(node, e);\n              }\n            }\n          }\n        }\n        var clicking_canvas_bg = false;\n\n        // when clicked on top of a node\n        // and it is not interactive\n        if (node && (this.allow_interaction || node.flags.allow_interaction) && !skip_action && !this.read_only) {\n          if (!this.live_mode && !node.flags.pinned) {\n            this.bringToFront(node);\n          } // if it wasn't selected?\n\n          // not dragging mouse to connect two slots\n          if (this.allow_interaction && !this.connecting_node && !node.flags.collapsed && !this.live_mode) {\n            // Search for corner for resize\n            if (!skip_action && node.resizable !== false && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(e.canvasX, e.canvasY, node.pos[0] + node.size[0] - 5, node.pos[1] + node.size[1] - 5, 10, 10)) {\n              this.graph.beforeChange();\n              this.resizing_node = node;\n              this.canvas.style.cursor = \"se-resize\";\n              skip_action = true;\n            } else {\n              // search for outputs\n              if (node.outputs) {\n                for (var i = 0, l = node.outputs.length; i < l; ++i) {\n                  var _output = node.outputs[i];\n                  var link_pos = node.getConnectionPos(false, i);\n                  if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {\n                    this.connecting_node = node;\n                    this.connecting_output = _output;\n                    this.connecting_output.slot_index = i;\n                    this.connecting_pos = node.getConnectionPos(false, i);\n                    this.connecting_slot = i;\n                    if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.shift_click_do_break_link_from) {\n                      if (e.shiftKey) {\n                        node.disconnectOutput(i);\n                      }\n                    }\n                    if (is_double_click) {\n                      var _node$onOutputDblClic, _node;\n                      (_node$onOutputDblClic = (_node = node).onOutputDblClick) === null || _node$onOutputDblClic === void 0 || _node$onOutputDblClic.call(_node, i, e);\n                    } else {\n                      var _node$onOutputClick, _node2;\n                      (_node$onOutputClick = (_node2 = node).onOutputClick) === null || _node$onOutputClick === void 0 || _node$onOutputClick.call(_node2, i, e);\n                    }\n                    skip_action = true;\n                    break;\n                  }\n                }\n              }\n\n              // search for inputs\n              if (node.inputs) {\n                for (var _i2 = 0, _l = node.inputs.length; _i2 < _l; ++_i2) {\n                  var _input = node.inputs[_i2];\n                  var _link_pos = node.getConnectionPos(true, _i2);\n                  if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(e.canvasX, e.canvasY, _link_pos[0] - 15, _link_pos[1] - 10, 30, 20)) {\n                    if (is_double_click) {\n                      var _node$onInputDblClick, _node3;\n                      (_node$onInputDblClick = (_node3 = node).onInputDblClick) === null || _node$onInputDblClick === void 0 || _node$onInputDblClick.call(_node3, _i2, e);\n                    } else {\n                      var _node$onInputClick, _node4;\n                      (_node$onInputClick = (_node4 = node).onInputClick) === null || _node$onInputClick === void 0 || _node$onInputClick.call(_node4, _i2, e);\n                    }\n                    if (_input.link !== null) {\n                      var link_info = this.graph.links[_input.link]; // before disconnecting\n                      if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.click_do_break_link_to) {\n                        node.disconnectInput(_i2);\n                        this.dirty_bgcanvas = true;\n                        skip_action = true;\n                      } else {\n                        // do same action as has not node ?\n                      }\n                      if (\n                      // this.allow_reconnect_links ||\n                      // this.move_destination_link_without_shift ||\n                      e.shiftKey) {\n                        if (!_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.click_do_break_link_to) {\n                          node.disconnectInput(_i2);\n                        }\n                        this.connecting_node = this.graph._nodes_by_id[link_info.origin_id];\n                        this.connecting_slot = link_info.origin_slot;\n                        this.connecting_output = this.connecting_node.outputs[this.connecting_slot];\n                        this.connecting_pos = this.connecting_node.getConnectionPos(false, this.connecting_slot);\n                        this.dirty_bgcanvas = true;\n                        skip_action = true;\n                      }\n                    } else {\n                      // has not node\n                    }\n                    if (!skip_action) {\n                      // connect from in to out, from to to from\n                      this.connecting_node = node;\n                      this.connecting_input = _input;\n                      this.connecting_input.slot_index = _i2;\n                      this.connecting_pos = node.getConnectionPos(true, _i2);\n                      this.connecting_slot = _i2;\n                      this.dirty_bgcanvas = true;\n                      skip_action = true;\n                    }\n                  }\n                }\n              }\n            } // not resizing\n          }\n\n          // it wasn't clicked on the links boxes\n          if (!skip_action) {\n            var block_drag_node = false;\n            var pos = [e.canvasX - node.pos[0], e.canvasY - node.pos[1]];\n\n            // widgets\n            var widget = this.processNodeWidgets(node, this.graph_mouse, e);\n            if (widget) {\n              block_drag_node = true;\n              this.node_widget = [node, widget];\n            }\n\n            // double clicking\n            if (this.allow_interaction && is_double_click && this.selected_nodes[node.id]) {\n              var _node$onDblClick, _node5;\n              (_node$onDblClick = (_node5 = node).onDblClick) === null || _node$onDblClick === void 0 || _node$onDblClick.call(_node5, e, pos, this);\n              this.processNodeDblClicked(node);\n              block_drag_node = true;\n            }\n\n            // if do not capture mouse\n            if (node.onMouseDown && node.onMouseDown(e, pos, this)) {\n              block_drag_node = true;\n            } else {\n              // open subgraph button\n              if (node.subgraph && !node.skip_subgraph_button) {\n                if (!node.flags.collapsed && pos[0] > node.size[0] - _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT && pos[1] < 0) {\n                  setTimeout(function () {\n                    _this2.openSubgraph(node.subgraph);\n                  }, 10);\n                }\n              }\n              if (this.live_mode) {\n                clicking_canvas_bg = true;\n                block_drag_node = true;\n              }\n            }\n            if (!block_drag_node) {\n              if (this.allow_dragnodes) {\n                this.graph.beforeChange();\n                this.node_dragged = node;\n              }\n              this.processNodeSelected(node, e);\n            } else {\n              // double-click\n              /**\r\n               * Don't call the function if the block is already selected.\r\n               * Otherwise, it could cause the block to be unselected while its panel is open.\r\n               */\n              if (!node.is_selected) this.processNodeSelected(node, e);\n            }\n            this.dirty_canvas = true;\n          }\n        } else {\n          // clicked outside of nodes\n          if (!skip_action) {\n            var _LiteGraph$debug3;\n            // search for link connector\n            if (!this.read_only) {\n              for (var _i3 = 0; _i3 < this.visible_links.length; ++_i3) {\n                var link = this.visible_links[_i3];\n                var center = link._pos;\n                if (!center || e.canvasX < center[0] - 4 || e.canvasX > center[0] + 4 || e.canvasY < center[1] - 4 || e.canvasY > center[1] + 4) {\n                  continue;\n                }\n                // link clicked\n                this.showLinkMenu(link, e);\n                this.over_link_center = null; // clear tooltip\n                break;\n              }\n            }\n            this.selected_group = this.graph.getGroupOnPos(e.canvasX, e.canvasY);\n            this.selected_group_resizing = false;\n            if (this.selected_group && !this.read_only) {\n              if (e.ctrlKey) {\n                this.dragging_rectangle = null;\n              }\n              var dist = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.distance([e.canvasX, e.canvasY], [this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1]]);\n              if (dist * this.ds.scale < 10) {\n                this.selected_group_resizing = true;\n              } else {\n                this.selected_group.recomputeInsideNodes();\n              }\n            }\n            if (is_double_click && !this.read_only && this.allow_searchbox) {\n              this.showSearchBox(e);\n              e.preventDefault();\n              e.stopPropagation();\n            }\n            (_LiteGraph$debug3 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug3 === void 0 || _LiteGraph$debug3.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"DEBUG canvas click is_double_click,this.allow_searchbox\", is_double_click, this.allow_searchbox);\n            clicking_canvas_bg = true;\n          }\n        }\n        if (!skip_action && clicking_canvas_bg && this.allow_dragcanvas) {\n          // LiteGraph.log?.(\"pointerevents: dragging_canvas start\");\n          this.dragging_canvas = true;\n        }\n      } else if (e.which == 2) {\n        // middle button\n\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.middle_click_slot_add_default_node) {\n          if (node && this.allow_interaction && !skip_action && !this.read_only) {\n            // not dragging mouse to connect two slots\n            if (!this.connecting_node && !node.flags.collapsed && !this.live_mode) {\n              var mClikSlot = false;\n              var mClikSlot_index = false;\n              var mClikSlot_isOut = false;\n              // search for outputs\n              if (node.outputs) {\n                for (var _i4 = 0, _l2 = node.outputs.length; _i4 < _l2; ++_i4) {\n                  var output = node.outputs[_i4];\n                  var _link_pos2 = node.getConnectionPos(false, _i4);\n                  if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(e.canvasX, e.canvasY, _link_pos2[0] - 15, _link_pos2[1] - 10, 30, 20)) {\n                    mClikSlot = output;\n                    mClikSlot_index = _i4;\n                    mClikSlot_isOut = true;\n                    break;\n                  }\n                }\n              }\n\n              // search for inputs\n              if (node.inputs) {\n                for (var _i5 = 0, _l3 = node.inputs.length; _i5 < _l3; ++_i5) {\n                  var input = node.inputs[_i5];\n                  var _link_pos3 = node.getConnectionPos(true, _i5);\n                  if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(e.canvasX, e.canvasY, _link_pos3[0] - 15, _link_pos3[1] - 10, 30, 20)) {\n                    mClikSlot = input;\n                    mClikSlot_index = _i5;\n                    mClikSlot_isOut = false;\n                    break;\n                  }\n                }\n              }\n              // LiteGraph.log?.(\"middleClickSlots? \"+mClikSlot+\" & \"+(mClikSlot_index!==false));\n              if (mClikSlot && mClikSlot_index !== false) {\n                var alphaPosY = 0.5 - (mClikSlot_index + 1) / (mClikSlot_isOut ? node.outputs.length : node.inputs.length);\n                var node_bounding = node.getBounding();\n                // estimate a position: this is a bad semi-bad-working mess .. REFACTOR with a correct autoplacement that knows about the others slots and nodes\n                var posRef = [!mClikSlot_isOut ? node_bounding[0] : node_bounding[0] + node_bounding[2],\n                // + node_bounding[0]/this.canvas.width*150\n                e.canvasY - 80 // + node_bounding[0]/this.canvas.width*66 // vertical \"derive\"\n                ];\n                this.createDefaultNodeForSlot({\n                  nodeFrom: !mClikSlot_isOut ? null : node,\n                  slotFrom: !mClikSlot_isOut ? null : mClikSlot_index,\n                  nodeTo: !mClikSlot_isOut ? node : null,\n                  slotTo: !mClikSlot_isOut ? mClikSlot_index : null,\n                  position: posRef,\n                  // ,e: e\n                  nodeType: \"AUTO\",\n                  // nodeNewType\n                  posAdd: [!mClikSlot_isOut ? -30 : 30, -alphaPosY * 130],\n                  // -alphaPosY*30]\n                  posSizeFix: [!mClikSlot_isOut ? -1 : 0, 0] // -alphaPosY*2*/\n                });\n              }\n            }\n          }\n        } else if (!skip_action && this.allow_dragcanvas) {\n          // LiteGraph.log?.(\"pointerevents: dragging_canvas start from middle button\");\n          this.dragging_canvas = true;\n        }\n      } else if (e.which == 3 || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.two_fingers_opens_menu && this.userInput_isNotPrimary) {\n        // right button\n        if (this.allow_interaction && !skip_action && !this.read_only) {\n          // is it hover a node ?\n          if (node) {\n            if (Object.keys(this.selected_nodes).length && (this.selected_nodes[node.id] || e.shiftKey || e.ctrlKey || e.metaKey)) {\n              // is multiselected or using shift to include the now node\n              if (!this.selected_nodes[node.id]) this.selectNodes([node], true); // add this if not present\n            } else {\n              // update selection\n              this.selectNodes([node]);\n            }\n          }\n\n          // show menu on this node\n          this.processContextMenu(node, e);\n        }\n      }\n\n      // TODO\n      // if(this.node_selected != prev_selected)\n      //\tthis.onNodeSelectionChange(this.node_selected);\n\n      this.last_mouse[0] = e.clientX;\n      this.last_mouse[1] = e.clientY;\n      this.last_mouseclick = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getTime();\n      this.last_mouse_dragging = true;\n\n      /*\r\n      if( (this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)\r\n      this.draw();\r\n      */\n\n      this.graph.change();\n\n      // this is to ensure to defocus(blur) if a text input element is on focus\n      if (!ref_window.document.activeElement || ref_window.document.activeElement.nodeName.toLowerCase() != \"input\" && ref_window.document.activeElement.nodeName.toLowerCase() != \"textarea\") {\n        e.preventDefault();\n      }\n      e.stopPropagation();\n      (_this$onMouseDown = this.onMouseDown) === null || _this$onMouseDown === void 0 || _this$onMouseDown.call(this, e);\n      return false;\n    }\n\n    /**\r\n     * Called when a mouse move event has to be processed\r\n     * @method processMouseMove\r\n     **/\n  }, {\n    key: \"processMouseMove\",\n    value: function processMouseMove(e) {\n      if (this.autoresize) {\n        this.resize();\n      }\n      if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n      if (!this.graph) {\n        return;\n      }\n      LGraphCanvas.active_canvas = this;\n      this.adjustMouseEvent(e);\n      var mouse = [e.clientX, e.clientY];\n      this.mouse[0] = mouse[0];\n      this.mouse[1] = mouse[1];\n      var delta = [mouse[0] - this.last_mouse[0], mouse[1] - this.last_mouse[1]];\n      this.last_mouse = mouse;\n      this.graph_mouse[0] = e.canvasX;\n      this.graph_mouse[1] = e.canvasY;\n\n      // LiteGraph.log?.(\"pointerevents: processMouseMove \"+e.pointerId+\" \"+e.isPrimary);\n\n      if (this.block_click) {\n        // LiteGraph.log?.(\"pointerevents: processMouseMove block_click\");\n        e.preventDefault();\n        return false;\n      }\n      e.dragging = this.last_mouse_dragging;\n      if (this.node_widget) {\n        this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e, this.node_widget[1]);\n        this.dirty_canvas = true;\n      }\n\n      // get node over\n      var node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);\n      if (this.dragging_rectangle) {\n        this.dragging_rectangle[2] = e.canvasX - this.dragging_rectangle[0];\n        this.dragging_rectangle[3] = e.canvasY - this.dragging_rectangle[1];\n        this.dirty_canvas = true;\n      } else if (this.selected_group && !this.read_only) {\n        // moving/resizing a group\n        if (this.selected_group_resizing) {\n          this.selected_group.size = [e.canvasX - this.selected_group.pos[0], e.canvasY - this.selected_group.pos[1]];\n        } else {\n          var deltax = delta[0] / this.ds.scale;\n          var deltay = delta[1] / this.ds.scale;\n          this.selected_group.move(deltax, deltay, e.ctrlKey);\n          if (this.selected_group._nodes.length) {\n            this.dirty_canvas = true;\n          }\n        }\n        this.dirty_bgcanvas = true;\n      } else if (this.dragging_canvas) {\n        // //LiteGraph.log?.(\"pointerevents: processMouseMove is dragging_canvas\");\n        this.ds.offset[0] += delta[0] / this.ds.scale;\n        this.ds.offset[1] += delta[1] / this.ds.scale;\n        this.dirty_canvas = true;\n        this.dirty_bgcanvas = true;\n      } else if ((this.allow_interaction || node && node.flags.allow_interaction) && !this.read_only) {\n        if (this.connecting_node) {\n          this.dirty_canvas = true;\n        }\n\n        // remove mouseover flag\n        for (var i = 0, l = this.graph._nodes.length; i < l; ++i) {\n          if (this.graph._nodes[i].mouseOver && node != this.graph._nodes[i]) {\n            // mouse leave\n            this.graph._nodes[i].mouseOver = false;\n            if (this.node_over && this.node_over.onMouseLeave) {\n              this.node_over.onMouseLeave(e);\n            }\n            this.node_over = null;\n            this.dirty_canvas = true;\n          }\n        }\n\n        // mouse over a node\n        if (node) {\n          var _node$onMouseMove;\n          if (node.redraw_on_mouse) this.dirty_canvas = true;\n\n          // this.canvas.style.cursor = \"move\";\n          if (!node.mouseOver) {\n            var _node$onMouseEnter;\n            // mouse enter\n            node.mouseOver = true;\n            this.node_over = node;\n            this.dirty_canvas = true;\n            (_node$onMouseEnter = node.onMouseEnter) === null || _node$onMouseEnter === void 0 || _node$onMouseEnter.call(node, e);\n          }\n\n          // in case the node wants to do something\n          (_node$onMouseMove = node.onMouseMove) === null || _node$onMouseMove === void 0 || _node$onMouseMove.call(node, e, [e.canvasX - node.pos[0], e.canvasY - node.pos[1]], this);\n\n          // if dragging a link\n          if (this.connecting_node) {\n            var pos;\n            if (this.connecting_output) {\n              pos = this._highlight_input || [0, 0]; // to store the output of isOverNodeInput\n\n              // on top of input\n              if (!this.isOverNodeBox(node, e.canvasX, e.canvasY)) {\n                // check if I have a slot below de mouse\n                var slot = this.isOverNodeInput(node, e.canvasX, e.canvasY, pos);\n                if (slot != -1 && node.inputs[slot]) {\n                  var slot_type = node.inputs[slot].type;\n                  if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isValidConnection(this.connecting_output.type, slot_type)) {\n                    this._highlight_input = pos;\n                    this._highlight_input_slot = node.inputs[slot]; // @TODO CHECK THIS\n                  }\n                } else {\n                  this._highlight_input = null;\n                  this._highlight_input_slot = null; // @TODO CHECK THIS\n                }\n              }\n            } else if (this.connecting_input) {\n              pos = this._highlight_output || [0, 0]; // to store the output of isOverNodeOutput\n\n              // on top of output\n              if (this.isOverNodeBox(node, e.canvasX, e.canvasY)) {\n                // check if I have a slot below de mouse\n                var _slot2 = this.isOverNodeOutput(node, e.canvasX, e.canvasY, pos);\n                if (_slot2 != -1 && node.outputs[_slot2]) {\n                  var _slot_type = node.outputs[_slot2].type;\n                  if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isValidConnection(this.connecting_input.type, _slot_type)) {\n                    this._highlight_output = pos;\n                  }\n                } else {\n                  this._highlight_output = null;\n                }\n              }\n            }\n          }\n\n          // Search for corner\n          if (this.canvas) {\n            if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(e.canvasX, e.canvasY, node.pos[0] + node.size[0] - 5, node.pos[1] + node.size[1] - 5, 5, 5)) {\n              this.canvas.style.cursor = \"se-resize\";\n            } else {\n              this.canvas.style.cursor = \"crosshair\";\n            }\n          }\n        } else {\n          // not over a node\n\n          // search for link connector\n          var over_link = null;\n          for (var _i6 = 0; _i6 < this.visible_links.length; ++_i6) {\n            var link = this.visible_links[_i6];\n            var center = link._pos;\n            if (!center || e.canvasX < center[0] - 4 || e.canvasX > center[0] + 4 || e.canvasY < center[1] - 4 || e.canvasY > center[1] + 4) {\n              continue;\n            }\n            over_link = link;\n            break;\n          }\n          if (over_link != this.over_link_center) {\n            this.over_link_center = over_link;\n            this.dirty_canvas = true;\n          }\n          if (this.canvas) {\n            this.canvas.style.cursor = \"\";\n          }\n        } // end\n\n        // send event to node if capturing input (used with widgets that allow drag outside of the area of the node)\n        if (this.node_capturing_input && this.node_capturing_input != node && this.node_capturing_input.onMouseMove) {\n          this.node_capturing_input.onMouseMove(e, [e.canvasX - this.node_capturing_input.pos[0], e.canvasY - this.node_capturing_input.pos[1]], this);\n        }\n\n        // node being dragged\n        if (this.node_dragged && !this.live_mode) {\n          // LiteGraph.log?.(\"draggin!\",this.selected_nodes);\n          for (var _i7 in this.selected_nodes) {\n            var n = this.selected_nodes[_i7];\n            n.pos[0] += delta[0] / this.ds.scale;\n            n.pos[1] += delta[1] / this.ds.scale;\n            if (!n.is_selected) this.processNodeSelected(n, e); /*\r\n                                                                * Don't call the function if the block is already selected.\r\n                                                                * Otherwise, it could cause the block to be unselected while dragging.\r\n                                                                */\n          }\n          this.dirty_canvas = true;\n          this.dirty_bgcanvas = true;\n        }\n        if (this.resizing_node && !this.live_mode) {\n          // convert mouse to node space\n          var desired_size = [e.canvasX - this.resizing_node.pos[0], e.canvasY - this.resizing_node.pos[1]];\n          var min_size = this.resizing_node.computeSize();\n          desired_size[0] = Math.max(min_size[0], desired_size[0]);\n          desired_size[1] = Math.max(min_size[1], desired_size[1]);\n          this.resizing_node.setSize(desired_size);\n          this.canvas.style.cursor = \"se-resize\";\n          this.dirty_canvas = true;\n          this.dirty_bgcanvas = true;\n        }\n      }\n      e.preventDefault();\n      return false;\n    }\n\n    /**\r\n     * Called when a mouse up event has to be processed\r\n     * @method processMouseUp\r\n     **/\n  }, {\n    key: \"processMouseUp\",\n    value: function processMouseUp(e) {\n      var is_primary = e.isPrimary === undefined || e.isPrimary;\n\n      // early exit for extra pointer\n      if (!is_primary) {\n        /* e.stopPropagation();\r\n        e.preventDefault();*/\n        // LiteGraph.log?.(\"pointerevents: processMouseUp pointerN_stop \"+e.pointerId+\" \"+e.isPrimary);\n        return false;\n      }\n\n      // LiteGraph.log?.(\"pointerevents: processMouseUp \"+e.pointerId+\" \"+e.isPrimary+\" :: \"+e.clientX+\" \"+e.clientY);\n\n      if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n      if (!this.graph) return;\n      var window = this.getCanvasWindow();\n      var document = window.document;\n      LGraphCanvas.active_canvas = this;\n\n      // restore the mousemove event back to the canvas\n      if (!this.options.skip_events) {\n        // LiteGraph.log?.(\"pointerevents: processMouseUp adjustEventListener\");\n        document.removeEventListener(\"pointermove\", this._mousemove_callback, true);\n        this.canvas.addEventListener(\"pointermove\", this._mousemove_callback, true);\n        document.removeEventListener(\"pointerup\", this._mouseup_callback, true);\n      }\n      this.adjustMouseEvent(e);\n      var now = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getTime();\n      e.click_time = now - this.last_mouseclick;\n      this.last_mouse_dragging = false;\n      this.last_click_position = null;\n      if (this.block_click) {\n        // LiteGraph.log?.(\"pointerevents: processMouseUp block_clicks\");\n        this.block_click = false; // used to avoid sending twice a click in a immediate button\n      }\n\n      // LiteGraph.log?.(\"pointerevents: processMouseUp which: \"+e.which);\n\n      if (e.which == 1) {\n        if (this.node_widget) {\n          this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e);\n        }\n\n        // left button\n        this.node_widget = null;\n        if (this.selected_group) {\n          var diffx = this.selected_group.pos[0] - Math.round(this.selected_group.pos[0]);\n          var diffy = this.selected_group.pos[1] - Math.round(this.selected_group.pos[1]);\n          this.selected_group.move(diffx, diffy, e.ctrlKey);\n          this.selected_group.pos[0] = Math.round(this.selected_group.pos[0]);\n          this.selected_group.pos[1] = Math.round(this.selected_group.pos[1]);\n          if (this.selected_group._nodes.length) {\n            this.dirty_canvas = true;\n          }\n          this.selected_group = null;\n        }\n        this.selected_group_resizing = false;\n        var node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);\n        if (this.dragging_rectangle) {\n          if (this.graph) {\n            var nodes = this.graph._nodes;\n            var node_bounding = new Float32Array(4);\n\n            // compute bounding and flip if left to right\n            var w = Math.abs(this.dragging_rectangle[2]);\n            var h = Math.abs(this.dragging_rectangle[3]);\n            var startx = this.dragging_rectangle[2] < 0 ? this.dragging_rectangle[0] - w : this.dragging_rectangle[0];\n            var starty = this.dragging_rectangle[3] < 0 ? this.dragging_rectangle[1] - h : this.dragging_rectangle[1];\n            this.dragging_rectangle[0] = startx;\n            this.dragging_rectangle[1] = starty;\n            this.dragging_rectangle[2] = w;\n            this.dragging_rectangle[3] = h;\n\n            // test dragging rect size, if minimun simulate a click\n            if (!node || w > 10 && h > 10) {\n              // test against all nodes (not visible because the rectangle maybe start outside\n              var to_select = [];\n              for (var i = 0; i < nodes.length; ++i) {\n                var nodeX = nodes[i];\n                nodeX.getBounding(node_bounding);\n                if (!_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.overlapBounding(this.dragging_rectangle, node_bounding)) {\n                  continue;\n                } // out of the visible area\n                to_select.push(nodeX);\n              }\n              if (to_select.length) {\n                this.selectNodes(to_select, e.shiftKey); // add to selection with shift\n              }\n            } else {\n              // will select of update selection\n              this.selectNodes([node], e.shiftKey || e.ctrlKey); // add to selection add to selection with ctrlKey or shiftKey\n            }\n          }\n          this.dragging_rectangle = null;\n        } else if (this.connecting_node) {\n          // dragging a connection\n          this.dirty_canvas = true;\n          this.dirty_bgcanvas = true;\n          var connInOrOut = this.connecting_output || this.connecting_input;\n          var connType = connInOrOut.type;\n          node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);\n\n          // node below mouse\n          if (node) {\n            /* @TODO: Excise?\r\n            // no need to condition on event type.. just another type\r\n            if (\r\n                connType == LiteGraph.EVENT &&\r\n                this.isOverNodeBox(node, e.canvasX, e.canvasY)\r\n            ) {\r\n                  this.connecting_node.connect(\r\n                    this.connecting_slot,\r\n                    node,\r\n                    LiteGraph.EVENT\r\n                );\r\n              } else {*/\n\n            // slot below mouse? connect\n            var slot;\n            if (this.connecting_output) {\n              slot = this.isOverNodeInput(node, e.canvasX, e.canvasY);\n              if (slot != -1) {\n                this.connecting_node.connect(this.connecting_slot, node, slot);\n              } else {\n                // not on top of an input\n                // look for a good slot\n                this.connecting_node.connectByType(this.connecting_slot, node, connType);\n              }\n            } else if (this.connecting_input) {\n              slot = this.isOverNodeOutput(node, e.canvasX, e.canvasY);\n              if (slot != -1) {\n                node.connect(slot, this.connecting_node, this.connecting_slot); // this is inverted has output-input nature like\n              } else {\n                // not on top of an input\n                // look for a good slot\n                this.connecting_node.connectByTypeOutput(this.connecting_slot, node, connType);\n              }\n            }\n            // }\n          } else {\n            // add menu when releasing link in empty space\n            if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.release_link_on_empty_shows_menu) {\n              if (e.shiftKey && this.allow_searchbox) {\n                if (this.connecting_output) {\n                  this.showSearchBox(e, {\n                    node_from: this.connecting_node,\n                    slot_from: this.connecting_output,\n                    type_filter_in: this.connecting_output.type\n                  });\n                } else if (this.connecting_input) {\n                  this.showSearchBox(e, {\n                    node_to: this.connecting_node,\n                    slot_from: this.connecting_input,\n                    type_filter_out: this.connecting_input.type\n                  });\n                }\n              } else {\n                if (this.connecting_output) {\n                  this.showConnectionMenu({\n                    nodeFrom: this.connecting_node,\n                    slotFrom: this.connecting_output,\n                    e: e\n                  });\n                } else if (this.connecting_input) {\n                  this.showConnectionMenu({\n                    nodeTo: this.connecting_node,\n                    slotTo: this.connecting_input,\n                    e: e\n                  });\n                }\n              }\n            }\n          }\n          this.connecting_output = null;\n          this.connecting_input = null;\n          this.connecting_pos = null;\n          this.connecting_node = null;\n          this.connecting_slot = -1;\n        } else if (this.resizing_node) {\n          // not dragging connection\n          this.dirty_canvas = true;\n          this.dirty_bgcanvas = true;\n          this.graph.afterChange(this.resizing_node);\n          this.resizing_node = null;\n        } else if (this.node_dragged) {\n          var _this$onNodeMoved;\n          // node being dragged?\n          node = this.node_dragged;\n          if (node && e.click_time < 300 && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(e.canvasX, e.canvasY, node.pos[0], node.pos[1] - _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT)) {\n            node.collapse();\n          }\n          this.dirty_canvas = true;\n          this.dirty_bgcanvas = true;\n          this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);\n          this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);\n          if (this.graph.config.align_to_grid || this.align_to_grid) {\n            this.node_dragged.alignToGrid();\n          }\n          (_this$onNodeMoved = this.onNodeMoved) === null || _this$onNodeMoved === void 0 || _this$onNodeMoved.call(this, this.node_dragged);\n          this.graph.onGraphChanged({\n            action: \"nodeDrag\",\n            doSave: true\n          });\n          this.graph.afterChange(this.node_dragged);\n          this.node_dragged = null;\n        } else {\n          // no node being dragged\n          // get node over\n          node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);\n          if (!node && e.click_time < 300) {\n            this.deselectAllNodes();\n          }\n          this.dirty_canvas = true;\n          this.dragging_canvas = false;\n          if (this.node_over && this.node_over.onMouseUp) {\n            this.node_over.onMouseUp(e, [e.canvasX - this.node_over.pos[0], e.canvasY - this.node_over.pos[1]], this);\n          }\n          if (this.node_capturing_input && this.node_capturing_input.onMouseUp) {\n            this.node_capturing_input.onMouseUp(e, [e.canvasX - this.node_capturing_input.pos[0], e.canvasY - this.node_capturing_input.pos[1]]);\n          }\n        }\n      } else if (e.which == 2) {\n        // middle button\n        // trace(\"middle\");\n        this.dirty_canvas = true;\n        this.dragging_canvas = false;\n      } else if (e.which == 3) {\n        // right button\n        // trace(\"right\");\n        this.dirty_canvas = true;\n        this.dragging_canvas = false;\n      }\n\n      /*\r\n      if((this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)\r\n          this.draw();\r\n      */\n\n      if (is_primary) {\n        this.pointer_is_down = false;\n        this.pointer_is_double = false;\n      }\n      this.graph.change();\n\n      // LiteGraph.log?.(\"pointerevents: processMouseUp stopPropagation\");\n      e.stopPropagation();\n      e.preventDefault();\n      return false;\n    }\n  }, {\n    key: \"isOverNodeBox\",\n    value:\n    /**\r\n     * returns true if a position (in graph space) is on top of a node little corner box\r\n     * @method isOverNodeBox\r\n     **/\n    function isOverNodeBox(node, canvasx, canvasy) {\n      var title_height = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT;\n      if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(canvasx, canvasy, node.pos[0] + 2, node.pos[1] + 2 - title_height, title_height - 4, title_height - 4)) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\r\n     * returns the INDEX if a position (in graph space) is on top of a node input slot\r\n     * @method isOverNodeInput\r\n     **/\n  }, {\n    key: \"isOverNodeInput\",\n    value: function isOverNodeInput(node, canvasx, canvasy, slot_pos) {\n      if (node.inputs) {\n        for (var i = 0, l = node.inputs.length; i < l; ++i) {\n          var link_pos = node.getConnectionPos(true, i);\n          var is_inside = false;\n          if (node.horizontal) {\n            is_inside = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(canvasx, canvasy, link_pos[0] - 5, link_pos[1] - 10, 10, 20);\n          } else {\n            is_inside = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(canvasx, canvasy, link_pos[0] - 10, link_pos[1] - 5, 40, 10);\n          }\n          if (is_inside) {\n            if (slot_pos) {\n              slot_pos[0] = link_pos[0];\n              slot_pos[1] = link_pos[1];\n            }\n            return i;\n          }\n        }\n      }\n      return -1;\n    }\n\n    /**\r\n     * returns the INDEX if a position (in graph space) is on top of a node output slot\r\n     * @method isOverNodeOuput\r\n     **/\n  }, {\n    key: \"isOverNodeOutput\",\n    value: function isOverNodeOutput(node, canvasx, canvasy, slot_pos) {\n      if (node.outputs) {\n        for (var i = 0, l = node.outputs.length; i < l; ++i) {\n          var link_pos = node.getConnectionPos(false, i);\n          var is_inside = false;\n          if (node.horizontal) {\n            is_inside = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(canvasx, canvasy, link_pos[0] - 5, link_pos[1] - 10, 10, 20);\n          } else {\n            is_inside = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(canvasx, canvasy, link_pos[0] - 10, link_pos[1] - 5, 40, 10);\n          }\n          if (is_inside) {\n            if (slot_pos) {\n              slot_pos[0] = link_pos[0];\n              slot_pos[1] = link_pos[1];\n            }\n            return i;\n          }\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: \"copyToClipboard\",\n    value: function copyToClipboard() {\n      var clipboard_info = {\n        nodes: [],\n        links: []\n      };\n      var index = 0;\n      var selected_nodes_array = [];\n      for (var i in this.selected_nodes) {\n        var node = this.selected_nodes[i];\n        if (node.clonable === false) continue;\n        node._relative_id = index;\n        selected_nodes_array.push(node);\n        index += 1;\n      }\n      for (var _i8 = 0; _i8 < selected_nodes_array.length; ++_i8) {\n        var _node6 = selected_nodes_array[_i8];\n        if (_node6.clonable === false) continue;\n        var cloned = _node6.clone();\n        if (!cloned) {\n          var _LiteGraph$warn3;\n          (_LiteGraph$warn3 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn3 === void 0 || _LiteGraph$warn3.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"node type not found: \" + _node6.type);\n          continue;\n        }\n        clipboard_info.nodes.push(cloned.serialize());\n        if (_node6.inputs && _node6.inputs.length) {\n          for (var j = 0; j < _node6.inputs.length; ++j) {\n            var input = _node6.inputs[j];\n            if (!input || input.link == null) {\n              continue;\n            }\n            var link_info = this.graph.links[input.link];\n            if (!link_info) {\n              continue;\n            }\n            var target_node = this.graph.getNodeById(link_info.origin_id);\n            if (!target_node) {\n              continue;\n            }\n            clipboard_info.links.push([target_node._relative_id, link_info.origin_slot,\n            // j,\n            _node6._relative_id, link_info.target_slot, target_node.id]);\n          }\n        }\n      }\n      localStorage.setItem(\"litegrapheditor_clipboard\", JSON.stringify(clipboard_info));\n    }\n  }, {\n    key: \"pasteFromClipboard\",\n    value: function pasteFromClipboard() {\n      var isConnectUnselected = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // if ctrl + shift + v is off, return when isConnectUnselected is true (shift is pressed) to maintain old behavior\n      if (!_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) {\n        return;\n      }\n      var data = localStorage.getItem(\"litegrapheditor_clipboard\");\n      if (!data) {\n        return;\n      }\n      this.graph.beforeChange();\n\n      // create nodes\n      var clipboard_info = JSON.parse(data);\n      // calculate top-left node, could work without this processing but using diff with last node pos :: clipboard_info.nodes[clipboard_info.nodes.length-1].pos\n      var posMin = false;\n      var posMinIndexes = false;\n      for (var i = 0; i < clipboard_info.nodes.length; ++i) {\n        if (posMin) {\n          if (posMin[0] > clipboard_info.nodes[i].pos[0]) {\n            posMin[0] = clipboard_info.nodes[i].pos[0];\n            posMinIndexes[0] = i;\n          }\n          if (posMin[1] > clipboard_info.nodes[i].pos[1]) {\n            posMin[1] = clipboard_info.nodes[i].pos[1];\n            posMinIndexes[1] = i;\n          }\n        } else {\n          posMin = [clipboard_info.nodes[i].pos[0], clipboard_info.nodes[i].pos[1]];\n          posMinIndexes = [i, i];\n        }\n      }\n      var nodes = [];\n      for (var _i9 = 0; _i9 < clipboard_info.nodes.length; ++_i9) {\n        var node_data = clipboard_info.nodes[_i9];\n        var node = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.createNode(node_data.type);\n        if (node) {\n          node.configure(node_data);\n\n          // paste in last known mouse position\n          node.pos[0] += this.graph_mouse[0] - posMin[0]; // += 5;\n          node.pos[1] += this.graph_mouse[1] - posMin[1]; // += 5;\n\n          this.graph.add(node, {\n            doProcessChange: false\n          });\n          nodes.push(node);\n        }\n      }\n\n      // create links\n      for (var _i10 = 0; _i10 < clipboard_info.links.length; ++_i10) {\n        var _LiteGraph$warn4;\n        var link_info = clipboard_info.links[_i10];\n        var origin_node = undefined;\n        var origin_node_relative_id = link_info[0];\n        if (origin_node_relative_id != null) {\n          origin_node = nodes[origin_node_relative_id];\n        } else if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) {\n          var origin_node_id = link_info[4];\n          if (origin_node_id) {\n            origin_node = this.graph.getNodeById(origin_node_id);\n          }\n        }\n        var target_node = nodes[link_info[2]];\n        if (origin_node && target_node) origin_node.connect(link_info[1], target_node, link_info[3]);else (_LiteGraph$warn4 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn4 === void 0 || _LiteGraph$warn4.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Warning, nodes missing on pasting\");\n      }\n      this.selectNodes(nodes);\n      this.graph.onGraphChanged({\n        action: \"paste\",\n        doSave: true\n      });\n      this.graph.afterChange();\n    }\n  }, {\n    key: \"checkDropItem\",\n    value:\n    // called if the graph doesn't have a default drop item behaviour\n    function checkDropItem(e) {\n      if (e.dataTransfer.files.length) {\n        var file = e.dataTransfer.files[0];\n        var ext = LGraphCanvas.getFileExtension(file.name).toLowerCase();\n        var nodetype = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.node_types_by_file_extension[ext];\n        if (nodetype) {\n          var _node$onDropFile;\n          this.graph.beforeChange();\n          var node = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.createNode(nodetype.type);\n          node.pos = [e.canvasX, e.canvasY];\n          this.graph.add(node, false, {\n            doProcessChange: false\n          });\n          (_node$onDropFile = node.onDropFile) === null || _node$onDropFile === void 0 || _node$onDropFile.call(node, file);\n          this.graph.onGraphChanged({\n            action: \"fileDrop\",\n            doSave: true\n          });\n          this.graph.afterChange();\n        }\n      }\n    }\n  }, {\n    key: \"processNodeDblClicked\",\n    value: function processNodeDblClicked(n) {\n      var _this$onNodeDblClicke;\n      if (this.onShowNodePanel) {\n        this.onShowNodePanel(n);\n      } else {\n        this.showShowNodePanel(n);\n      }\n      (_this$onNodeDblClicke = this.onNodeDblClicked) === null || _this$onNodeDblClicke === void 0 || _this$onNodeDblClicke.call(this, n);\n      this.setDirty(true);\n    }\n  }, {\n    key: \"processNodeSelected\",\n    value: function processNodeSelected(node, e) {\n      var _this$onNodeSelected;\n      this.selectNode(node, e && (e.shiftKey || e.ctrlKey || this.multi_select));\n      (_this$onNodeSelected = this.onNodeSelected) === null || _this$onNodeSelected === void 0 || _this$onNodeSelected.call(this, node);\n    }\n\n    /**\r\n     * selects a given node (or adds it to the current selection)\r\n     * @method selectNode\r\n     **/\n  }, {\n    key: \"selectNode\",\n    value: function selectNode(node, add_to_current_selection) {\n      if (node == null) {\n        this.deselectAllNodes();\n      } else {\n        this.selectNodes([node], add_to_current_selection);\n      }\n    }\n\n    /**\r\n     * selects several nodes (or adds them to the current selection)\r\n     * @method selectNodes\r\n     **/\n  }, {\n    key: \"selectNodes\",\n    value: function selectNodes(nodes, add_to_current_selection) {\n      var _this3 = this,\n        _this$onSelectionChan;\n      if (!add_to_current_selection) {\n        this.deselectAllNodes();\n      }\n      nodes = nodes || this.graph._nodes;\n      if (typeof nodes == \"string\") nodes = [nodes];\n      Object.values(nodes).forEach(function (node) {\n        var _node$onSelected, _node$inputs, _node$outputs;\n        if (node.is_selected) {\n          _this3.deselectNode(node);\n          return;\n        }\n        node.is_selected = true;\n        _this3.selected_nodes[node.id] = node;\n        (_node$onSelected = node.onSelected) === null || _node$onSelected === void 0 || _node$onSelected.call(node);\n        (_node$inputs = node.inputs) === null || _node$inputs === void 0 || _node$inputs.forEach(function (input) {\n          _this3.highlighted_links[input.link] = true;\n        });\n        (_node$outputs = node.outputs) === null || _node$outputs === void 0 || _node$outputs.forEach(function (out) {\n          var _out$links;\n          (_out$links = out.links) === null || _out$links === void 0 || _out$links.forEach(function (link) {\n            _this3.highlighted_links[link] = true;\n          });\n        });\n      });\n      (_this$onSelectionChan = this.onSelectionChange) === null || _this$onSelectionChan === void 0 || _this$onSelectionChan.call(this, this.selected_nodes);\n      this.setDirty(true);\n    }\n\n    /**\r\n     * removes a node from the current selection\r\n     * @method deselectNode\r\n     **/\n  }, {\n    key: \"deselectNode\",\n    value: function deselectNode(node) {\n      var _node$onDeselected,\n        _this$onNodeDeselecte,\n        _node$inputs2,\n        _this4 = this,\n        _node$outputs2;\n      if (!node.is_selected) return;\n      (_node$onDeselected = node.onDeselected) === null || _node$onDeselected === void 0 || _node$onDeselected.call(node);\n      node.is_selected = false;\n      (_this$onNodeDeselecte = this.onNodeDeselected) === null || _this$onNodeDeselecte === void 0 || _this$onNodeDeselecte.call(this, node);\n\n      // Remove highlighted\n      (_node$inputs2 = node.inputs) === null || _node$inputs2 === void 0 || _node$inputs2.forEach(function (input) {\n        var _this4$highlighted_li;\n        (_this4$highlighted_li = _this4.highlighted_links) === null || _this4$highlighted_li === void 0 || delete _this4$highlighted_li[input.link];\n      });\n      (_node$outputs2 = node.outputs) === null || _node$outputs2 === void 0 || _node$outputs2.forEach(function (out) {\n        var _out$links2;\n        (_out$links2 = out.links) === null || _out$links2 === void 0 || _out$links2.forEach(function (link) {\n          var _this4$highlighted_li2;\n          return (_this4$highlighted_li2 = _this4.highlighted_links) === null || _this4$highlighted_li2 === void 0 || delete _this4$highlighted_li2[link];\n        });\n      });\n    }\n\n    /**\r\n     * removes all nodes from the current selection\r\n     * @method deselectAllNodes\r\n     **/\n  }, {\n    key: \"deselectAllNodes\",\n    value: function deselectAllNodes() {\n      var _this$graph$_nodes,\n        _this5 = this,\n        _this$onSelectionChan2;\n      if (!this.graph) {\n        return;\n      }\n      (_this$graph$_nodes = this.graph._nodes) === null || _this$graph$_nodes === void 0 || _this$graph$_nodes.forEach(function (node) {\n        var _node$onDeselected2, _this5$onNodeDeselect;\n        if (!node.is_selected) return;\n        (_node$onDeselected2 = node.onDeselected) === null || _node$onDeselected2 === void 0 || _node$onDeselected2.call(node);\n        node.is_selected = false;\n        (_this5$onNodeDeselect = _this5.onNodeDeselected) === null || _this5$onNodeDeselect === void 0 || _this5$onNodeDeselect.call(_this5, node);\n      });\n      this.selected_nodes = {};\n      this.current_node = null;\n      this.highlighted_links = {};\n      (_this$onSelectionChan2 = this.onSelectionChange) === null || _this$onSelectionChan2 === void 0 || _this$onSelectionChan2.call(this, this.selected_nodes);\n      this.setDirty(true);\n    }\n\n    /**\r\n     * deletes all nodes in the current selection from the graph\r\n     * @method deleteSelectedNodes\r\n     **/\n  }, {\n    key: \"deleteSelectedNodes\",\n    value: function deleteSelectedNodes() {\n      this.graph.beforeChange();\n      for (var i in this.selected_nodes) {\n        var node = this.selected_nodes[i];\n        if (node.block_delete) continue;\n\n        // autoconnect when possible (very basic, only takes into account first input-output)\n        if (node.inputs && node.inputs.length && node.outputs && node.outputs.length && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isValidConnection(node.inputs[0].type, node.outputs[0].type) && node.inputs[0].link && node.outputs[0].links && node.outputs[0].links.length) {\n          var input_link = node.graph.links[node.inputs[0].link];\n          var output_link = node.graph.links[node.outputs[0].links[0]];\n          var input_node = node.getInputNode(0);\n          var output_node = node.getOutputNodes(0)[0];\n          if (input_node && output_node) input_node.connect(input_link.origin_slot, output_node, output_link.target_slot);\n        }\n        this.graph.remove(node);\n        if (this.onNodeDeselected) {\n          this.onNodeDeselected(node);\n        }\n      }\n      this.selected_nodes = {};\n      this.current_node = null;\n      this.highlighted_links = {};\n      this.setDirty(true);\n      this.graph.afterChange();\n    }\n\n    /**\r\n     * centers the camera on a given node\r\n     * @method centerOnNode\r\n     **/\n  }, {\n    key: \"centerOnNode\",\n    value: function centerOnNode(node) {\n      this.ds.offset[0] = -node.pos[0] - node.size[0] * 0.5 + this.canvas.width * 0.5 / this.ds.scale;\n      this.ds.offset[1] = -node.pos[1] - node.size[1] * 0.5 + this.canvas.height * 0.5 / this.ds.scale;\n      this.setDirty(true, true);\n    }\n\n    /**\r\n     * adds some useful properties to a mouse event, like the position in graph coordinates\r\n     * @method adjustMouseEvent\r\n     **/\n  }, {\n    key: \"adjustMouseEvent\",\n    value: function adjustMouseEvent(e) {\n      var clientX_rel = 0;\n      var clientY_rel = 0;\n      if (this.canvas) {\n        var b = this.canvas.getBoundingClientRect();\n        clientX_rel = e.clientX - b.left;\n        clientY_rel = e.clientY - b.top;\n      } else {\n        clientX_rel = e.clientX;\n        clientY_rel = e.clientY;\n      }\n\n      // e.deltaX = clientX_rel - this.last_mouse_position[0];\n      // e.deltaY = clientY_rel- this.last_mouse_position[1];\n\n      this.last_mouse_position[0] = clientX_rel;\n      this.last_mouse_position[1] = clientY_rel;\n      e.canvasX = clientX_rel / this.ds.scale - this.ds.offset[0];\n      e.canvasY = clientY_rel / this.ds.scale - this.ds.offset[1];\n\n      // LiteGraph.log?.(\"pointerevents: adjustMouseEvent \"+e.clientX+\":\"+e.clientY+\" \"+clientX_rel+\":\"+clientY_rel+\" \"+e.canvasX+\":\"+e.canvasY);\n    }\n\n    /**\r\n     * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot the zoom\r\n     * @method setZoom\r\n     **/\n  }, {\n    key: \"setZoom\",\n    value: function setZoom(value, zooming_center) {\n      this.ds.changeScale(value, zooming_center);\n      /*\r\n      if(!zooming_center && this.canvas)\r\n      zooming_center = [this.canvas.width * 0.5,this.canvas.height * 0.5];\r\n      var center = this.convertOffsetToCanvas( zooming_center );\r\n      this.ds.scale = value;\r\n      if(this.scale > this.max_zoom)\r\n      this.scale = this.max_zoom;\r\n      else if(this.scale < this.min_zoom)\r\n      this.scale = this.min_zoom;\r\n      var new_center = this.convertOffsetToCanvas( zooming_center );\r\n      var delta_offset = [new_center[0] - center[0], new_center[1] - center[1]];\r\n      this.offset[0] += delta_offset[0];\r\n      this.offset[1] += delta_offset[1];\r\n      */\n\n      this.dirty_canvas = true;\n      this.dirty_bgcanvas = true;\n    }\n\n    /**\r\n     * converts a coordinate from graph coordinates to canvas2D coordinates\r\n     * @method convertOffsetToCanvas\r\n     **/\n  }, {\n    key: \"convertOffsetToCanvas\",\n    value: function convertOffsetToCanvas(pos, out) {\n      return this.ds.convertOffsetToCanvas(pos, out);\n    }\n\n    /**\r\n     * converts a coordinate from Canvas2D coordinates to graph space\r\n     * @method convertCanvasToOffset\r\n     **/\n  }, {\n    key: \"convertCanvasToOffset\",\n    value: function convertCanvasToOffset(pos, out) {\n      return this.ds.convertCanvasToOffset(pos, out);\n    }\n\n    // converts event coordinates from canvas2D to graph coordinates\n  }, {\n    key: \"convertEventToCanvasOffset\",\n    value: function convertEventToCanvasOffset(e) {\n      var rect = this.canvas.getBoundingClientRect();\n      return this.convertCanvasToOffset([e.clientX - rect.left, e.clientY - rect.top]);\n    }\n\n    /**\r\n     * brings a node to front (above all other nodes)\r\n     * @method bringToFront\r\n     **/\n  }, {\n    key: \"bringToFront\",\n    value: function bringToFront(node) {\n      var i = this.graph._nodes.indexOf(node);\n      if (i == -1) {\n        return;\n      }\n      this.graph._nodes.splice(i, 1);\n      this.graph._nodes.push(node);\n    }\n\n    /**\r\n     * sends a node to the back (below all other nodes)\r\n     * @method sendToBack\r\n     **/\n  }, {\n    key: \"sendToBack\",\n    value: function sendToBack(node) {\n      var i = this.graph._nodes.indexOf(node);\n      if (i == -1) {\n        return;\n      }\n      this.graph._nodes.splice(i, 1);\n      this.graph._nodes.unshift(node);\n    }\n\n    /**\r\n     * checks which nodes are visible (inside the camera area)\r\n     * @method computeVisibleNodes\r\n     **/\n  }, {\n    key: \"computeVisibleNodes\",\n    value: function computeVisibleNodes(nodes, out) {\n      var visible_nodes = out || [];\n      visible_nodes.length = 0;\n      nodes = nodes || this.graph._nodes;\n      for (var i = 0, l = nodes.length; i < l; ++i) {\n        var n = nodes[i];\n\n        // skip rendering nodes in live mode\n        if (this.live_mode && !n.onDrawBackground && !n.onDrawForeground) {\n          continue;\n        }\n        if (!_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.overlapBounding(this.visible_area, n.getBounding(temp, true))) {\n          continue;\n        } // out of the visible area\n\n        visible_nodes.push(n);\n      }\n      return visible_nodes;\n    }\n\n    /**\r\n     * renders the whole canvas content, by rendering in two separated canvas, one containing the background grid and the connections, and one containing the nodes)\r\n     * @method draw\r\n     **/\n  }, {\n    key: \"draw\",\n    value: function draw(force_canvas, force_bgcanvas) {\n      if (!this.canvas || this.canvas.width == 0 || this.canvas.height == 0) {\n        return;\n      }\n\n      // fps counting\n      var now = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getTime();\n      this.render_time = (now - this.last_draw_time) * 0.001;\n      this.last_draw_time = now;\n      if (this.graph) {\n        this.ds.computeVisibleArea(this.viewport);\n      }\n      if (this.dirty_bgcanvas || force_bgcanvas || this.always_render_background || this.graph && this.graph._last_trigger_time && now - this.graph._last_trigger_time < 1000) {\n        this.drawBackCanvas();\n      }\n      var draw_front_canvas = this.dirty_canvas || force_canvas;\n      if (draw_front_canvas) {\n        this.drawFrontCanvas();\n      }\n      this.fps = this.render_time ? 1.0 / this.render_time : 0;\n      this.frame += 1;\n\n      // update low qualty counter\n      if (this.ds.scale < 0.7) {\n        if (draw_front_canvas) {\n          // count only slow frames with havy rendering\n          var threshold = this.low_quality_rendering_threshold;\n          var acceptable_fps = 45;\n          if (this.fps < acceptable_fps) {\n            this.low_quality_rendering_counter += acceptable_fps / this.fps;\n            this.low_quality_rendering_counter = Math.min(this.low_quality_rendering_counter, 2 * threshold); // clamp counter\n          } else {\n            // make 100 slower the recovery as there are a lot of cahced rendering calls\n            this.low_quality_rendering_counter -= this.fps / acceptable_fps * 0.01;\n            this.low_quality_rendering_counter = Math.max(this.low_quality_rendering_counter, 0); // clamp counter\n          }\n        }\n      } else {\n        // force reset to high quality when zoomed in\n        this.low_quality_rendering_counter = 0;\n      }\n    }\n\n    /**\r\n     * draws the front canvas (the one containing all the nodes)\r\n     * @method drawFrontCanvas\r\n     **/\n  }, {\n    key: \"drawFrontCanvas\",\n    value: function drawFrontCanvas() {\n      var _this$onRender, _this$onDrawOverlay, _ctx$finish2D;\n      this.dirty_canvas = false;\n      if (!this.ctx) {\n        this.ctx = this.bgcanvas.getContext(\"2d\");\n      }\n      var ctx = this.ctx;\n      if (!ctx) {\n        // maybe is using webgl...\n        return;\n      }\n      var canvas = this.canvas;\n      if (ctx.start2D && !this.viewport) {\n        ctx.start2D();\n        ctx.restore();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n      }\n\n      // clip dirty area if there is one, otherwise work in full canvas\n      var area = this.viewport || this.dirty_area;\n      if (area) {\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(area[0], area[1], area[2], area[3]);\n        ctx.clip();\n      }\n\n      // clear\n      // canvas.width = canvas.width;\n      if (this.clear_background) {\n        if (area) ctx.clearRect(area[0], area[1], area[2], area[3]);else ctx.clearRect(0, 0, canvas.width, canvas.height);\n      }\n\n      // draw bg canvas\n      if (this.bgcanvas == this.canvas) {\n        this.drawBackCanvas();\n      } else {\n        ctx.drawImage(this.bgcanvas, 0, 0);\n      }\n\n      // rendering\n      (_this$onRender = this.onRender) === null || _this$onRender === void 0 || _this$onRender.call(this, canvas, ctx);\n\n      // info widget\n      if (this.show_info) {\n        this.renderInfo(ctx, area ? area[0] : 0, area ? area[1] : 0);\n      }\n      if (this.graph) {\n        var _this$onDrawLinkToolt, _this$onDrawForegroun;\n        // apply transformations\n        ctx.save();\n        this.ds.toCanvasContext(ctx);\n        var visible_nodes = this.computeVisibleNodes(null, this.visible_nodes);\n        for (var i = 0; i < visible_nodes.length; ++i) {\n          var node = visible_nodes[i];\n\n          // transform coords system\n          ctx.save();\n          ctx.translate(node.pos[0], node.pos[1]);\n\n          // Draw\n          this.drawNode(node, ctx);\n\n          // Restore\n          ctx.restore();\n        }\n\n        // on top (debug)\n        if (this.render_execution_order) {\n          this.drawExecutionOrder(ctx);\n        }\n\n        // connections ontop?\n        if (this.graph.config.links_ontop) {\n          if (!this.live_mode) {\n            this.drawConnections(ctx);\n          }\n        }\n\n        // current connection (the one being dragged by the mouse)\n        if (this.connecting_pos != null) {\n          ctx.lineWidth = this.connections_width;\n          var link_color = null;\n          var connInOrOut = this.connecting_output || this.connecting_input;\n          var connType = connInOrOut.type;\n          var connDir = connInOrOut.dir;\n          if (connDir == null) {\n            if (this.connecting_output) connDir = this.connecting_node.horizontal ? _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.DOWN : _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.RIGHT;else connDir = this.connecting_node.horizontal ? _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.UP : _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LEFT;\n          }\n          var connShape = connInOrOut.shape;\n          switch (connType) {\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT:\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION:\n              link_color = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT_LINK_COLOR;\n              break;\n            default:\n              link_color = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CONNECTING_LINK_COLOR;\n          }\n\n          // the connection being dragged by the mouse\n          this.renderLink(ctx, this.connecting_pos, [this.graph_mouse[0], this.graph_mouse[1]], null, false, null, link_color, connDir, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CENTER);\n          ctx.beginPath();\n          if (connType === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT || connType === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION || connShape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.BOX_SHAPE) {\n            ctx.rect(this.connecting_pos[0] - 6 + 0.5, this.connecting_pos[1] - 5 + 0.5, 14, 10);\n            ctx.fill();\n            ctx.beginPath();\n            ctx.rect(this.graph_mouse[0] - 6 + 0.5, this.graph_mouse[1] - 5 + 0.5, 14, 10);\n          } else if (connShape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ARROW_SHAPE) {\n            ctx.moveTo(this.connecting_pos[0] + 8, this.connecting_pos[1] + 0.5);\n            ctx.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] + 6 + 0.5);\n            ctx.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] - 6 + 0.5);\n            ctx.closePath();\n          } else {\n            ctx.arc(this.connecting_pos[0], this.connecting_pos[1], 4, 0, Math.PI * 2);\n            ctx.fill();\n            ctx.beginPath();\n            ctx.arc(this.graph_mouse[0], this.graph_mouse[1], 4, 0, Math.PI * 2);\n          }\n          ctx.fill();\n          ctx.fillStyle = \"#ffcc00\";\n          if (this._highlight_input) {\n            ctx.beginPath();\n            var shape = this._highlight_input_slot.shape;\n            if (shape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ARROW_SHAPE) {\n              ctx.moveTo(this._highlight_input[0] + 8, this._highlight_input[1] + 0.5);\n              ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] + 6 + 0.5);\n              ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] - 6 + 0.5);\n              ctx.closePath();\n            } else {\n              ctx.arc(this._highlight_input[0], this._highlight_input[1], 6, 0, Math.PI * 2);\n            }\n            ctx.fill();\n          }\n          if (this._highlight_output) {\n            ctx.beginPath();\n            if (shape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ARROW_SHAPE) {\n              ctx.moveTo(this._highlight_output[0] + 8, this._highlight_output[1] + 0.5);\n              ctx.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] + 6 + 0.5);\n              ctx.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] - 6 + 0.5);\n              ctx.closePath();\n            } else {\n              ctx.arc(this._highlight_output[0], this._highlight_output[1], 6, 0, Math.PI * 2);\n            }\n            ctx.fill();\n          }\n        }\n\n        // the selection rectangle\n        if (this.dragging_rectangle) {\n          ctx.strokeStyle = \"#FFF\";\n          ctx.strokeRect(this.dragging_rectangle[0], this.dragging_rectangle[1], this.dragging_rectangle[2], this.dragging_rectangle[3]);\n        }\n\n        // on top of link center\n        if (this.over_link_center && this.render_link_tooltip) this.drawLinkTooltip(ctx, this.over_link_center);else (_this$onDrawLinkToolt = this.onDrawLinkTooltip) === null || _this$onDrawLinkToolt === void 0 || _this$onDrawLinkToolt.call(this, ctx, null);\n\n        // custom info\n        (_this$onDrawForegroun = this.onDrawForeground) === null || _this$onDrawForegroun === void 0 || _this$onDrawForegroun.call(this, ctx, this.visible_rect);\n        ctx.restore();\n      }\n\n      // draws panel in the corner\n      if (this._graph_stack && this._graph_stack.length) {\n        this.drawSubgraphPanel(ctx);\n      }\n      (_this$onDrawOverlay = this.onDrawOverlay) === null || _this$onDrawOverlay === void 0 || _this$onDrawOverlay.call(this, ctx);\n      if (area) {\n        ctx.restore();\n      }\n      (_ctx$finish2D = ctx.finish2D) === null || _ctx$finish2D === void 0 || _ctx$finish2D.call(ctx);\n    }\n\n    /**\r\n     * draws the panel in the corner that shows subgraph properties\r\n     * @method drawSubgraphPanel\r\n     **/\n  }, {\n    key: \"drawSubgraphPanel\",\n    value: function drawSubgraphPanel(ctx) {\n      var subgraph = this.graph;\n      if (!subgraph) return;\n      var subnode = subgraph._subgraph_node;\n      if (!subnode) {\n        var _LiteGraph$warn5;\n        (_LiteGraph$warn5 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn5 === void 0 || _LiteGraph$warn5.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"subgraph without subnode\");\n        return;\n      }\n      this.drawSubgraphPanelLeft(subgraph, subnode, ctx);\n      this.drawSubgraphPanelRight(subgraph, subnode, ctx);\n    }\n  }, {\n    key: \"drawSubgraphPanelLeft\",\n    value: function drawSubgraphPanelLeft(subgraph, subnode, ctx) {\n      var num = subnode.inputs ? subnode.inputs.length : 0;\n      var w = 200;\n      var h = Math.floor(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_SLOT_HEIGHT * 1.6);\n      ctx.fillStyle = \"#111\";\n      ctx.globalAlpha = 0.8;\n      ctx.beginPath();\n      ctx.roundRect(10, 10, w, (num + 1) * h + 50, [8]);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n      ctx.fillStyle = \"#888\";\n      ctx.font = \"14px Arial\";\n      ctx.textAlign = \"left\";\n      ctx.fillText(\"Graph Inputs\", 20, 34);\n      // var pos = this.mouse;\n\n      if (this.drawButton(w - 20, 20, 20, 20, \"X\", \"#151515\")) {\n        this.closeSubgraph();\n        return;\n      }\n      var y = 50;\n      ctx.font = \"14px Arial\";\n      if (subnode.inputs) for (var i = 0; i < subnode.inputs.length; ++i) {\n        var input = subnode.inputs[i];\n        if (input.not_subgraph_input) continue;\n\n        // input button clicked\n        if (this.drawButton(20, y + 2, w - 20, h - 2)) {\n          var _LiteGraph$error;\n          var type = subnode.constructor.input_node_type || \"graph/input\";\n          this.graph.beforeChange();\n          var newnode = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.createNode(type);\n          if (newnode) {\n            subgraph.add(newnode, false, {\n              doProcessChange: false\n            });\n            this.block_click = false;\n            this.last_click_position = null;\n            this.selectNodes([newnode]);\n            this.node_dragged = newnode;\n            this.dragging_canvas = false;\n            newnode.setProperty(\"name\", input.name);\n            newnode.setProperty(\"type\", input.type);\n            this.node_dragged.pos[0] = this.graph_mouse[0] - 5;\n            this.node_dragged.pos[1] = this.graph_mouse[1] - 5;\n            this.graph.afterChange();\n          } else (_LiteGraph$error = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.error) === null || _LiteGraph$error === void 0 || _LiteGraph$error.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"graph input node not found:\", type);\n        }\n        ctx.fillStyle = \"#9C9\";\n        ctx.beginPath();\n        ctx.arc(w - 16, y + h * 0.5, 5, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"#AAA\";\n        ctx.fillText(input.name, 30, y + h * 0.75);\n        // var tw = ctx.measureText(input.name);\n        ctx.fillStyle = \"#777\";\n        ctx.fillText(input.type, 130, y + h * 0.75);\n        y += h;\n      }\n      // add + button\n      if (this.drawButton(20, y + 2, w - 20, h - 2, \"+\", \"#151515\", \"#222\")) {\n        this.showSubgraphPropertiesDialog(subnode);\n      }\n    }\n  }, {\n    key: \"drawSubgraphPanelRight\",\n    value: function drawSubgraphPanelRight(subgraph, subnode, ctx) {\n      var num = subnode.outputs ? subnode.outputs.length : 0;\n      var canvas_w = this.bgcanvas.width;\n      var w = 200;\n      var h = Math.floor(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_SLOT_HEIGHT * 1.6);\n      ctx.fillStyle = \"#111\";\n      ctx.globalAlpha = 0.8;\n      ctx.beginPath();\n      ctx.roundRect(canvas_w - w - 10, 10, w, (num + 1) * h + 50, [8]);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n      ctx.fillStyle = \"#888\";\n      ctx.font = \"14px Arial\";\n      ctx.textAlign = \"left\";\n      var title_text = \"Graph Outputs\";\n      var tw = ctx.measureText(title_text).width;\n      ctx.fillText(title_text, canvas_w - tw - 20, 34);\n      // var pos = this.mouse;\n      if (this.drawButton(canvas_w - w, 20, 20, 20, \"X\", \"#151515\")) {\n        this.closeSubgraph();\n        return;\n      }\n      var y = 50;\n      ctx.font = \"14px Arial\";\n      if (subnode.outputs) for (var i = 0; i < subnode.outputs.length; ++i) {\n        var output = subnode.outputs[i];\n        if (output.not_subgraph_input) continue;\n\n        // output button clicked\n        if (this.drawButton(canvas_w - w, y + 2, w - 20, h - 2)) {\n          var _LiteGraph$error2;\n          var type = subnode.constructor.output_node_type || \"graph/output\";\n          this.graph.beforeChange();\n          var newnode = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.createNode(type);\n          if (newnode) {\n            subgraph.add(newnode, false, {\n              doProcessChange: false\n            });\n            this.block_click = false;\n            this.last_click_position = null;\n            this.selectNodes([newnode]);\n            this.node_dragged = newnode;\n            this.dragging_canvas = false;\n            newnode.setProperty(\"name\", output.name);\n            newnode.setProperty(\"type\", output.type);\n            this.node_dragged.pos[0] = this.graph_mouse[0] - 5;\n            this.node_dragged.pos[1] = this.graph_mouse[1] - 5;\n            this.graph.afterChange();\n          } else (_LiteGraph$error2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.error) === null || _LiteGraph$error2 === void 0 || _LiteGraph$error2.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"graph input node not found:\", type);\n        }\n        ctx.fillStyle = \"#9C9\";\n        ctx.beginPath();\n        ctx.arc(canvas_w - w + 16, y + h * 0.5, 5, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"#AAA\";\n        ctx.fillText(output.name, canvas_w - w + 30, y + h * 0.75);\n        // var tw = ctx.measureText(input.name);\n        ctx.fillStyle = \"#777\";\n        ctx.fillText(output.type, canvas_w - w + 130, y + h * 0.75);\n        y += h;\n      }\n      // add + button\n      if (this.drawButton(canvas_w - w, y + 2, w - 20, h - 2, \"+\", \"#151515\", \"#222\")) {\n        this.showSubgraphPropertiesDialogRight(subnode);\n      }\n    }\n\n    // Draws a button into the canvas overlay and computes if it was clicked using the immediate gui paradigm\n  }, {\n    key: \"drawButton\",\n    value: function drawButton(x, y, w, h, text, bgcolor, hovercolor, textcolor) {\n      var ctx = this.ctx;\n      bgcolor = bgcolor || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_DEFAULT_COLOR;\n      hovercolor = hovercolor || \"#555\";\n      textcolor = textcolor || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TEXT_COLOR;\n      var pos = this.ds.convertOffsetToCanvas(this.graph_mouse);\n      var hover = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(pos[0], pos[1], x, y, w, h);\n      pos = this.last_click_position ? [this.last_click_position[0], this.last_click_position[1]] : null;\n      if (pos) {\n        var rect = this.canvas.getBoundingClientRect();\n        pos[0] -= rect.left;\n        pos[1] -= rect.top;\n      }\n      var clicked = pos && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(pos[0], pos[1], x, y, w, h);\n      ctx.fillStyle = hover ? hovercolor : bgcolor;\n      if (clicked) ctx.fillStyle = \"#AAA\";\n      ctx.beginPath();\n      ctx.roundRect(x, y, w, h, [4]);\n      ctx.fill();\n      if (text != null) {\n        if (text.constructor == String) {\n          ctx.fillStyle = textcolor;\n          ctx.textAlign = \"center\";\n          ctx.font = (h * 0.65 | 0) + \"px Arial\";\n          ctx.fillText(text, x + w * 0.5, y + h * 0.75);\n          ctx.textAlign = \"left\";\n        }\n      }\n      var was_clicked = clicked && !this.block_click;\n      if (clicked) this.blockClick();\n      return was_clicked;\n    }\n  }, {\n    key: \"isAreaClicked\",\n    value: function isAreaClicked(x, y, w, h, hold_click) {\n      var pos = this.last_click_position;\n      var clicked = pos && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(pos[0], pos[1], x, y, w, h);\n      var was_clicked = clicked && !this.block_click;\n      if (clicked && hold_click) this.blockClick();\n      return was_clicked;\n    }\n\n    /**\r\n     * draws some useful stats in the corner of the canvas\r\n     * @method renderInfo\r\n     **/\n  }, {\n    key: \"renderInfo\",\n    value: function renderInfo(ctx, x, y) {\n      x = x || 10;\n      y = y || this.canvas.height - 80;\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.font = \"10px Arial\";\n      ctx.fillStyle = \"#888\";\n      ctx.textAlign = \"left\";\n      if (this.graph) {\n        ctx.fillText(\"T: \" + this.graph.globaltime.toFixed(2) + \"s\", 5, 13 * 1);\n        ctx.fillText(\"I: \" + this.graph.iteration, 5, 13 * 2);\n        ctx.fillText(\"N: \" + this.graph._nodes.length + \" [\" + this.visible_nodes.length + \"]\", 5, 13 * 3);\n        ctx.fillText(\"V: \" + this.graph._version, 5, 13 * 4);\n        ctx.fillText(\"FPS:\" + this.fps.toFixed(2), 5, 13 * 5);\n      } else {\n        ctx.fillText(\"No graph selected\", 5, 13 * 1);\n      }\n      ctx.restore();\n    }\n\n    /**\r\n     * draws the back canvas (the one containing the background and the connections)\r\n     * @method drawBackCanvas\r\n     **/\n  }, {\n    key: \"drawBackCanvas\",\n    value: function drawBackCanvas() {\n      var _this6 = this,\n        _ctx$finish;\n      var canvas = this.bgcanvas;\n      if (!this.bgctx) {\n        this.bgctx = this.bgcanvas.getContext(\"2d\");\n      }\n      var ctx = this.bgctx;\n      if (ctx.start) {\n        ctx.start();\n      }\n      var viewport = this.viewport || [0, 0, ctx.canvas.width, ctx.canvas.height];\n\n      // clear\n      if (this.clear_background) {\n        ctx.clearRect(viewport[0], viewport[1], viewport[2], viewport[3]);\n      }\n\n      // show subgraph stack header\n      if (this._graph_stack && this._graph_stack.length) {\n        ctx.save();\n        var subgraph_node = this.graph._subgraph_node;\n        ctx.strokeStyle = subgraph_node.bgcolor;\n        ctx.lineWidth = 10;\n        ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);\n        ctx.lineWidth = 1;\n        ctx.font = \"40px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.fillStyle = subgraph_node.bgcolor || \"#AAA\";\n        var title = \"\";\n        this._graph_stack.slice(1).forEach(function (item, index) {\n          title += \"\".concat(item._subgraph_node.getTitle(), \" \").concat(index < _this6._graph_stack.length - 2 ? \">> \" : \"\");\n        });\n        ctx.fillText(title + subgraph_node.getTitle(), canvas.width * 0.5, 40);\n        ctx.restore();\n      }\n      var bg_already_painted = false;\n      if (this.onRenderBackground) {\n        bg_already_painted = this.onRenderBackground(canvas, ctx);\n      }\n\n      // reset in case of error\n      if (!this.viewport) {\n        ctx.restore();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n      }\n      this.visible_links.length = 0;\n      if (this.graph) {\n        var _this$onDrawBackgroun;\n        // apply transformations\n        ctx.save();\n        this.ds.toCanvasContext(ctx);\n\n        // render BG\n        if (this.ds.scale < 1.5 && !bg_already_painted && this.clear_background_color) {\n          ctx.fillStyle = this.clear_background_color;\n          ctx.fillRect(this.visible_area[0], this.visible_area[1], this.visible_area[2], this.visible_area[3]);\n        }\n        if (this.background_image && this.ds.scale > 0.5 && !bg_already_painted) {\n          if (this.zoom_modify_alpha) {\n            ctx.globalAlpha = (1.0 - 0.5 / this.ds.scale) * this.editor_alpha;\n          } else {\n            ctx.globalAlpha = this.editor_alpha;\n          }\n          ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled = false; // ctx.mozImageSmoothingEnabled =\n          if (!this._bg_img || this._bg_img.name != this.background_image) {\n            this._bg_img = new Image();\n            this._bg_img.name = this.background_image;\n            this._bg_img.src = this.background_image;\n            var that = this;\n            this._bg_img.onload = function () {\n              that.draw(true, true);\n            };\n          }\n          var pattern = null;\n          if (this._pattern == null && this._bg_img.width > 0) {\n            pattern = ctx.createPattern(this._bg_img, \"repeat\");\n            this._pattern_img = this._bg_img;\n            this._pattern = pattern;\n          } else {\n            pattern = this._pattern;\n          }\n          if (pattern) {\n            ctx.fillStyle = pattern;\n            ctx.fillRect(this.visible_area[0], this.visible_area[1], this.visible_area[2], this.visible_area[3]);\n            ctx.fillStyle = \"transparent\";\n          }\n          ctx.globalAlpha = 1.0;\n          ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled = true; // = ctx.mozImageSmoothingEnabled\n        }\n\n        // groups\n        if (this.graph._groups.length && !this.live_mode) {\n          this.drawGroups(canvas, ctx);\n        }\n        (_this$onDrawBackgroun = this.onDrawBackground) === null || _this$onDrawBackgroun === void 0 || _this$onDrawBackgroun.call(this, ctx, this.visible_area);\n        if (this.onBackgroundRender) {\n          var _LiteGraph$error3;\n          // LEGACY\n          (_LiteGraph$error3 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.error) === null || _LiteGraph$error3 === void 0 || _LiteGraph$error3.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"WARNING! onBackgroundRender deprecated, now is named onDrawBackground \");\n          this.onBackgroundRender = null;\n        }\n\n        // DEBUG: show clipping area\n        // ctx.fillStyle = \"red\";\n        // ctx.fillRect( this.visible_area[0] + 10, this.visible_area[1] + 10, this.visible_area[2] - 20, this.visible_area[3] - 20);\n\n        // bg\n        if (this.render_canvas_border) {\n          ctx.strokeStyle = \"#235\";\n          ctx.strokeRect(0, 0, canvas.width, canvas.height);\n        }\n        if (this.render_connections_shadows) {\n          ctx.shadowColor = \"#000\";\n          ctx.shadowOffsetX = 0;\n          ctx.shadowOffsetY = 0;\n          ctx.shadowBlur = 6;\n        } else {\n          ctx.shadowColor = \"rgba(0,0,0,0)\";\n        }\n\n        // draw connections\n        if (!this.live_mode) {\n          this.drawConnections(ctx);\n        }\n        ctx.shadowColor = \"rgba(0,0,0,0)\";\n\n        // restore state\n        ctx.restore();\n      }\n      (_ctx$finish = ctx.finish) === null || _ctx$finish === void 0 || _ctx$finish.call(ctx);\n      this.dirty_bgcanvas = false;\n      this.dirty_canvas = true; // to force to repaint the front canvas with the bgcanvas\n    }\n\n    /**\r\n     * draws the given node inside the canvas\r\n     * @method drawNode\r\n     **/\n  }, {\n    key: \"drawNode\",\n    value: function drawNode(node, ctx) {\n      var _node$onDrawCollapsed, _node$onDrawForegroun2;\n      this.current_node = node;\n      var color = node.color || node.constructor.color || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_DEFAULT_COLOR;\n      var bgcolor = node.bgcolor || node.constructor.bgcolor || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_DEFAULT_BGCOLOR;\n      var low_quality = this.ds.scale < 0.6; // zoomed out\n\n      // only render if it forces it to do it\n      if (this.live_mode) {\n        if (!node.flags.collapsed) {\n          var _node$onDrawForegroun;\n          ctx.shadowColor = \"transparent\";\n          (_node$onDrawForegroun = node.onDrawForeground) === null || _node$onDrawForegroun === void 0 || _node$onDrawForegroun.call(node, ctx, this, this.canvas);\n        }\n        return;\n      }\n      var editor_alpha = this.editor_alpha;\n      ctx.globalAlpha = editor_alpha;\n      if (this.render_shadows && !low_quality) {\n        ctx.shadowColor = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.DEFAULT_SHADOW_COLOR;\n        ctx.shadowOffsetX = 2 * this.ds.scale;\n        ctx.shadowOffsetY = 2 * this.ds.scale;\n        ctx.shadowBlur = 3 * this.ds.scale;\n      } else {\n        ctx.shadowColor = \"transparent\";\n      }\n\n      // custom draw collapsed method (draw after shadows because they are affected)\n      if (node.flags.collapsed && (_node$onDrawCollapsed = node.onDrawCollapsed) !== null && _node$onDrawCollapsed !== void 0 && _node$onDrawCollapsed.call(node, ctx, this)) {\n        return;\n      }\n\n      // clip if required (mask)\n      var shape = node._shape || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.BOX_SHAPE;\n      var size = temp_vec2;\n      temp_vec2.set(node.size);\n      var horizontal = node.horizontal; // || node.flags.horizontal;\n\n      if (node.flags.collapsed) {\n        ctx.font = this.inner_text_font;\n        var title = node.getTitle ? node.getTitle() : node.title;\n        if (title != null) {\n          node._collapsed_width = Math.min(node.size[0], ctx.measureText(title).width + _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT * 2); // LiteGraph.NODE_COLLAPSED_WIDTH;\n          size[0] = node._collapsed_width;\n          size[1] = 0;\n        }\n      }\n      if (node.clip_area || this.clip_all_nodes) {\n        // Start clipping\n        ctx.save();\n        ctx.beginPath();\n        if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.BOX_SHAPE) {\n          ctx.rect(0, 0, size[0], size[1]);\n        } else if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ROUND_SHAPE) {\n          ctx.roundRect(0, 0, size[0], size[1], [10]);\n        } else if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CIRCLE_SHAPE) {\n          ctx.arc(size[0] * 0.5, size[1] * 0.5, size[0] * 0.5, 0, Math.PI * 2);\n        }\n        ctx.clip();\n      }\n\n      // draw shape\n      if (node.has_errors) {\n        bgcolor = \"red\";\n      }\n      this.drawNodeShape(node, ctx, size, color, bgcolor, node.is_selected, node.mouseOver);\n      ctx.shadowColor = \"transparent\";\n\n      // draw foreground\n      (_node$onDrawForegroun2 = node.onDrawForeground) === null || _node$onDrawForegroun2 === void 0 || _node$onDrawForegroun2.call(node, ctx, this, this.canvas);\n\n      // node tooltip\n      if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.show_node_tooltip && node.mouseOver && node.is_selected && (!this.selected_nodes || Object.keys(this.selected_nodes).length <= 1)) {\n        this.drawNodeTooltip(ctx, node);\n      }\n\n      // connection slots\n      ctx.textAlign = horizontal ? \"center\" : \"left\";\n      ctx.font = this.inner_text_font;\n      var render_text = !this.lowQualityRenderingRequired(0.6);\n      var out_slot = this.connecting_output;\n      var in_slot = this.connecting_input;\n      ctx.lineWidth = 1;\n      var max_y = 0;\n      var slot_pos = new Float32Array(2); // to reuse\n      var doStroke;\n\n      // render inputs and outputs\n      if (!node.flags.collapsed) {\n        // input connection slots\n        if (node.inputs) {\n          for (var i = 0; i < node.inputs.length; i++) {\n            var _slot3 = node.inputs[i];\n            var slot_type = _slot3.type;\n            var slot_shape = _slot3.shape;\n            ctx.globalAlpha = editor_alpha;\n            // change opacity of incompatible slots when dragging a connection\n            if (this.connecting_output && !_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isValidConnection(_slot3.type, out_slot.type)) {\n              ctx.globalAlpha = 0.4 * editor_alpha;\n            }\n            ctx.fillStyle = _slot3.link != null ? _slot3.color_on || this.default_connection_color_byType[slot_type] || this.default_connection_color.input_on : _slot3.color_off || this.default_connection_color_byTypeOff[slot_type] || this.default_connection_color_byType[slot_type] || this.default_connection_color.input_off;\n            var pos = node.getConnectionPos(true, i, slot_pos);\n            pos[0] -= node.pos[0];\n            pos[1] -= node.pos[1];\n            if (max_y < pos[1] + _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_SLOT_HEIGHT * 0.5) {\n              max_y = pos[1] + _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_SLOT_HEIGHT * 0.5;\n            }\n            ctx.beginPath();\n            if (slot_type == \"array\") {\n              slot_shape = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.GRID_SHAPE; // place in addInput? addOutput instead?\n            } else if (_slot3.name == \"onTrigger\" || _slot3.name == \"onExecuted\") {\n              slot_shape = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ARROW_SHAPE;\n            } else if (slot_type === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT || slot_type === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION) {\n              slot_shape = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.BOX_SHAPE;\n            }\n            doStroke = true;\n            if (slot_shape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.BOX_SHAPE) {\n              if (horizontal) {\n                ctx.rect(pos[0] - 5 + 0.5, pos[1] - 8 + 0.5, 10, 14);\n              } else {\n                ctx.rect(pos[0] - 6 + 0.5, pos[1] - 5 + 0.5, 14, 10);\n              }\n            } else if (slot_shape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ARROW_SHAPE) {\n              ctx.moveTo(pos[0] + 8, pos[1] + 0.5);\n              ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);\n              ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);\n              ctx.closePath();\n            } else if (slot_shape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.GRID_SHAPE) {\n              ctx.rect(pos[0] - 4, pos[1] - 4, 2, 2);\n              ctx.rect(pos[0] - 1, pos[1] - 4, 2, 2);\n              ctx.rect(pos[0] + 2, pos[1] - 4, 2, 2);\n              ctx.rect(pos[0] - 4, pos[1] - 1, 2, 2);\n              ctx.rect(pos[0] - 1, pos[1] - 1, 2, 2);\n              ctx.rect(pos[0] + 2, pos[1] - 1, 2, 2);\n              ctx.rect(pos[0] - 4, pos[1] + 2, 2, 2);\n              ctx.rect(pos[0] - 1, pos[1] + 2, 2, 2);\n              ctx.rect(pos[0] + 2, pos[1] + 2, 2, 2);\n              doStroke = false;\n            } else {\n              if (low_quality) ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8); // faster\n              else ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);\n            }\n            ctx.fill();\n\n            // render name\n            if (render_text && !(_slot3.name == \"onTrigger\" || _slot3.name == \"onExecuted\")) {\n              var text = _slot3.label != null ? _slot3.label : _slot3.name;\n              if (text) {\n                ctx.fillStyle = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TEXT_COLOR;\n                if (horizontal || _slot3.dir == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.UP) {\n                  ctx.fillText(text, pos[0], pos[1] - 10);\n                } else {\n                  ctx.fillText(text, pos[0] + 10, pos[1] + 5);\n                }\n              }\n            }\n          }\n        }\n\n        // output connection slots\n\n        ctx.textAlign = horizontal ? \"center\" : \"right\";\n        ctx.strokeStyle = \"black\";\n        if (node.outputs) {\n          for (var _i11 = 0; _i11 < node.outputs.length; _i11++) {\n            var _slot4 = node.outputs[_i11];\n            var _slot_type2 = _slot4.type;\n            var _slot_shape = _slot4.shape;\n\n            // change opacity of incompatible slots when dragging a connection\n            if (this.connecting_input && !_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isValidConnection(_slot_type2, in_slot.type)) {\n              ctx.globalAlpha = 0.4 * editor_alpha;\n            }\n            var _pos = node.getConnectionPos(false, _i11, slot_pos);\n            _pos[0] -= node.pos[0];\n            _pos[1] -= node.pos[1];\n            if (max_y < _pos[1] + _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_SLOT_HEIGHT * 0.5) {\n              max_y = _pos[1] + _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_SLOT_HEIGHT * 0.5;\n            }\n            ctx.fillStyle = _slot4.links && _slot4.links.length ? _slot4.color_on || this.default_connection_color_byType[_slot_type2] || this.default_connection_color.output_on : _slot4.color_off || this.default_connection_color_byTypeOff[_slot_type2] || this.default_connection_color_byType[_slot_type2] || this.default_connection_color.output_off;\n            ctx.beginPath();\n            // ctx.rect( node.size[0] - 14,i*14,10,10);\n\n            if (_slot_type2 == \"array\") {\n              _slot_shape = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.GRID_SHAPE;\n            } else if (_slot4.name == \"onTrigger\" || _slot4.name == \"onExecuted\") {\n              _slot_shape = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ARROW_SHAPE;\n            } else if (_slot_type2 === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT || _slot_type2 === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION) {\n              _slot_shape = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.BOX_SHAPE;\n            }\n            doStroke = true;\n            if (_slot_shape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.BOX_SHAPE) {\n              if (horizontal) {\n                ctx.rect(_pos[0] - 5 + 0.5, _pos[1] - 8 + 0.5, 10, 14);\n              } else {\n                ctx.rect(_pos[0] - 6 + 0.5, _pos[1] - 5 + 0.5, 14, 10);\n              }\n            } else if (_slot_shape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ARROW_SHAPE) {\n              ctx.moveTo(_pos[0] + 8, _pos[1] + 0.5);\n              ctx.lineTo(_pos[0] - 4, _pos[1] + 6 + 0.5);\n              ctx.lineTo(_pos[0] - 4, _pos[1] - 6 + 0.5);\n              ctx.closePath();\n            } else if (_slot_shape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.GRID_SHAPE) {\n              ctx.rect(_pos[0] - 4, _pos[1] - 4, 2, 2);\n              ctx.rect(_pos[0] - 1, _pos[1] - 4, 2, 2);\n              ctx.rect(_pos[0] + 2, _pos[1] - 4, 2, 2);\n              ctx.rect(_pos[0] - 4, _pos[1] - 1, 2, 2);\n              ctx.rect(_pos[0] - 1, _pos[1] - 1, 2, 2);\n              ctx.rect(_pos[0] + 2, _pos[1] - 1, 2, 2);\n              ctx.rect(_pos[0] - 4, _pos[1] + 2, 2, 2);\n              ctx.rect(_pos[0] - 1, _pos[1] + 2, 2, 2);\n              ctx.rect(_pos[0] + 2, _pos[1] + 2, 2, 2);\n              doStroke = false;\n            } else {\n              if (low_quality) ctx.rect(_pos[0] - 4, _pos[1] - 4, 8, 8);else ctx.arc(_pos[0], _pos[1], 4, 0, Math.PI * 2);\n            }\n\n            // trigger\n            // if(slot.node_id != null && slot.slot == -1)\n            //\tctx.fillStyle = \"#F85\";\n\n            // if(slot.links != null && slot.links.length)\n            ctx.fill();\n            if (!low_quality && doStroke) ctx.stroke();\n\n            // render output name\n            if (render_text && !(_slot4.name == \"onTrigger\" || _slot4.name == \"onExecuted\")) {\n              var _text = _slot4.label != null ? _slot4.label : _slot4.name;\n              if (_text) {\n                ctx.fillStyle = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TEXT_COLOR;\n                if (horizontal || _slot4.dir == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.DOWN) {\n                  ctx.fillText(_text, _pos[0], _pos[1] - 8);\n                } else {\n                  ctx.fillText(_text, _pos[0] - 10, _pos[1] + 5);\n                }\n              }\n            }\n          }\n        }\n        ctx.textAlign = \"left\";\n        ctx.globalAlpha = 1;\n        if (node.widgets) {\n          var widgets_y = max_y;\n          if (horizontal || node.widgets_up) {\n            widgets_y = 2;\n          }\n          if (node.widgets_start_y != null) widgets_y = node.widgets_start_y;\n          this.drawNodeWidgets(node, widgets_y, ctx, this.node_widget && this.node_widget[0] == node ? this.node_widget[1] : null);\n        }\n      } else if (this.render_collapsed_slots) {\n        // if collapsed\n        var input_slot = null;\n        var output_slot = null;\n\n        // get first connected slot to render\n        if (node.inputs) {\n          for (var _i12 = 0; _i12 < node.inputs.length; _i12++) {\n            var slot = node.inputs[_i12];\n            if (slot.link == null) {\n              continue;\n            }\n            input_slot = slot;\n            break;\n          }\n        }\n        if (node.outputs) {\n          for (var _i13 = 0; _i13 < node.outputs.length; _i13++) {\n            var slot = node.outputs[_i13];\n            if (!slot.links || !slot.links.length) {\n              continue;\n            }\n            output_slot = slot;\n          }\n        }\n        if (input_slot) {\n          var x = 0;\n          var y = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT * -0.5; // center\n          if (horizontal) {\n            x = node._collapsed_width * 0.5;\n            y = -_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT;\n          }\n          ctx.fillStyle = \"#686\";\n          ctx.beginPath();\n          if (slot.type === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT || slot.type === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION || slot.shape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.BOX_SHAPE) {\n            ctx.rect(x - 7 + 0.5, y - 4, 14, 8);\n          } else if (slot.shape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ARROW_SHAPE) {\n            ctx.moveTo(x + 8, y);\n            ctx.lineTo(x + -4, y - 4);\n            ctx.lineTo(x + -4, y + 4);\n            ctx.closePath();\n          } else {\n            ctx.arc(x, y, 4, 0, Math.PI * 2);\n          }\n          ctx.fill();\n        }\n        if (output_slot) {\n          var _x = node._collapsed_width;\n          var _y = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT * -0.5; // center\n          if (horizontal) {\n            _x = node._collapsed_width * 0.5;\n            _y = 0;\n          }\n          ctx.fillStyle = \"#686\";\n          ctx.strokeStyle = \"black\";\n          ctx.beginPath();\n          if (slot.type === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT || slot.type === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION || slot.shape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.BOX_SHAPE) {\n            ctx.rect(_x - 7 + 0.5, _y - 4, 14, 8);\n          } else if (slot.shape === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ARROW_SHAPE) {\n            ctx.moveTo(_x + 6, _y);\n            ctx.lineTo(_x - 6, _y - 4);\n            ctx.lineTo(_x - 6, _y + 4);\n            ctx.closePath();\n          } else {\n            ctx.arc(_x, _y, 4, 0, Math.PI * 2);\n          }\n          ctx.fill();\n          // ctx.stroke();\n        }\n      }\n      if (node.clip_area || this.clip_all_nodes) {\n        ctx.restore();\n      }\n      ctx.globalAlpha = 1.0;\n    }\n  }, {\n    key: \"drawNodeTooltip\",\n    value: function drawNodeTooltip(ctx, node) {\n      if (!node || !ctx) {\n        var _LiteGraph$warn6;\n        (_LiteGraph$warn6 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn6 === void 0 || _LiteGraph$warn6.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"drawNodeTooltip: invalid node or ctx\", node, ctx);\n        return;\n      }\n      var text = node.properties.tooltip != undefined ? node.properties.tooltip : \"\";\n      if (!text || text == \"\") {\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.show_node_tooltip_use_descr_property && node.constructor.desc) {\n          text = node.constructor.desc;\n        }\n      }\n      text = (text + \"\").trim();\n      if (!text || text == \"\") {\n        // DBG(\"Empty tooltip\");\n        return;\n      }\n      var pos = [0, -_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT]; // node.pos;\n      // text = text.substr(0,30); //avoid weird\n      // text = text + \"\\n\" + text;\n      var size = node.flags.collapsed ? [_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_COLLAPSED_WIDTH, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT] : node.size;\n\n      // using a trick to save the calculated height of the tip the first time using trasparent, to than show it\n      // node.ttip_oTMultiRet is not set or false the first time\n\n      ctx.font = \"14px Courier New\";\n      var info = ctx.measureText(text);\n      var w = Math.max(node.size[0], 160) + 20; // info.width + 20;\n      var h = node.ttip_oTMultiRet ? node.ttip_oTMultiRet.height + 15 : 21;\n      ctx.globalAlpha = 0.7 * this.editor_alpha;\n      ctx.shadowColor = node.ttip_oTMultiRet ? \"black\" : \"transparent\";\n      ctx.shadowOffsetX = 2;\n      ctx.shadowOffsetY = 2;\n      ctx.shadowBlur = 3;\n      ctx.fillStyle = node.ttip_oTMultiRet ? \"#454\" : \"transparent\";\n      ctx.beginPath();\n      ctx.roundRect(pos[0] - w * 0.5 + size[0] / 2, pos[1] - 15 - h, w, h, [3]);\n      ctx.moveTo(pos[0] - 10 + size[0] / 2, pos[1] - 15);\n      ctx.lineTo(pos[0] + 10 + size[0] / 2, pos[1] - 15);\n      ctx.lineTo(pos[0] + size[0] / 2, pos[1] - 5);\n      ctx.fill();\n      ctx.shadowColor = \"transparent\";\n      ctx.textAlign = \"center\";\n      ctx.fillStyle = node.ttip_oTMultiRet ? \"#CEC\" : \"transparent\";\n      ctx.globalAlpha = this.editor_alpha;\n\n      // ctx.fillText(text, pos[0] + size[0]/2, pos[1] - 15 - h * 0.3);\n      var oTMultiRet = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.canvasFillTextMultiline(ctx, text, pos[0] + size[0] / 2, pos[1] - h, w, 14);\n      node.ttip_oTMultiRet = oTMultiRet;\n      ctx.closePath();\n    }\n\n    // used by this.over_link_center\n  }, {\n    key: \"drawLinkTooltip\",\n    value: function drawLinkTooltip(ctx, link) {\n      var _this$onDrawLinkToolt2;\n      var pos = link._pos;\n      ctx.fillStyle = \"black\";\n      ctx.beginPath();\n      ctx.arc(pos[0], pos[1], 3, 0, Math.PI * 2);\n      ctx.fill();\n      if (link.data == null) return;\n      if ((_this$onDrawLinkToolt2 = this.onDrawLinkTooltip) !== null && _this$onDrawLinkToolt2 !== void 0 && _this$onDrawLinkToolt2.call(this, ctx, link, this)) return;\n      var data = link.data;\n      var text = null;\n      if (data.constructor === Number) text = data.toFixed(2);else if (data.constructor === String) text = \"\\\"\" + data + \"\\\"\";else if (data.constructor === Boolean) text = String(data);else if (data.toToolTip) text = data.toToolTip();else text = \"[\" + data.constructor.name + \"]\";\n      if (text == null) return;\n      text = text.substr(0, 30); // avoid weird\n\n      ctx.font = \"14px Courier New\";\n      var info = ctx.measureText(text);\n      var w = info.width + 20;\n      var h = 24;\n      ctx.shadowColor = \"black\";\n      ctx.shadowOffsetX = 2;\n      ctx.shadowOffsetY = 2;\n      ctx.shadowBlur = 3;\n      ctx.fillStyle = \"#454\";\n      ctx.beginPath();\n      ctx.roundRect(pos[0] - w * 0.5, pos[1] - 15 - h, w, h, [3]);\n      ctx.moveTo(pos[0] - 10, pos[1] - 15);\n      ctx.lineTo(pos[0] + 10, pos[1] - 15);\n      ctx.lineTo(pos[0], pos[1] - 5);\n      ctx.fill();\n      ctx.shadowColor = \"transparent\";\n      ctx.textAlign = \"center\";\n      ctx.fillStyle = \"#CEC\";\n      ctx.fillText(text, pos[0], pos[1] - 15 - h * 0.3);\n    }\n  }, {\n    key: \"drawNodeShape\",\n    value: function drawNodeShape(node, ctx, size, fgcolor, bgcolor, selected, mouse_over) {\n      var _node$onDrawBackgroun;\n      // bg rect\n      ctx.strokeStyle = fgcolor;\n      ctx.fillStyle = bgcolor;\n      var title_height = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT;\n      var low_quality = this.lowQualityRenderingRequired(0.5);\n\n      // render node area depending on shape\n      var shape = node._shape || node.constructor.shape || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ROUND_SHAPE;\n      var title_mode = node.constructor.title_mode;\n      var render_title = true;\n      if (title_mode == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.TRANSPARENT_TITLE || title_mode == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NO_TITLE) {\n        render_title = false;\n      } else if (title_mode == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.AUTOHIDE_TITLE && mouse_over) {\n        render_title = true;\n      }\n      var area = tmp_area;\n      area[0] = 0; // x\n      area[1] = render_title ? -title_height : 0; // y\n      area[2] = size[0] + 1; // w\n      area[3] = render_title ? size[1] + title_height : size[1]; // h\n\n      var old_alpha = ctx.globalAlpha;\n\n      // full node shape\n      // if(node.flags.collapsed)\n      {\n        ctx.beginPath();\n        if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.BOX_SHAPE || low_quality) {\n          ctx.fillRect(area[0], area[1], area[2], area[3]);\n        } else if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ROUND_SHAPE || shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CARD_SHAPE) {\n          ctx.roundRect(area[0], area[1], area[2], area[3], shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CARD_SHAPE ? [this.round_radius, this.round_radius, 0, 0] : [this.round_radius]);\n        } else if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CIRCLE_SHAPE) {\n          ctx.arc(size[0] * 0.5, size[1] * 0.5, size[0] * 0.5, 0, Math.PI * 2);\n        }\n        ctx.fill();\n\n        // separator\n        if (!node.flags.collapsed && render_title) {\n          ctx.shadowColor = \"transparent\";\n          ctx.fillStyle = \"rgba(0,0,0,0.2)\";\n          ctx.fillRect(0, -1, area[2], 2);\n        }\n      }\n      ctx.shadowColor = \"transparent\";\n      (_node$onDrawBackgroun = node.onDrawBackground) === null || _node$onDrawBackgroun === void 0 || _node$onDrawBackgroun.call(node, ctx, this, this.canvas, this.graph_mouse);\n\n      // title bg (remember, it is rendered ABOVE the node)\n      if (render_title || title_mode == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.TRANSPARENT_TITLE) {\n        // title bar\n        if (node.onDrawTitleBar) {\n          node.onDrawTitleBar(ctx, title_height, size, this.ds.scale, fgcolor);\n        } else if (title_mode != _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.TRANSPARENT_TITLE && (node.constructor.title_color || this.render_title_colored)) {\n          var title_color = node.constructor.title_color || fgcolor;\n          if (node.flags.collapsed) {\n            ctx.shadowColor = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.DEFAULT_SHADOW_COLOR;\n          }\n\n          //* gradient test\n          if (this.use_gradients) {\n            var grad = LGraphCanvas.gradients[title_color];\n            if (!grad) {\n              grad = LGraphCanvas.gradients[title_color] = ctx.createLinearGradient(0, 0, 400, 0);\n              grad.addColorStop(0, title_color); // TODO refactor: validate color !! prevent DOMException\n              grad.addColorStop(1, \"#000\");\n            }\n            ctx.fillStyle = grad;\n          } else {\n            ctx.fillStyle = title_color;\n          }\n\n          // ctx.globalAlpha = 0.5 * old_alpha;\n          ctx.beginPath();\n          if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.BOX_SHAPE || low_quality) {\n            ctx.rect(0, -title_height, size[0] + 1, title_height);\n          } else if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ROUND_SHAPE || shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CARD_SHAPE) {\n            ctx.roundRect(0, -title_height, size[0] + 1, title_height, node.flags.collapsed ? [this.round_radius] : [this.round_radius, this.round_radius, 0, 0]);\n          }\n          ctx.fill();\n          ctx.shadowColor = \"transparent\";\n        }\n        var colState = false;\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.node_box_coloured_by_mode && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_MODES_COLORS[node.mode]) {\n          colState = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_MODES_COLORS[node.mode];\n        }\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.node_box_coloured_when_on) {\n          colState = node.action_triggered ? \"#FFF\" : node.execute_triggered ? \"#AAA\" : colState;\n        }\n\n        // title box\n        var box_size = 10;\n        if (node.onDrawTitleBox) {\n          node.onDrawTitleBox(ctx, title_height, size, this.ds.scale);\n        } else if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ROUND_SHAPE || shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CIRCLE_SHAPE || shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CARD_SHAPE) {\n          if (low_quality) {\n            ctx.fillStyle = \"black\";\n            ctx.beginPath();\n            ctx.arc(title_height * 0.5, title_height * -0.5, box_size * 0.5 + 1, 0, Math.PI * 2);\n            ctx.fill();\n          }\n          ctx.fillStyle = node.boxcolor || colState || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_DEFAULT_BOXCOLOR;\n          if (low_quality) ctx.fillRect(title_height * 0.5 - box_size * 0.5, title_height * -0.5 - box_size * 0.5, box_size, box_size);else {\n            ctx.beginPath();\n            ctx.arc(title_height * 0.5, title_height * -0.5, box_size * 0.5, 0, Math.PI * 2);\n            ctx.fill();\n          }\n        } else {\n          if (low_quality) {\n            ctx.fillStyle = \"black\";\n            ctx.fillRect((title_height - box_size) * 0.5 - 1, (title_height + box_size) * -0.5 - 1, box_size + 2, box_size + 2);\n          }\n          ctx.fillStyle = node.boxcolor || colState || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_DEFAULT_BOXCOLOR;\n          ctx.fillRect((title_height - box_size) * 0.5, (title_height + box_size) * -0.5, box_size, box_size);\n        }\n        ctx.globalAlpha = old_alpha;\n\n        // title text\n        if (node.onDrawTitleText) {\n          node.onDrawTitleText(ctx, title_height, size, this.ds.scale, this.title_text_font, selected);\n        }\n        if (!low_quality) {\n          ctx.font = this.title_text_font;\n          var title = String(node.getTitle());\n          if (title) {\n            if (selected) {\n              ctx.fillStyle = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_SELECTED_TITLE_COLOR;\n            } else {\n              ctx.fillStyle = node.constructor.title_text_color || this.node_title_color;\n            }\n            if (node.flags.collapsed) {\n              ctx.textAlign = \"left\";\n              ctx.fillText(title.substr(0, 20),\n              // avoid urls too long //@TODO: Replace with substring\n              title_height,\n              // + measure.width * 0.5,\n              _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_TEXT_Y - title_height);\n              ctx.textAlign = \"left\";\n            } else {\n              ctx.textAlign = \"left\";\n              ctx.fillText(title, title_height, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_TEXT_Y - title_height);\n            }\n          }\n        }\n\n        // subgraph box\n        if (!node.flags.collapsed && node.subgraph && !node.skip_subgraph_button) {\n          var w = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT;\n          var x = node.size[0] - w;\n          var over = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(this.graph_mouse[0] - node.pos[0], this.graph_mouse[1] - node.pos[1], x + 2, -w + 2, w - 4, w - 4);\n          ctx.fillStyle = over ? \"#888\" : \"#555\";\n          if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.BOX_SHAPE || low_quality) ctx.fillRect(x + 2, -w + 2, w - 4, w - 4);else {\n            ctx.beginPath();\n            ctx.roundRect(x + 2, -w + 2, w - 4, w - 4, [4]);\n            ctx.fill();\n          }\n          ctx.fillStyle = \"#333\";\n          ctx.beginPath();\n          ctx.moveTo(x + w * 0.2, -w * 0.6);\n          ctx.lineTo(x + w * 0.8, -w * 0.6);\n          ctx.lineTo(x + w * 0.5, -w * 0.3);\n          ctx.fill();\n        }\n\n        // custom title render\n        if (node.onDrawTitle) {\n          node.onDrawTitle(ctx);\n        }\n      }\n\n      // render selection marker\n      if (selected) {\n        if (node.onBounding) {\n          node.onBounding(area);\n        }\n        if (title_mode == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.TRANSPARENT_TITLE) {\n          area[1] -= title_height;\n          area[3] += title_height;\n        }\n        ctx.lineWidth = 1;\n        ctx.globalAlpha = 0.8;\n        ctx.beginPath();\n        if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.BOX_SHAPE) {\n          ctx.rect(-6 + area[0], -6 + area[1], 12 + area[2], 12 + area[3]);\n        } else if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ROUND_SHAPE || shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CARD_SHAPE && node.flags.collapsed) {\n          ctx.roundRect(-6 + area[0], -6 + area[1], 12 + area[2], 12 + area[3], [this.round_radius * 2]);\n        } else if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CARD_SHAPE) {\n          ctx.roundRect(-6 + area[0], -6 + area[1], 12 + area[2], 12 + area[3], [this.round_radius * 2, 2, this.round_radius * 2, 2]);\n        } else if (shape == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CIRCLE_SHAPE) {\n          ctx.arc(size[0] * 0.5, size[1] * 0.5, size[0] * 0.5 + 6, 0, Math.PI * 2);\n        }\n        ctx.strokeStyle = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_BOX_OUTLINE_COLOR;\n        ctx.stroke();\n        ctx.strokeStyle = fgcolor;\n        ctx.globalAlpha = 1;\n      }\n\n      // these counter helps in conditioning drawing based on if the node has been executed or an action occurred\n      if (node.execute_triggered > 0) node.execute_triggered--;\n      if (node.action_triggered > 0) node.action_triggered--;\n    }\n\n    /**\r\n     * draws every connection visible in the canvas\r\n     * OPTIMIZE THIS: pre-catch connections position instead of recomputing them every time\r\n     * @method drawConnections\r\n     **/\n  }, {\n    key: \"drawConnections\",\n    value: function drawConnections(ctx) {\n      var now = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getTime();\n      var visible_area = this.visible_area;\n      margin_area[0] = visible_area[0] - 20;\n      margin_area[1] = visible_area[1] - 20;\n      margin_area[2] = visible_area[2] + 40;\n      margin_area[3] = visible_area[3] + 40;\n\n      // draw connections\n      ctx.lineWidth = this.connections_width;\n      ctx.fillStyle = \"#AAA\";\n      ctx.strokeStyle = \"#AAA\";\n      ctx.globalAlpha = this.editor_alpha;\n      // for every node\n      var nodes = this.graph._nodes;\n      for (var n = 0, l = nodes.length; n < l; ++n) {\n        var node = nodes[n];\n        // for every input (we render just inputs because it is easier as every slot can only have one input)\n        if (!node.inputs || !node.inputs.length) {\n          continue;\n        }\n        for (var i = 0; i < node.inputs.length; ++i) {\n          var input = node.inputs[i];\n          if (!input || input.link == null) {\n            continue;\n          }\n          var link_id = input.link;\n          var link = this.graph.links[link_id];\n          if (!link) {\n            continue;\n          }\n\n          // find link info\n          var start_node = this.graph.getNodeById(link.origin_id);\n          if (start_node == null) {\n            continue;\n          }\n          var start_node_slot = link.origin_slot;\n          var start_node_slotpos = null;\n          if (start_node_slot == -1) {\n            start_node_slotpos = [start_node.pos[0] + 10, start_node.pos[1] + 10];\n          } else {\n            start_node_slotpos = start_node.getConnectionPos(false, start_node_slot, tempA);\n          }\n          var end_node_slotpos = node.getConnectionPos(true, i, tempB);\n\n          // compute link bounding\n          link_bounding[0] = start_node_slotpos[0];\n          link_bounding[1] = start_node_slotpos[1];\n          link_bounding[2] = end_node_slotpos[0] - start_node_slotpos[0];\n          link_bounding[3] = end_node_slotpos[1] - start_node_slotpos[1];\n          if (link_bounding[2] < 0) {\n            link_bounding[0] += link_bounding[2];\n            link_bounding[2] = Math.abs(link_bounding[2]);\n          }\n          if (link_bounding[3] < 0) {\n            link_bounding[1] += link_bounding[3];\n            link_bounding[3] = Math.abs(link_bounding[3]);\n          }\n\n          // skip links outside of the visible area of the canvas\n          if (!_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.overlapBounding(link_bounding, margin_area)) {\n            continue;\n          }\n          var start_slot = start_node.outputs[start_node_slot];\n          var end_slot = node.inputs[i];\n          if (!start_slot || !end_slot) {\n            continue;\n          }\n          var start_dir = start_slot.dir || (start_node.horizontal ? _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.DOWN : _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.RIGHT);\n          var end_dir = end_slot.dir || (node.horizontal ? _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.UP : _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LEFT);\n          this.renderLink(ctx, start_node_slotpos, end_node_slotpos, link, false, 0, null, start_dir, end_dir);\n\n          // event triggered rendered on top\n          if (link && link._last_time && now - link._last_time < 1000) {\n            var f = 2.0 - (now - link._last_time) * 0.002;\n            var tmp = ctx.globalAlpha;\n            ctx.globalAlpha = tmp * f;\n            this.renderLink(ctx, start_node_slotpos, end_node_slotpos, link, true, f, \"white\", start_dir, end_dir);\n            ctx.globalAlpha = tmp;\n          }\n        }\n      }\n      ctx.globalAlpha = 1;\n    }\n\n    /**\r\n     * draws a link between two points\r\n     * @method renderLink\r\n     * @param {vec2} a start pos\r\n     * @param {vec2} b end pos\r\n     * @param {Object} link the link object with all the link info\r\n     * @param {boolean} skip_border ignore the shadow of the link\r\n     * @param {boolean} flow show flow animation (for events)\r\n     * @param {string} color the color for the link\r\n     * @param {number} start_dir the direction enum\r\n     * @param {number} end_dir the direction enum\r\n     * @param {number} num_sublines number of sublines (useful to represent vec3 or rgb)\r\n     **/\n  }, {\n    key: \"renderLink\",\n    value: function renderLink(ctx, a, b, link, skip_border, flow, color, start_dir, end_dir, num_sublines) {\n      if (link) {\n        this.visible_links.push(link);\n      }\n\n      // choose color\n      if (!color && link) {\n        color = link.color || LGraphCanvas.link_type_colors[link.type];\n      }\n      if (!color) {\n        color = this.default_link_color;\n      }\n      if (link != null && this.highlighted_links[link.id]) {\n        color = \"#FFF\";\n      }\n      start_dir = start_dir || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.RIGHT;\n      end_dir = end_dir || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LEFT;\n      var dist = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.distance(a, b);\n      if (this.render_connections_border && this.ds.scale > 0.6) {\n        ctx.lineWidth = this.connections_width + 4;\n      }\n      ctx.lineJoin = \"round\";\n      num_sublines = num_sublines || 1;\n      if (num_sublines > 1) {\n        ctx.lineWidth = 0.5;\n      }\n\n      // begin line shape\n      ctx.beginPath();\n      for (var i = 0; i < num_sublines; i += 1) {\n        var offsety = (i - (num_sublines - 1) * 0.5) * 5;\n        if (this.links_render_mode == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.SPLINE_LINK) {\n          ctx.moveTo(a[0], a[1] + offsety);\n          var start_offset_x = 0;\n          var start_offset_y = 0;\n          var end_offset_x = 0;\n          var end_offset_y = 0;\n          switch (start_dir) {\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LEFT:\n              start_offset_x = dist * -0.25;\n              break;\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.RIGHT:\n              start_offset_x = dist * 0.25;\n              break;\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.UP:\n              start_offset_y = dist * -0.25;\n              break;\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.DOWN:\n              start_offset_y = dist * 0.25;\n              break;\n          }\n          switch (end_dir) {\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LEFT:\n              end_offset_x = dist * -0.25;\n              break;\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.RIGHT:\n              end_offset_x = dist * 0.25;\n              break;\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.UP:\n              end_offset_y = dist * -0.25;\n              break;\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.DOWN:\n              end_offset_y = dist * 0.25;\n              break;\n          }\n          ctx.bezierCurveTo(a[0] + start_offset_x, a[1] + start_offset_y + offsety, b[0] + end_offset_x, b[1] + end_offset_y + offsety, b[0], b[1] + offsety);\n        } else if (this.links_render_mode == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LINEAR_LINK) {\n          ctx.moveTo(a[0], a[1] + offsety);\n          var _start_offset_x = 0;\n          var _start_offset_y = 0;\n          var _end_offset_x = 0;\n          var _end_offset_y = 0;\n          switch (start_dir) {\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LEFT:\n              _start_offset_x = -1;\n              break;\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.RIGHT:\n              _start_offset_x = 1;\n              break;\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.UP:\n              _start_offset_y = -1;\n              break;\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.DOWN:\n              _start_offset_y = 1;\n              break;\n          }\n          switch (end_dir) {\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LEFT:\n              _end_offset_x = -1;\n              break;\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.RIGHT:\n              _end_offset_x = 1;\n              break;\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.UP:\n              _end_offset_y = -1;\n              break;\n            case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.DOWN:\n              _end_offset_y = 1;\n              break;\n          }\n          var l = 15;\n          ctx.lineTo(a[0] + _start_offset_x * l, a[1] + _start_offset_y * l + offsety);\n          ctx.lineTo(b[0] + _end_offset_x * l, b[1] + _end_offset_y * l + offsety);\n          ctx.lineTo(b[0], b[1] + offsety);\n        } else if (this.links_render_mode == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.STRAIGHT_LINK) {\n          ctx.moveTo(a[0], a[1]);\n          var start_x = a[0];\n          var start_y = a[1];\n          var end_x = b[0];\n          var end_y = b[1];\n          if (start_dir == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.RIGHT) {\n            start_x += 10;\n          } else {\n            start_y += 10;\n          }\n          if (end_dir == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LEFT) {\n            end_x -= 10;\n          } else {\n            end_y -= 10;\n          }\n          ctx.lineTo(start_x, start_y);\n          ctx.lineTo((start_x + end_x) * 0.5, start_y);\n          ctx.lineTo((start_x + end_x) * 0.5, end_y);\n          ctx.lineTo(end_x, end_y);\n          ctx.lineTo(b[0], b[1]);\n        } else {\n          return;\n        } // unknown\n      }\n\n      // rendering the outline of the connection can be a little bit slow\n      if (this.render_connections_border && this.ds.scale > 0.6 && !skip_border) {\n        ctx.strokeStyle = \"rgba(0,0,0,0.5)\";\n        ctx.stroke();\n      }\n      ctx.lineWidth = this.connections_width;\n      ctx.fillStyle = ctx.strokeStyle = color;\n      ctx.stroke();\n      // end line shape\n\n      var pos = this.computeConnectionPoint(a, b, 0.5, start_dir, end_dir);\n      if (link && link._pos) {\n        link._pos[0] = pos[0];\n        link._pos[1] = pos[1];\n      }\n\n      // render arrow in the middle\n      if (this.ds.scale >= 0.6 && this.highquality_render && end_dir != _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CENTER) {\n        // render arrow\n        if (this.render_connection_arrows) {\n          // compute two points in the connection\n          var posA = this.computeConnectionPoint(a, b, 0.25, start_dir, end_dir);\n          var posB = this.computeConnectionPoint(a, b, 0.26, start_dir, end_dir);\n          var posC = this.computeConnectionPoint(a, b, 0.75, start_dir, end_dir);\n          var posD = this.computeConnectionPoint(a, b, 0.76, start_dir, end_dir);\n\n          // compute the angle between them so the arrow points in the right direction\n          var angleA = 0;\n          var angleB = 0;\n          if (this.render_curved_connections) {\n            angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1]);\n            angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1]);\n          } else {\n            angleB = angleA = b[1] > a[1] ? 0 : Math.PI;\n          }\n\n          // render arrow\n          ctx.save();\n          ctx.translate(posA[0], posA[1]);\n          ctx.rotate(angleA);\n          ctx.beginPath();\n          ctx.moveTo(-5, -3);\n          ctx.lineTo(0, +7);\n          ctx.lineTo(+5, -3);\n          ctx.fill();\n          ctx.restore();\n          ctx.save();\n          ctx.translate(posC[0], posC[1]);\n          ctx.rotate(angleB);\n          ctx.beginPath();\n          ctx.moveTo(-5, -3);\n          ctx.lineTo(0, +7);\n          ctx.lineTo(+5, -3);\n          ctx.fill();\n          ctx.restore();\n        }\n\n        // circle\n        ctx.beginPath();\n        ctx.arc(pos[0], pos[1], 5, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      // render flowing points\n      if (flow) {\n        ctx.fillStyle = color;\n        for (var _i14 = 0; _i14 < 5; ++_i14) {\n          var f = (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getTime() * 0.001 + _i14 * 0.2) % 1;\n          pos = this.computeConnectionPoint(a, b, f, start_dir, end_dir);\n          ctx.beginPath();\n          ctx.arc(pos[0], pos[1], 5, 0, 2 * Math.PI);\n          ctx.fill();\n        }\n      }\n    }\n\n    // returns the link center point based on curvature\n  }, {\n    key: \"computeConnectionPoint\",\n    value: function computeConnectionPoint(a, b, t, start_dir, end_dir) {\n      start_dir = start_dir || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.RIGHT;\n      end_dir = end_dir || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LEFT;\n      var dist = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.distance(a, b);\n      var p0 = a;\n      var p1 = [a[0], a[1]];\n      var p2 = [b[0], b[1]];\n      var p3 = b;\n      switch (start_dir) {\n        case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LEFT:\n          p1[0] += dist * -0.25;\n          break;\n        case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.RIGHT:\n          p1[0] += dist * 0.25;\n          break;\n        case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.UP:\n          p1[1] += dist * -0.25;\n          break;\n        case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.DOWN:\n          p1[1] += dist * 0.25;\n          break;\n      }\n      switch (end_dir) {\n        case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LEFT:\n          p2[0] += dist * -0.25;\n          break;\n        case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.RIGHT:\n          p2[0] += dist * 0.25;\n          break;\n        case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.UP:\n          p2[1] += dist * -0.25;\n          break;\n        case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.DOWN:\n          p2[1] += dist * 0.25;\n          break;\n      }\n      var c1 = (1 - t) * (1 - t) * (1 - t);\n      var c2 = 3 * ((1 - t) * (1 - t)) * t;\n      var c3 = 3 * (1 - t) * (t * t);\n      var c4 = t * t * t;\n      var x = c1 * p0[0] + c2 * p1[0] + c3 * p2[0] + c4 * p3[0];\n      var y = c1 * p0[1] + c2 * p1[1] + c3 * p2[1] + c4 * p3[1];\n      return [x, y];\n    }\n  }, {\n    key: \"drawExecutionOrder\",\n    value: function drawExecutionOrder(ctx) {\n      ctx.shadowColor = \"transparent\";\n      ctx.globalAlpha = 0.25;\n      ctx.textAlign = \"center\";\n      ctx.strokeStyle = \"white\";\n      ctx.globalAlpha = 0.75;\n      var visible_nodes = this.visible_nodes;\n      for (var i = 0; i < visible_nodes.length; ++i) {\n        var node = visible_nodes[i];\n        ctx.fillStyle = \"black\";\n        ctx.fillRect(node.pos[0] - _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT, node.pos[1] - _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT);\n        if (node.order == 0) {\n          ctx.strokeRect(node.pos[0] - _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT + 0.5, node.pos[1] - _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT + 0.5, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT);\n        }\n        ctx.fillStyle = \"#FFF\";\n        ctx.fillText(node.order, node.pos[0] + _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT * -0.5, node.pos[1] - 6);\n      }\n      ctx.globalAlpha = 1;\n    }\n\n    /**\r\n     * draws the widgets stored inside a node\r\n     * @method drawNodeWidgets\r\n     **/\n  }, {\n    key: \"drawNodeWidgets\",\n    value: function drawNodeWidgets(node, posY, ctx, active_widget) {\n      if (!node.widgets || !node.widgets.length) {\n        return 0;\n      }\n      var width = node.size[0];\n      var widgets = node.widgets;\n      posY += 2;\n      var H = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_WIDGET_HEIGHT;\n      var show_text = !this.lowQualityRenderingRequired(0.5);\n      ctx.save();\n      ctx.globalAlpha = this.editor_alpha;\n      var outline_color = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.WIDGET_OUTLINE_COLOR;\n      var background_color = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.WIDGET_BGCOLOR;\n      var text_color = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.WIDGET_TEXT_COLOR;\n      var secondary_text_color = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.WIDGET_SECONDARY_TEXT_COLOR;\n      var margin = 15;\n      for (var i = 0; i < widgets.length; ++i) {\n        var w = widgets[i];\n        var y = posY;\n        if (w.y) {\n          y = w.y;\n        }\n        w.last_y = y;\n        ctx.strokeStyle = outline_color;\n        ctx.fillStyle = \"#222\";\n        ctx.textAlign = \"left\";\n        // ctx.lineWidth = 2;\n        if (w.disabled) ctx.globalAlpha *= 0.5;\n        var widget_width = w.width || width;\n        switch (w.type) {\n          case \"button\":\n            if (w.clicked) {\n              ctx.fillStyle = \"#AAA\";\n              w.clicked = false;\n              this.dirty_canvas = true;\n            }\n            ctx.fillRect(margin, y, widget_width - margin * 2, H);\n            if (show_text && !w.disabled) ctx.strokeRect(margin, y, widget_width - margin * 2, H);\n            if (show_text) {\n              ctx.textAlign = \"center\";\n              ctx.fillStyle = text_color;\n              ctx.fillText(w.label || w.name, widget_width * 0.5, y + H * 0.7);\n            }\n            break;\n          case \"toggle\":\n            ctx.textAlign = \"left\";\n            ctx.strokeStyle = outline_color;\n            ctx.fillStyle = background_color;\n            ctx.beginPath();\n            if (show_text) ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5]);else ctx.rect(margin, y, widget_width - margin * 2, H);\n            ctx.fill();\n            if (show_text && !w.disabled) ctx.stroke();\n            ctx.fillStyle = w.value ? \"#89A\" : \"#333\";\n            ctx.beginPath();\n            ctx.arc(widget_width - margin * 2, y + H * 0.5, H * 0.36, 0, Math.PI * 2);\n            ctx.fill();\n            if (show_text) {\n              ctx.fillStyle = secondary_text_color;\n              var label = w.label || w.name;\n              if (label != null) {\n                ctx.fillText(label, margin * 2, y + H * 0.7);\n              }\n              ctx.fillStyle = w.value ? text_color : secondary_text_color;\n              ctx.textAlign = \"right\";\n              ctx.fillText(w.value ? w.options.on || \"true\" : w.options.off || \"false\", widget_width - 40, y + H * 0.7);\n            }\n            break;\n          case \"slider\":\n            ctx.fillStyle = background_color;\n            ctx.fillRect(margin, y, widget_width - margin * 2, H);\n            var range = w.options.max - w.options.min;\n            var nvalue = (w.value - w.options.min) / range;\n            if (nvalue < 0.0) nvalue = 0.0;\n            if (nvalue > 1.0) nvalue = 1.0;\n            ctx.fillStyle = w.options.hasOwnProperty(\"slider_color\") ? w.options.slider_color : active_widget == w ? \"#89A\" : \"#678\";\n            ctx.fillRect(margin, y, nvalue * (widget_width - margin * 2), H);\n            if (show_text && !w.disabled) ctx.strokeRect(margin, y, widget_width - margin * 2, H);\n            if (w.marker) {\n              var marker_nvalue = (w.marker - w.options.min) / range;\n              if (marker_nvalue < 0.0) marker_nvalue = 0.0;\n              if (marker_nvalue > 1.0) marker_nvalue = 1.0;\n              ctx.fillStyle = w.options.hasOwnProperty(\"marker_color\") ? w.options.marker_color : \"#AA9\";\n              ctx.fillRect(margin + marker_nvalue * (widget_width - margin * 2), y, 2, H);\n            }\n            if (show_text) {\n              ctx.textAlign = \"center\";\n              ctx.fillStyle = text_color;\n              ctx.fillText(w.label || w.name + \"  \" + Number(w.value).toFixed(w.options.precision != null ? w.options.precision : 3), widget_width * 0.5, y + H * 0.7);\n            }\n            break;\n          case \"number\":\n          case \"combo\":\n            ctx.textAlign = \"left\";\n            ctx.strokeStyle = outline_color;\n            ctx.fillStyle = background_color;\n            ctx.beginPath();\n            if (show_text) ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5]);else ctx.rect(margin, y, widget_width - margin * 2, H);\n            ctx.fill();\n            if (show_text) {\n              if (!w.disabled) ctx.stroke();\n              ctx.fillStyle = text_color;\n              if (!w.disabled) {\n                ctx.beginPath();\n                ctx.moveTo(margin + 16, y + 5);\n                ctx.lineTo(margin + 6, y + H * 0.5);\n                ctx.lineTo(margin + 16, y + H - 5);\n                ctx.fill();\n                ctx.beginPath();\n                ctx.moveTo(widget_width - margin - 16, y + 5);\n                ctx.lineTo(widget_width - margin - 6, y + H * 0.5);\n                ctx.lineTo(widget_width - margin - 16, y + H - 5);\n                ctx.fill();\n              }\n              ctx.fillStyle = secondary_text_color;\n              ctx.fillText(w.label || w.name, margin * 2 + 5, y + H * 0.7);\n              ctx.fillStyle = text_color;\n              ctx.textAlign = \"right\";\n              if (w.type == \"number\") {\n                ctx.fillText(Number(w.value).toFixed(w.options.precision !== undefined ? w.options.precision : 3), widget_width - margin * 2 - 20, y + H * 0.7);\n              } else {\n                var v = w.value;\n                if (w.options.values) {\n                  var values = w.options.values;\n                  if (values.constructor === Function) values = values();\n                  if (values && values.constructor !== Array) v = values[w.value];\n                }\n                ctx.fillText(v, widget_width - margin * 2 - 20, y + H * 0.7);\n              }\n            }\n            break;\n          case \"string\":\n          case \"text\":\n            ctx.textAlign = \"left\";\n            ctx.strokeStyle = outline_color;\n            ctx.fillStyle = background_color;\n            ctx.beginPath();\n            if (show_text) ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5]);else ctx.rect(margin, y, widget_width - margin * 2, H);\n            ctx.fill();\n            if (show_text) {\n              if (!w.disabled) ctx.stroke();\n              ctx.save();\n              ctx.beginPath();\n              ctx.rect(margin, y, widget_width - margin * 2, H);\n              ctx.clip();\n\n              // ctx.stroke();\n              ctx.fillStyle = secondary_text_color;\n              var _label = w.label || w.name;\n              if (_label != null) {\n                ctx.fillText(_label, margin * 2, y + H * 0.7);\n              }\n              ctx.fillStyle = text_color;\n              ctx.textAlign = \"right\";\n              ctx.fillText(String(w.value).substr(0, 30), widget_width - margin * 2, y + H * 0.7); // 30 chars max\n              ctx.restore();\n            }\n            break;\n          default:\n            if (w.draw) {\n              w.draw(ctx, node, widget_width, y, H);\n            }\n            break;\n        }\n        posY += (w.computeSize ? w.computeSize(widget_width)[1] : H) + 4;\n        ctx.globalAlpha = this.editor_alpha;\n      }\n      ctx.restore();\n      ctx.textAlign = \"left\";\n    }\n\n    /**\r\n     * process an event on widgets\r\n     * @method processNodeWidgets\r\n     **/\n  }, {\n    key: \"processNodeWidgets\",\n    value: function processNodeWidgets(node, pos, event, active_widget) {\n      var _this7 = this;\n      if (!node.widgets || !node.widgets.length || !this.allow_interaction && !node.flags.allow_interaction) {\n        return null;\n      }\n      var x = pos[0] - node.pos[0];\n      var y = pos[1] - node.pos[1];\n      var width = node.size[0];\n      var deltaX = event.deltaX || event.deltax || 0;\n      var that = this;\n      var ref_window = this.getCanvasWindow();\n      var _loop = function _loop() {\n          w = node.widgets[i];\n          if (!w || w.disabled) return 0; // continue\n          widget_height = w.computeSize ? w.computeSize(width)[1] : _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_WIDGET_HEIGHT;\n          widget_width = w.width || width; // outside\n          if (w != active_widget && (x < 6 || x > widget_width - 12 || y < w.last_y || y > w.last_y + widget_height || w.last_y === undefined)) return 0; // continue\n          old_value = w.value; // if ( w == active_widget || (x > 6 && x < widget_width - 12 && y > w.last_y && y < w.last_y + widget_height) ) {\n          // inside widget\n          switch (w.type) {\n            case \"button\":\n              if (event.type === \"pointerdown\") {\n                if (w.callback) {\n                  setTimeout(function () {\n                    w.callback(w, that, node, pos, event);\n                  }, 20);\n                }\n                w.clicked = true;\n                _this7.dirty_canvas = true;\n              }\n              break;\n            case \"slider\":\n              nvalue = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.clamp((x - 15) / (widget_width - 30), 0, 1);\n              if (w.options.read_only) break;\n              w.value = w.options.min + (w.options.max - w.options.min) * nvalue;\n              if (old_value != w.value) {\n                setTimeout(function () {\n                  inner_value_change(w, w.value, old_value);\n                }, 20);\n              }\n              _this7.dirty_canvas = true;\n              break;\n            case \"number\":\n            case \"combo\":\n            case \"enum\":\n              if (event.type == \"pointermove\" && w.type == \"number\") {\n                if (deltaX) w.value += deltaX * 0.1 * (w.options.step || 1);\n                if (w.options.min != null && w.value < w.options.min) {\n                  w.value = w.options.min;\n                }\n                if (w.options.max != null && w.value > w.options.max) {\n                  w.value = w.options.max;\n                }\n              } else if (event.type == \"pointerdown\") {\n                values = w.options.values;\n                if (values && values.constructor === Function) {\n                  values = w.options.values(w, node);\n                }\n                values_list = null;\n                if (w.type != \"number\") values_list = values.constructor === Array ? values : Object.keys(values);\n                var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;\n                if (w.type == \"number\") {\n                  w.value += delta * 0.1 * (w.options.step || 1);\n                  if (w.options.min != null && w.value < w.options.min) {\n                    w.value = w.options.min;\n                  }\n                  if (w.options.max != null && w.value > w.options.max) {\n                    w.value = w.options.max;\n                  }\n                } else if (delta) {\n                  // clicked in arrow, used for combos\n                  index = -1;\n                  _this7.last_mouseclick = 0; // avoids double click event\n                  if (values.constructor === Object) index = values_list.indexOf(String(w.value)) + delta;else index = values_list.indexOf(w.value) + delta;\n                  if (index >= values_list.length) {\n                    index = values_list.length - 1;\n                  }\n                  if (index < 0) {\n                    index = 0;\n                  }\n                  if (values.constructor === Array) w.value = values[index];else w.value = index;\n                } else {\n                  // @TODO: Excise this, bound to w above\n                  var inner_clicked = function inner_clicked(v) {\n                    if (values != values_list) v = text_values.indexOf(v);\n                    this.value = v;\n                    inner_value_change(this, v, old_value);\n                    that.dirty_canvas = true;\n                    return false;\n                  };\n                  // combo clicked\n                  text_values = values != values_list ? Object.values(values) : values;\n                  new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu(text_values, {\n                    scale: Math.max(1, _this7.ds.scale),\n                    event: event,\n                    className: \"dark\",\n                    callback: inner_clicked.bind(w)\n                  }, ref_window);\n                }\n                // end mousedown\n              } else if (event.type == \"pointerup\" && w.type == \"number\") {\n                var _delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;\n                if (event.click_time < 200 && _delta == 0) {\n                  _this7.prompt(\"Value\", w.value, function (v) {\n                    // check if v is a valid equation or a number\n                    if (/^[0-9+\\-*/()\\s]+|\\d+\\.\\d+$/.test(v)) {\n                      try {\n                        // solve the equation if possible\n                        v = eval(v);\n                      } catch (error) {\n                        var _LiteGraph$warn7;\n                        (_LiteGraph$warn7 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn7 === void 0 || _LiteGraph$warn7.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, error);\n                      }\n                    }\n                    this.value = Number(v);\n                    inner_value_change(this, this.value, old_value);\n                  }.bind(w), event);\n                }\n              }\n              if (old_value != w.value) setTimeout(function () {\n                inner_value_change(this, this.value, old_value);\n              }.bind(w), 20);\n              _this7.dirty_canvas = true;\n              break;\n            case \"toggle\":\n              if (event.type == \"pointerdown\") {\n                w.value = !w.value;\n                setTimeout(function () {\n                  inner_value_change(w, w.value);\n                }, 20);\n              }\n              break;\n            case \"string\":\n            case \"text\":\n              if (event.type == \"pointerdown\") {\n                _this7.prompt(\"Value\", w.value, function (v) {\n                  // @TODO: this.value = v; // CHECK\n                  inner_value_change(this, v);\n                }.bind(w), event, w.options ? w.options.multiline : false);\n              }\n              break;\n            default:\n              if (w.mouse) {\n                _this7.dirty_canvas = w.mouse(event, [x, y], node);\n              }\n              break;\n          }\n          return {\n            v: w\n          };\n        },\n        w,\n        widget_height,\n        widget_width,\n        old_value,\n        nvalue,\n        values,\n        values_list,\n        index,\n        text_values,\n        _ret;\n      for (var i = 0; i < node.widgets.length; ++i) {\n        _ret = _loop();\n        if (_ret === 0) continue;\n        if (_ret) return _ret.v;\n      } // end for\n\n      function inner_value_change(widget, value, old_value) {\n        var _LiteGraph$debug4;\n        (_LiteGraph$debug4 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug4 === void 0 || _LiteGraph$debug4.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"inner_value_change for processNodeWidgets\", widget, value);\n        // value changed\n        if (old_value != w.value) {\n          if (node.onWidgetChanged) {\n            node.onWidgetChanged(w.name, w.value, old_value, w); // tag: event entrypoint\n          }\n          // node.graph._version++;\n          node.graph.onGraphChanged({\n            action: \"widgetChanged\",\n            doSave: true\n          }); // tag: graph event entrypoint\n        }\n        if (widget.type == \"number\") {\n          value = Number(value);\n        }\n        widget.value = value;\n        if (widget.options && widget.options.property && node.properties[widget.options.property] !== undefined) {\n          node.setProperty(widget.options.property, value);\n        }\n        if (widget.callback) {\n          widget.callback(widget.value, that, node, pos, event);\n        }\n      }\n      return null;\n    }\n\n    /**\r\n     * draws every group area in the background\r\n     * @method drawGroups\r\n     **/\n  }, {\n    key: \"drawGroups\",\n    value: function drawGroups(canvas, ctx) {\n      if (!this.graph) {\n        return;\n      }\n      var groups = this.graph._groups;\n      ctx.save();\n      ctx.globalAlpha = 0.5 * this.editor_alpha;\n      for (var i = 0; i < groups.length; ++i) {\n        var group = groups[i];\n        if (!_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.overlapBounding(this.visible_area, group._bounding)) {\n          continue;\n        } // out of the visible area\n\n        ctx.fillStyle = group.color || \"#335\";\n        ctx.strokeStyle = group.color || \"#335\";\n        var pos = group._pos;\n        var size = group._size;\n        ctx.globalAlpha = 0.25 * this.editor_alpha;\n        ctx.beginPath();\n        ctx.rect(pos[0] + 0.5, pos[1] + 0.5, size[0], size[1]);\n        ctx.fill();\n        ctx.globalAlpha = this.editor_alpha;\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(pos[0] + size[0], pos[1] + size[1]);\n        ctx.lineTo(pos[0] + size[0] - 10, pos[1] + size[1]);\n        ctx.lineTo(pos[0] + size[0], pos[1] + size[1] - 10);\n        ctx.fill();\n        var font_size = group.font_size || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.DEFAULT_GROUP_FONT_SIZE;\n        ctx.font = font_size + \"px Arial\";\n        ctx.textAlign = \"left\";\n        ctx.fillText(group.title, pos[0] + 4, pos[1] + font_size);\n      }\n      ctx.restore();\n    }\n  }, {\n    key: \"adjustNodesSize\",\n    value: function adjustNodesSize() {\n      var nodes = this.graph._nodes;\n      for (var i = 0; i < nodes.length; ++i) {\n        nodes[i].size = nodes[i].computeSize();\n      }\n      this.setDirty(true, true);\n    }\n\n    /**\r\n     * resizes the canvas to a given size, if no size is passed, then it tries to fill the parentNode\r\n     * @method resize\r\n     **/\n  }, {\n    key: \"resize\",\n    value: function resize(width, height) {\n      if (!width && !height) {\n        var parent = this.canvas.parentNode;\n        width = parent.offsetWidth;\n        height = parent.offsetHeight;\n      }\n      if (this.canvas.width == width && this.canvas.height == height) {\n        return;\n      }\n      this.canvas.width = width;\n      this.canvas.height = height;\n      this.bgcanvas.width = this.canvas.width;\n      this.bgcanvas.height = this.canvas.height;\n      this.setDirty(true, true);\n    }\n\n    /**\r\n     * switches to live mode (node shapes are not rendered, only the content)\r\n     * this feature was designed when graphs where meant to create user interfaces\r\n     * @method switchLiveMode\r\n     **/\n  }, {\n    key: \"switchLiveMode\",\n    value: function switchLiveMode(transition) {\n      if (!transition) {\n        this.live_mode = !this.live_mode;\n        this.dirty_canvas = true;\n        this.dirty_bgcanvas = true;\n        return;\n      }\n      var self = this;\n      var delta = this.live_mode ? 1.1 : 0.9;\n      if (this.live_mode) {\n        this.live_mode = false;\n        this.editor_alpha = 0.1;\n      }\n      var t = setInterval(function () {\n        self.editor_alpha *= delta;\n        self.dirty_canvas = true;\n        self.dirty_bgcanvas = true;\n        if (delta < 1 && self.editor_alpha < 0.01) {\n          clearInterval(t);\n          if (delta < 1) {\n            self.live_mode = true;\n          }\n        }\n        if (delta > 1 && self.editor_alpha > 0.99) {\n          clearInterval(t);\n          self.editor_alpha = 1;\n        }\n      }, 1);\n    }\n\n    /* @TODO: Validate this is never called\r\n    onNodeSelectionChange() {\r\n        return; // disabled\r\n    }\r\n    */\n\n    /* this is an implementation for touch not in production and not ready\r\n        */\n    /* LGraphCanvas.prototype.touchHandler = function(event) {\r\n        //alert(\"foo\");\r\n        var touches = event.changedTouches,\r\n            first = touches[0],\r\n            type = \"\";\r\n          switch (event.type) {\r\n            case \"touchstart\":\r\n                type = \"pointerdown\";\r\n                break;\r\n            case \"touchmove\":\r\n                type = \"pointermove\";\r\n                break;\r\n            case \"touchend\":\r\n                type = \"pointerup\";\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n          //initMouseEvent(type, canBubble, cancelable, view, clickCount,\r\n        //           screenX, screenY, clientX, clientY, ctrlKey,\r\n        //           altKey, shiftKey, metaKey, button, relatedTarget);\r\n          // this is eventually a Dom object, get the LGraphCanvas back\r\n        if(typeof this.getCanvasWindow == \"undefined\"){\r\n            var window = this.lgraphcanvas.getCanvasWindow();\r\n        }else{\r\n            var window = this.getCanvasWindow();\r\n        }\r\n          var document = window.document;\r\n          var simulatedEvent = document.createEvent(\"MouseEvent\");\r\n        simulatedEvent.initMouseEvent(\r\n            type,\r\n            true,\r\n            true,\r\n            window,\r\n            1,\r\n            first.screenX,\r\n            first.screenY,\r\n            first.clientX,\r\n            first.clientY,\r\n            false,\r\n            false,\r\n            false,\r\n            false,\r\n            0, //left\r\n            null\r\n        );\r\n        first.target.dispatchEvent(simulatedEvent);\r\n        event.preventDefault();\r\n    };*/\n\n    /* CONTEXT MENU ********************/\n  }, {\n    key: \"boundaryNodesForSelection\",\n    value:\n    /**\r\n     * Determines the furthest nodes in each direction for the currently selected nodes\r\n     * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}\r\n     */\n    function boundaryNodesForSelection() {\n      return LGraphCanvas.getBoundaryNodes(Object.values(this.selected_nodes));\n    }\n\n    /**\r\n     *\r\n     * @param {LGraphNode[]} nodes a list of nodes\r\n     * @param {\"top\"|\"bottom\"|\"left\"|\"right\"} direction Direction to align the nodes\r\n     * @param {LGraphNode?} align_to Node to align to (if null, align to the furthest node in the given direction)\r\n     */\n  }, {\n    key: \"showLinkMenu\",\n    value: function showLinkMenu(link, e) {\n      var that = this;\n      // LiteGraph.log?.(link);\n      var node_left = that.graph.getNodeById(link.origin_id);\n      var node_right = that.graph.getNodeById(link.target_id);\n      var fromType = false;\n      if (node_left && node_left.outputs && node_left.outputs[link.origin_slot]) fromType = node_left.outputs[link.origin_slot].type;\n      var destType = false;\n      if (node_right && node_right.outputs && node_right.outputs[link.target_slot]) destType = node_right.inputs[link.target_slot].type;\n\n      // @TODO: See if deleting this is a bug:\n      // var options = [\"Add Node\",null,\"Delete\",null];\n\n      var menu = new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu(options, {\n        event: e,\n        title: link.data != null ? link.data.constructor.name : null,\n        callback: inner_clicked\n      });\n      function inner_clicked(v, options, e) {\n        switch (v) {\n          case \"Add Node\":\n            LGraphCanvas.onMenuAdd(null, null, e, menu, function (node) {\n              var _LiteGraph$debug5;\n              (_LiteGraph$debug5 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug5 === void 0 || _LiteGraph$debug5.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"node autoconnect\");\n              if (!node.inputs || !node.inputs.length || !node.outputs || !node.outputs.length) {\n                return;\n              }\n              // leave the connection type checking inside connectByType\n              if (node_left.connectByType(link.origin_slot, node, fromType)) {\n                node.connectByType(link.target_slot, node_right, destType);\n                node.pos[0] -= node.size[0] * 0.5;\n              }\n            });\n            break;\n          case \"Delete\":\n            that.graph.removeLink(link.id);\n            break;\n          default:\n          /* var nodeCreated = createDefaultNodeForSlot({   nodeFrom: node_left\r\n                                                          ,slotFrom: link.origin_slot\r\n                                                          ,nodeTo: node\r\n                                                          ,slotTo: link.target_slot\r\n                                                          ,e: e\r\n                                                          ,nodeType: \"AUTO\"\r\n                                                      });\r\n          if(nodeCreated) LiteGraph.log?.(\"new node in beetween \"+v+\" created\");*/\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"createDefaultNodeForSlot\",\n    value: function createDefaultNodeForSlot() {\n      var _LiteGraph$warn10;\n      var optPass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // addNodeMenu for connection\n      var opts = Object.assign({\n        nodeFrom: null,\n        // input\n        slotFrom: null,\n        // input\n        nodeTo: null,\n        // output\n        slotTo: null,\n        // output\n        position: [],\n        // pass the event coords\n        nodeType: null,\n        // choose a nodetype to add, AUTO to set at first good\n        posAdd: [0, 0],\n        // adjust x,y\n        posSizeFix: [0, 0] // alpha, adjust the position x,y based on the new node size w,h\n      }, optPass);\n      var that = this;\n      var isFrom = opts.nodeFrom && opts.slotFrom !== null;\n      var isTo = !isFrom && opts.nodeTo && opts.slotTo !== null;\n      if (!isFrom && !isTo) {\n        var _LiteGraph$warn8;\n        (_LiteGraph$warn8 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn8 === void 0 || _LiteGraph$warn8.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"No data passed to createDefaultNodeForSlot \" + opts.nodeFrom + \" \" + opts.slotFrom + \" \" + opts.nodeTo + \" \" + opts.slotTo);\n        return false;\n      }\n      if (!opts.nodeType) {\n        var _LiteGraph$warn9;\n        (_LiteGraph$warn9 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn9 === void 0 || _LiteGraph$warn9.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"No type to createDefaultNodeForSlot\");\n        return false;\n      }\n      var nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;\n      var slotX = isFrom ? opts.slotFrom : opts.slotTo;\n      var iSlotConn = false;\n      switch (_typeof(slotX)) {\n        case \"string\":\n          iSlotConn = isFrom ? nodeX.findOutputSlot(slotX, false) : nodeX.findInputSlot(slotX, false);\n          slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];\n          break;\n        case \"object\":\n          // ok slotX\n          iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);\n          break;\n        case \"number\":\n          iSlotConn = slotX;\n          slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];\n          break;\n        default:\n          // bad ?\n          // iSlotConn = 0;\n          (_LiteGraph$warn10 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn10 === void 0 || _LiteGraph$warn10.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Cant get slot information \" + slotX);\n          return false;\n      }\n      if (slotX === false || iSlotConn === false) {\n        var _LiteGraph$warn11;\n        (_LiteGraph$warn11 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn11 === void 0 || _LiteGraph$warn11.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"createDefaultNodeForSlot bad slotX \" + slotX + \" \" + iSlotConn);\n      }\n\n      // check for defaults nodes for this slottype\n      var fromSlotType = slotX.type == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT ? \"_event_\" : slotX.type;\n      var slotTypesDefault = isFrom ? _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.slot_types_default_out : _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.slot_types_default_in;\n      if (slotTypesDefault && slotTypesDefault[fromSlotType]) {\n        if (slotX.link !== null) {\n          // is connected\n        } else {\n          // is not not connected\n        }\n        var nodeNewType = false;\n        if (_typeof(slotTypesDefault[fromSlotType]) == \"object\") {\n          for (var typeX in slotTypesDefault[fromSlotType]) {\n            if (opts.nodeType == slotTypesDefault[fromSlotType][typeX] || opts.nodeType == \"AUTO\") {\n              nodeNewType = slotTypesDefault[fromSlotType][typeX];\n              // LiteGraph.log?.(\"opts.nodeType == slotTypesDefault[fromSlotType][typeX] :: \"+opts.nodeType);\n              break; // --------\n            }\n          }\n        } else {\n          if (opts.nodeType == slotTypesDefault[fromSlotType] || opts.nodeType == \"AUTO\") nodeNewType = slotTypesDefault[fromSlotType];\n        }\n        if (nodeNewType) {\n          var nodeNewOpts = false;\n          if (_typeof(nodeNewType) == \"object\" && nodeNewType.node) {\n            nodeNewOpts = nodeNewType;\n            nodeNewType = nodeNewType.node;\n          }\n\n          // that.graph.beforeChange();\n\n          var newNode = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.createNode(nodeNewType);\n          if (newNode) {\n            // if is object pass options\n            if (nodeNewOpts) {\n              if (nodeNewOpts.properties) {\n                for (var _i15 = 0, _Object$entries = Object.entries(nodeNewOpts.properties); _i15 < _Object$entries.length; _i15++) {\n                  var _Object$entries$_i = _slicedToArray(_Object$entries[_i15], 2),\n                    key = _Object$entries$_i[0],\n                    value = _Object$entries$_i[1];\n                  newNode.addProperty(key, value);\n                }\n              }\n              if (nodeNewOpts.inputs) {\n                newNode.inputs = [];\n                Object.values(nodeNewOpts.inputs).forEach(function (value) {\n                  newNode.addOutput(value[0], value[1]);\n                });\n              }\n              if (nodeNewOpts.outputs) {\n                newNode.outputs = [];\n                Object.values(nodeNewOpts.outputs).forEach(function (value) {\n                  newNode.addOutput(value[0], value[1]);\n                });\n              }\n              if (nodeNewOpts.title) {\n                newNode.title = nodeNewOpts.title;\n              }\n              if (nodeNewOpts.json) {\n                newNode.configure(nodeNewOpts.json);\n              }\n            }\n\n            // add the node\n            that.graph.add(newNode);\n            newNode.pos = [opts.position[0] + opts.posAdd[0] + (opts.posSizeFix[0] ? opts.posSizeFix[0] * newNode.size[0] : 0), opts.position[1] + opts.posAdd[1] + (opts.posSizeFix[1] ? opts.posSizeFix[1] * newNode.size[1] : 0)]; // that.last_click_position; //[e.canvasX+30, e.canvasX+5];*/\n\n            // that.graph.afterChange();\n\n            // connect the two!\n            if (isFrom) {\n              opts.nodeFrom.connectByType(iSlotConn, newNode, fromSlotType);\n            } else {\n              opts.nodeTo.connectByTypeOutput(iSlotConn, newNode, fromSlotType);\n            }\n\n            /* if connecting in between\r\n            if (isFrom && isTo){\r\n                //@TODO\r\n            }\r\n            */\n\n            return true;\n          } else {\n            var _LiteGraph$warn12;\n            (_LiteGraph$warn12 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn12 === void 0 || _LiteGraph$warn12.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"failed creating \" + nodeNewType);\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"showConnectionMenu\",\n    value: function showConnectionMenu() {\n      var _LiteGraph$warn14;\n      var optPass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // addNodeMenu for connection\n\n      var opts = Object.assign({\n        nodeFrom: null,\n        // input\n        slotFrom: null,\n        // input\n        nodeTo: null,\n        // output\n        slotTo: null,\n        // output\n        e: null\n      }, optPass);\n      var that = this;\n      var isFrom = opts.nodeFrom && opts.slotFrom;\n      var isTo = !isFrom && opts.nodeTo && opts.slotTo;\n      if (!isFrom && !isTo) {\n        var _LiteGraph$warn13;\n        (_LiteGraph$warn13 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn13 === void 0 || _LiteGraph$warn13.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"No data passed to showConnectionMenu\");\n        return false;\n      }\n      var nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;\n      var slotX = isFrom ? opts.slotFrom : opts.slotTo;\n      var iSlotConn = false;\n      switch (_typeof(slotX)) {\n        case \"string\":\n          iSlotConn = isFrom ? nodeX.findOutputSlot(slotX, false) : nodeX.findInputSlot(slotX, false);\n          slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];\n          break;\n        case \"object\":\n          // ok slotX\n          iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);\n          break;\n        case \"number\":\n          iSlotConn = slotX;\n          slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];\n          break;\n        default:\n          // bad ?\n          // iSlotConn = 0;\n          (_LiteGraph$warn14 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn14 === void 0 || _LiteGraph$warn14.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Cant get slot information \" + slotX);\n          return false;\n      }\n      var options = [\"Add Node\", null];\n      if (that.allow_searchbox) {\n        options.push(\"Search\");\n        options.push(null);\n      }\n\n      // get defaults nodes for this slottype\n      var fromSlotType = slotX.type === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT ? \"_event_\" : slotX.type;\n      var slotTypesDefault = isFrom ? _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.slot_types_default_out : _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.slot_types_default_in;\n      if (slotTypesDefault && slotTypesDefault[fromSlotType]) {\n        var slotType = slotTypesDefault[fromSlotType];\n        if (Array.isArray(slotType) || _typeof(slotType) === \"object\") {\n          Object.values(slotType).forEach(function (typeX) {\n            options.push(typeX);\n          });\n        } else {\n          options.push(slotType);\n        }\n      }\n\n      // build menu\n      var menu = new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu(options, {\n        event: opts.e,\n        title: (slotX && slotX.name != \"\" ? slotX.name + (fromSlotType ? \" | \" : \"\") : \"\") + (slotX && fromSlotType ? fromSlotType : \"\"),\n        callback: function callback(v, options, e) {\n          var cases = {\n            \"Add Node\": function AddNode() {\n              LGraphCanvas.onMenuAdd(null, null, e, menu, function (node) {\n                isFrom ? opts.nodeFrom.connectByType(iSlotConn, node, fromSlotType) : opts.nodeTo.connectByTypeOutput(iSlotConn, node, fromSlotType);\n              });\n            },\n            \"Search\": function Search() {\n              isFrom ? that.showSearchBox(e, {\n                node_from: opts.nodeFrom,\n                slot_from: slotX,\n                type_filter_in: fromSlotType\n              }) : that.showSearchBox(e, {\n                node_to: opts.nodeTo,\n                slot_from: slotX,\n                type_filter_out: fromSlotType\n              });\n            },\n            \"default\": function _default() {\n              that.createDefaultNodeForSlot(Object.assign(opts, {\n                position: [opts.e.canvasX, opts.e.canvasY],\n                nodeType: v\n              }));\n            }\n          };\n\n          // Execute the corresponding function based on the value of v\n          (cases[v] || cases[\"default\"])();\n        }\n      });\n      return false;\n    }\n\n    // TODO refactor :: this is used fot title but not for properties!\n  }, {\n    key: \"prompt\",\n    value:\n    // refactor: there are different dialogs, some uses createDialog some dont\n    // prompt v2\n    function prompt() {\n      var _this8 = this,\n        _this$prompt_box;\n      var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var value = arguments.length > 1 ? arguments[1] : undefined;\n      var callback = arguments.length > 2 ? arguments[2] : undefined;\n      var event = arguments.length > 3 ? arguments[3] : undefined;\n      var multiline = arguments.length > 4 ? arguments[4] : undefined;\n      var dialog = document.createElement(\"div\");\n      dialog.is_modified = false;\n      dialog.className = \"graphdialog rounded\";\n      if (multiline) dialog.innerHTML = \"<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>\";else dialog.innerHTML = \"<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>\";\n      dialog.close = function () {\n        var _dialog$parentNode;\n        _this8.prompt_box = null;\n        (_dialog$parentNode = dialog.parentNode) === null || _dialog$parentNode === void 0 || _dialog$parentNode.removeChild(dialog);\n      };\n      var graphcanvas = LGraphCanvas.active_canvas;\n      var canvas = graphcanvas.canvas;\n      canvas.parentNode.appendChild(dialog);\n      if (this.ds.scale > 1) {\n        dialog.style.transform = \"scale(\".concat(this.ds.scale, \")\");\n      }\n      var dialogCloseTimer = null;\n      var prevent_timeout = false;\n      dialog.addEventListener(\"pointerleave\", function (_event) {\n        if (prevent_timeout) return;\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.dialog_close_on_mouse_leave && !dialog.is_modified && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.dialog_close_on_mouse_leave) {\n          dialogCloseTimer = setTimeout(dialog.close, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.dialog_close_on_mouse_leave_delay);\n        }\n      });\n      dialog.addEventListener(\"pointerenter\", function (_event) {\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.dialog_close_on_mouse_leave && dialogCloseTimer) {\n          clearTimeout(dialogCloseTimer);\n        }\n      });\n      var selInDia = dialog.querySelectorAll(\"select\");\n      if (selInDia) {\n        // @BUG: prevent_timeout is never used.  This is literally thrashing just to keep some timeout from happening!\n        var _prevent_timeout = 0;\n        selInDia.forEach(function (selIn) {\n          selIn.addEventListener(\"click\", function (_event) {\n            _prevent_timeout++;\n          });\n          selIn.addEventListener(\"blur\", function (_event) {\n            _prevent_timeout = 0;\n          });\n          selIn.addEventListener(\"change\", function (_event) {\n            _prevent_timeout = -1;\n          });\n        });\n      }\n      (_this$prompt_box = this.prompt_box) === null || _this$prompt_box === void 0 || _this$prompt_box.close();\n      this.prompt_box = dialog;\n      var name_element = dialog.querySelector(\".name\");\n      name_element.innerText = title;\n      var value_element = dialog.querySelector(\".value\");\n      value_element.value = value;\n      var input = value_element;\n      input.addEventListener(\"keydown\", function (e) {\n        var _LiteGraph$debug6;\n        dialog.is_modified = true;\n        switch (e.keyCode) {\n          case 27:\n            // ESC key\n            dialog.close();\n            break;\n          case 13:\n            // Enter key\n            if (e.target.localName !== \"textarea\" && typeof callback == \"function\") {\n              callback(input.value);\n              _this8.setDirty(true); // CHECK should probably call graphChanged instead\n            }\n            (_LiteGraph$debug6 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug6 === void 0 || _LiteGraph$debug6.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"prompt v2 ENTER\", input.value, e.target.localName, callback);\n            dialog.close();\n            break;\n          default:\n            return;\n          // Ignore other key codes\n        }\n        e.preventDefault();\n        e.stopPropagation();\n      });\n      var button = dialog.querySelector(\"button\");\n      button.addEventListener(\"click\", function (_event) {\n        var _LiteGraph$debug7;\n        if (typeof callback == \"function\") {\n          callback(input.value);\n          _this8.setDirty(true); // CHECK should probably call graphChanged instead\n        }\n        (_LiteGraph$debug7 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug7 === void 0 || _LiteGraph$debug7.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"prompt v2 OK\", input.value, callback);\n        dialog.close();\n      });\n      var rect = canvas.getBoundingClientRect();\n      var offsetx = -20;\n      var offsety = -20;\n      if (rect) {\n        offsetx -= rect.left;\n        offsety -= rect.top;\n      }\n      if (event) {\n        dialog.style.left = event.clientX + offsetx + \"px\";\n        dialog.style.top = event.clientY + offsety + \"px\";\n      } else {\n        dialog.style.left = canvas.width * 0.5 + offsetx + \"px\";\n        dialog.style.top = canvas.height * 0.5 + offsety + \"px\";\n      }\n      setTimeout(function () {\n        input.focus();\n      }, 10);\n      return dialog;\n    }\n  }, {\n    key: \"showSearchBox\",\n    value: function showSearchBox(event, options) {\n      // proposed defaults\n      var def_options = {\n        slot_from: null,\n        node_from: null,\n        node_to: null,\n        do_type_filter: _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.search_filter_enabled,\n        // TODO check for registered_slot_[in/out]_types not empty // this will be checked for functionality enabled : filter on slot type, in and out\n        type_filter_in: false,\n        // these are default: pass to set initially set values\n        type_filter_out: false,\n        show_general_if_none_on_typefilter: true,\n        show_general_after_typefiltered: true,\n        hide_on_mouse_leave: _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.search_hide_on_mouse_leave,\n        show_all_if_empty: true,\n        show_all_on_open: _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.search_show_all_on_open\n      };\n      options = Object.assign(def_options, options || {});\n\n      // LiteGraph.log?.(options);\n\n      var that = this;\n      var graphcanvas = LGraphCanvas.active_canvas;\n      var canvas = graphcanvas.canvas;\n      var root_document = canvas.ownerDocument || document;\n      var dialog = document.createElement(\"div\");\n      dialog.className = \"litegraph litesearchbox graphdialog rounded\";\n      dialog.innerHTML = \"<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/>\";\n      if (options.do_type_filter) {\n        dialog.innerHTML += \"<select class='slot_in_type_filter'><option value=''></option></select>\";\n        dialog.innerHTML += \"<select class='slot_out_type_filter'><option value=''></option></select>\";\n      }\n      if (options.show_close_button) {\n        dialog.innerHTML += \"<button class='close_searchbox close'>X</button>\";\n      }\n      dialog.innerHTML += \"<div class='helper'></div>\";\n      if (root_document.fullscreenElement) root_document.fullscreenElement.appendChild(dialog);else {\n        root_document.body.appendChild(dialog);\n        root_document.body.style.overflow = \"hidden\";\n      }\n      // dialog element has been appended\n\n      if (options.do_type_filter) {\n        var selIn = dialog.querySelector(\".slot_in_type_filter\");\n        var selOut = dialog.querySelector(\".slot_out_type_filter\");\n      }\n      dialog.close = function () {\n        that.search_box = null;\n        this.blur();\n        canvas.focus();\n        root_document.body.style.overflow = \"\";\n        setTimeout(function () {\n          that.canvas.focus();\n        }, 20); // important, if canvas loses focus keys wont be captured\n        if (dialog.parentNode) {\n          dialog.parentNode.removeChild(dialog);\n        }\n      };\n      if (this.ds.scale > 1) {\n        dialog.style.transform = \"scale(\".concat(this.ds.scale, \")\");\n      }\n\n      // hide on mouse leave\n      if (options.hide_on_mouse_leave) {\n        var prevent_timeout = false;\n        var timeout_close = null;\n        dialog.addEventListener(\"pointerenter\", function (_event) {\n          if (timeout_close) {\n            clearTimeout(timeout_close);\n            timeout_close = null;\n          }\n        });\n        dialog.addEventListener(\"pointerleave\", function (_event) {\n          if (prevent_timeout) {\n            return;\n          }\n          timeout_close = setTimeout(function () {\n            dialog.close();\n          }, 500);\n        });\n        // if filtering, check focus changed to comboboxes and prevent closing\n        if (options.do_type_filter) {\n          selIn.addEventListener(\"click\", function (_event) {\n            prevent_timeout++;\n          });\n          selIn.addEventListener(\"blur\", function (_event) {\n            prevent_timeout = 0;\n          });\n          selIn.addEventListener(\"change\", function (_event) {\n            prevent_timeout = -1;\n          });\n          selOut.addEventListener(\"click\", function (_event) {\n            prevent_timeout++;\n          });\n          selOut.addEventListener(\"blur\", function (_event) {\n            prevent_timeout = 0;\n          });\n          selOut.addEventListener(\"change\", function (_event) {\n            prevent_timeout = -1;\n          });\n        }\n      }\n      if (that.search_box) {\n        that.search_box.close();\n      }\n      that.search_box = dialog;\n      var helper = dialog.querySelector(\".helper\");\n      var first = null;\n      var timeout = null;\n      var selected = null;\n      var input = dialog.querySelector(\"input\");\n      if (input) {\n        input.addEventListener(\"blur\", function (_event) {\n          if (that.search_box) this.focus();\n        });\n        input.addEventListener(\"keydown\", function (e) {\n          if (e.keyCode == 38) {\n            // @TODO: deprecated\n            // UP\n            changeSelection(false);\n          } else if (e.keyCode == 40) {\n            // DOWN\n            changeSelection(true);\n          } else if (e.keyCode == 27) {\n            // ESC\n            dialog.close();\n          } else if (e.keyCode == 13) {\n            refreshHelper();\n            if (selected) {\n              select(selected.innerHTML);\n            } else if (first) {\n              select(first);\n            } else {\n              dialog.close();\n            }\n          } else {\n            if (timeout) {\n              clearInterval(timeout);\n            }\n            timeout = setTimeout(refreshHelper, 250);\n            return;\n          }\n          e.preventDefault();\n          e.stopPropagation();\n          e.stopImmediatePropagation();\n          return true;\n        });\n      }\n\n      // if should filter on type, load and fill selected and choose elements if passed\n      if (options.do_type_filter) {\n        if (selIn) {\n          var aSlots = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.slot_types_in;\n          var nSlots = aSlots.length; // this for object :: Object.keys(aSlots).length;\n\n          if (options.type_filter_in == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT || options.type_filter_in == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION) options.type_filter_in = \"_event_\";\n          /* this will filter on * .. but better do it manually in case\r\n          else if(options.type_filter_in === \"\" || options.type_filter_in === 0)\r\n              options.type_filter_in = \"*\";*/\n\n          for (var iK = 0; iK < nSlots; iK++) {\n            var opt = document.createElement('option');\n            opt.value = aSlots[iK];\n            opt.innerHTML = aSlots[iK];\n            selIn.appendChild(opt);\n            if (options.type_filter_in !== false && (options.type_filter_in + \"\").toLowerCase() == (aSlots[iK] + \"\").toLowerCase()) {\n              // selIn.selectedIndex ..\n              opt.selected = true;\n              // LiteGraph.log?.(\"comparing IN \"+options.type_filter_in+\" :: \"+aSlots[iK]);\n            } else {\n              // LiteGraph.log?.(\"comparing OUT \"+options.type_filter_in+\" :: \"+aSlots[iK]);\n            }\n          }\n          selIn.addEventListener(\"change\", function () {\n            refreshHelper();\n          });\n        }\n        if (selOut) {\n          var _aSlots = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.slot_types_out;\n          var _nSlots = _aSlots.length; // this for object :: Object.keys(aSlots).length;\n\n          if (options.type_filter_out == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT || options.type_filter_out == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION) options.type_filter_out = \"_event_\";\n          /* this will filter on * .. but better do it manually in case\r\n          else if(options.type_filter_out === \"\" || options.type_filter_out === 0)\r\n              options.type_filter_out = \"*\";*/\n\n          for (var _iK = 0; _iK < _nSlots; _iK++) {\n            var _opt = document.createElement('option');\n            _opt.value = _aSlots[_iK];\n            _opt.innerHTML = _aSlots[_iK];\n            selOut.appendChild(_opt);\n            if (options.type_filter_out !== false && (options.type_filter_out + \"\").toLowerCase() == (_aSlots[_iK] + \"\").toLowerCase()) {\n              // selOut.selectedIndex ..\n              _opt.selected = true;\n            }\n          }\n          selOut.addEventListener(\"change\", function () {\n            refreshHelper();\n          });\n        }\n      }\n      if (options.show_close_button) {\n        var button = dialog.querySelector(\".close\");\n        button.addEventListener(\"click\", dialog.close);\n      }\n\n      // compute best position\n      var rect = canvas.getBoundingClientRect();\n      var left = (event ? event.clientX : rect.left + rect.width * 0.5) - 80;\n      var top = (event ? event.clientY : rect.top + rect.height * 0.5) - 20;\n      if (rect.width - left < 470) left = rect.width - 470;\n      if (rect.height - top < 220) top = rect.height - 220;\n      if (left < rect.left + 20) left = rect.left + 20;\n      if (top < rect.top + 20) top = rect.top + 20;\n      dialog.style.left = left + \"px\";\n      dialog.style.top = top + \"px\";\n\n      /*\r\n      var offsetx = -20;\r\n      var offsety = -20;\r\n      if (rect) {\r\n          offsetx -= rect.left;\r\n          offsety -= rect.top;\r\n      }\r\n        if (event) {\r\n          dialog.style.left = event.clientX + offsetx + \"px\";\r\n          dialog.style.top = event.clientY + offsety + \"px\";\r\n      } else {\r\n          dialog.style.left = canvas.width * 0.5 + offsetx + \"px\";\r\n          dialog.style.top = canvas.height * 0.5 + offsety + \"px\";\r\n      }\r\n      canvas.parentNode.appendChild(dialog);\r\n      */\n\n      input.focus();\n      if (options.show_all_on_open) refreshHelper();\n      function select(name) {\n        if (name) {\n          if (that.onSearchBoxSelection) {\n            that.onSearchBoxSelection(name, event, graphcanvas);\n          } else {\n            var extra = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.searchbox_extras[name.toLowerCase()];\n            if (extra) {\n              name = extra.type;\n            }\n            graphcanvas.graph.beforeChange();\n            var node = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.createNode(name);\n            if (node) {\n              node.pos = graphcanvas.convertEventToCanvasOffset(event);\n              graphcanvas.graph.add(node, false, {\n                doProcessChange: false\n              });\n            }\n            if (extra && extra.data) {\n              if (extra.data.properties) {\n                for (var i in extra.data.properties) {\n                  node.addProperty(i, extra.data.properties[i]);\n                }\n              }\n              if (extra.data.inputs) {\n                node.inputs = [];\n                for (var _i16 in extra.data.inputs) {\n                  node.addOutput(extra.data.inputs[_i16][0], extra.data.inputs[_i16][1]);\n                }\n              }\n              if (extra.data.outputs) {\n                node.outputs = [];\n                for (var _i17 in extra.data.outputs) {\n                  node.addOutput(extra.data.outputs[_i17][0], extra.data.outputs[_i17][1]);\n                }\n              }\n              if (extra.data.title) {\n                node.title = extra.data.title;\n              }\n              if (extra.data.json) {\n                node.configure(extra.data.json);\n              }\n            }\n            var iS;\n\n            // join node after inserting\n            if (options.node_from) {\n              iS = false;\n              switch (_typeof(options.slot_from)) {\n                case \"string\":\n                  iS = options.node_from.findOutputSlot(options.slot_from);\n                  break;\n                case \"object\":\n                  if (options.slot_from.name) {\n                    iS = options.node_from.findOutputSlot(options.slot_from.name);\n                  } else {\n                    iS = -1;\n                  }\n                  if (iS == -1 && typeof options.slot_from.slot_index !== \"undefined\") iS = options.slot_from.slot_index;\n                  break;\n                case \"number\":\n                  iS = options.slot_from;\n                  break;\n                default:\n                  iS = 0;\n                // try with first if no name set\n              }\n              if (typeof options.node_from.outputs[iS] !== \"undefined\") {\n                if (iS !== false && iS > -1) {\n                  options.node_from.connectByType(iS, node, options.node_from.outputs[iS].type);\n                }\n              } else {\n                // LiteGraph.warn?.(\"cant find slot \" + options.slot_from);\n              }\n            }\n            if (options.node_to) {\n              iS = false;\n              switch (_typeof(options.slot_from)) {\n                case \"string\":\n                  iS = options.node_to.findInputSlot(options.slot_from);\n                  break;\n                case \"object\":\n                  if (options.slot_from.name) {\n                    iS = options.node_to.findInputSlot(options.slot_from.name);\n                  } else {\n                    iS = -1;\n                  }\n                  if (iS == -1 && typeof options.slot_from.slot_index !== \"undefined\") iS = options.slot_from.slot_index;\n                  break;\n                case \"number\":\n                  iS = options.slot_from;\n                  break;\n                default:\n                  iS = 0;\n                // try with first if no name set\n              }\n              if (typeof options.node_to.inputs[iS] !== \"undefined\") {\n                if (iS !== false && iS > -1) {\n                  // try connection\n                  options.node_to.connectByTypeOutput(iS, node, options.node_to.inputs[iS].type);\n                }\n              } else {\n                // LiteGraph.warn?.(\"cant find slot_nodeTO \" + options.slot_from);\n              }\n            }\n            graphcanvas.graph.afterChange();\n          }\n        }\n        dialog.close();\n      }\n      function changeSelection(forward) {\n        var prev = selected;\n        if (selected) {\n          selected.classList.remove(\"selected\");\n        }\n        if (!selected) {\n          selected = forward ? helper.childNodes[0] : helper.childNodes[helper.childNodes.length];\n        } else {\n          selected = forward ? selected.nextSibling : selected.previousSibling;\n          if (!selected) {\n            selected = prev;\n          }\n        }\n        if (!selected) {\n          return;\n        }\n        selected.classList.add(\"selected\");\n        selected.scrollIntoView({\n          block: \"end\",\n          behavior: \"smooth\"\n        });\n      }\n      function refreshHelper() {\n        timeout = null;\n        var str = input.value;\n        first = null;\n        helper.innerHTML = \"\";\n        if (!str && !options.show_all_if_empty) {\n          return;\n        }\n        if (that.onSearchBox) {\n          var list = that.onSearchBox(helper, str, graphcanvas);\n          if (list) {\n            for (var i = 0; i < list.length; ++i) {\n              addResult(list[i]);\n            }\n          }\n        } else {\n          var inner_test_filter = function inner_test_filter(type) {\n            var optsIn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var optsDef = {\n              skipFilter: false,\n              inTypeOverride: false,\n              outTypeOverride: false\n            };\n            var opts = Object.assign(optsDef, optsIn);\n            var ctor = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registered_node_types[type];\n            if (filter && ctor.filter != filter) return false;\n            if ((!options.show_all_if_empty || str) && type.toLowerCase().indexOf(str) === -1) return false;\n\n            // filter by slot IN, OUT types\n            if (options.do_type_filter && !opts.skipFilter) {\n              var sType = type;\n              var doesInc;\n              var sV = sIn.value;\n              if (opts.inTypeOverride !== false) sV = opts.inTypeOverride;\n              // if (sV.toLowerCase() == \"_event_\") sV = LiteGraph.EVENT; // -1\n\n              if (sIn && sV) {\n                // LiteGraph.log?.(\"will check filter against \"+sV);\n                if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registered_slot_in_types[sV] && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registered_slot_in_types[sV].nodes) {\n                  // type is stored\n                  // LiteGraph.debug?.(\"check \"+sType+\" in \"+LiteGraph.registered_slot_in_types[sV].nodes);\n                  doesInc = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registered_slot_in_types[sV].nodes.includes(sType);\n                  if (doesInc !== false) {\n                    // LiteGraph.log?.(sType+\" HAS \"+sV);\n                  } else {\n                    /* LiteGraph.debug?.(LiteGraph.registered_slot_in_types[sV]);\r\n                    LiteGraph.log?.(+\" DONT includes \"+type);*/\n                    return false;\n                  }\n                }\n              }\n              sV = sOut.value;\n              if (opts.outTypeOverride !== false) {\n                sV = opts.outTypeOverride;\n              }\n              // if (sV.toLowerCase() == \"_event_\") sV = LiteGraph.EVENT; // -1\n\n              if (sOut && sV) {\n                // LiteGraph.log?.(\"search will check filter against \"+sV);\n                if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registered_slot_out_types[sV] && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registered_slot_out_types[sV].nodes) {\n                  // type is stored\n                  // LiteGraph.debug?.(\"check \"+sType+\" in \"+LiteGraph.registered_slot_out_types[sV].nodes);\n                  doesInc = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registered_slot_out_types[sV].nodes.includes(sType);\n                  if (doesInc !== false) {\n                    // LiteGraph.log?.(sType+\" HAS \"+sV);\n                  } else {\n                    /* LiteGraph.debug?.(LiteGraph.registered_slot_out_types[sV]);\r\n                    LiteGraph.log?.(+\" DONT includes \"+type);*/\n                    return false;\n                  }\n                }\n              }\n            }\n            return true;\n          };\n          var c = 0;\n          str = str.toLowerCase();\n          var filter = graphcanvas.filter || graphcanvas.graph.filter;\n          var sIn, sOut;\n\n          // filter by type preprocess\n          if (options.do_type_filter && that.search_box) {\n            sIn = that.search_box.querySelector(\".slot_in_type_filter\");\n            sOut = that.search_box.querySelector(\".slot_out_type_filter\");\n          } else {\n            sIn = false;\n            sOut = false;\n          }\n\n          // extras\n          for (var _i18 in _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.searchbox_extras) {\n            var extra = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.searchbox_extras[_i18];\n            if ((!options.show_all_if_empty || str) && extra.desc.toLowerCase().indexOf(str) === -1) {\n              continue;\n            }\n            var ctor = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registered_node_types[extra.type];\n            if (ctor && ctor.filter != filter) continue;\n            if (!inner_test_filter(extra.type)) continue;\n            addResult(extra.desc, \"searchbox_extra\");\n            if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n              break;\n            }\n          }\n          var filtered = null;\n          if (Array.prototype.filter) {\n            // filter supported\n            var keys = Object.keys(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registered_node_types); // types\n            filtered = keys.filter(inner_test_filter);\n          } else {\n            filtered = [];\n            for (var _i19 in _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registered_node_types) {\n              if (inner_test_filter(_i19)) filtered.push(_i19);\n            }\n          }\n          for (var _i20 = 0; _i20 < filtered.length; _i20++) {\n            addResult(filtered[_i20]);\n            if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n              break;\n            }\n          }\n\n          // add general type if filtering\n          if (options.show_general_after_typefiltered && (sIn.value || sOut.value)) {\n            var filtered_extra = [];\n            for (var _i21 in _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registered_node_types) {\n              if (inner_test_filter(_i21, {\n                inTypeOverride: sIn && sIn.value ? \"*\" : false,\n                outTypeOverride: sOut && sOut.value ? \"*\" : false\n              })) filtered_extra.push(_i21);\n            }\n            for (var _i22 = 0; _i22 < filtered_extra.length; _i22++) {\n              addResult(filtered_extra[_i22], \"generic_type\");\n              if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n                break;\n              }\n            }\n          }\n\n          // check il filtering gave no results\n          if ((sIn.value || sOut.value) && helper.childNodes.length == 0 && options.show_general_if_none_on_typefilter) {\n            var filtered_extra = [];\n            for (var _i23 in _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registered_node_types) {\n              if (inner_test_filter(_i23, {\n                skipFilter: true\n              })) filtered_extra.push(_i23);\n            }\n            for (var _i24 = 0; _i24 < filtered_extra.length; _i24++) {\n              addResult(filtered_extra[_i24], \"not_in_filter\");\n              if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n                break;\n              }\n            }\n          }\n        }\n        function addResult(type, className) {\n          var help = document.createElement(\"div\");\n          if (!first) {\n            first = type;\n          }\n          help.innerText = type;\n          help.dataset[\"type\"] = escape(type); // @TODO: deprecated\n          help.className = \"litegraph lite-search-item\";\n          if (className) {\n            help.className += \" \" + className;\n          }\n          help.addEventListener(\"click\", function (_event) {\n            select(unescape(this.dataset[\"type\"]));\n          });\n          helper.appendChild(help);\n        }\n      }\n      return dialog;\n    }\n  }, {\n    key: \"showEditPropertyValue\",\n    value: function showEditPropertyValue(node, property, options) {\n      if (!node || node.properties[property] === undefined) {\n        return;\n      }\n      options = options || {};\n      var info = node.getPropertyInfo(property);\n      var type = info.type;\n      var input_html;\n      if (type == \"string\" || type == \"number\" || type == \"array\" || type == \"object\") {\n        input_html = \"<input autofocus type='text' class='value'/>\";\n      } else if ((type == \"enum\" || type == \"combo\") && info.values) {\n        var _LiteGraph$debug8;\n        (_LiteGraph$debug8 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug8 === void 0 || _LiteGraph$debug8.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"CREATING showEditPropertyValue ENUM COMBO\", input, type, dialog);\n        input_html = \"<select autofocus type='text' class='value'>\";\n        for (var i in info.values) {\n          var v = i;\n          if (info.values.constructor === Array) v = info.values[i];\n          input_html += \"<option value='\" + v + \"' \" + (v == node.properties[property] ? \"selected\" : \"\") + \">\" + info.values[i] + \"</option>\";\n        }\n        input_html += \"</select>\";\n      } else if (type == \"boolean\" || type == \"toggle\") {\n        input_html = \"<input autofocus type='checkbox' class='value' \" + (node.properties[property] ? \"checked\" : \"\") + \"/>\";\n      } else {\n        var _LiteGraph$warn15;\n        (_LiteGraph$warn15 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn15 === void 0 || _LiteGraph$warn15.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"unknown type: \" + type);\n        return;\n      }\n      var dialog = this.createDialog(\"<span class='name'>\" + (info.label ? info.label : property) + \"</span>\" + input_html + \"<button>OK</button>\", options);\n      var input = false;\n      if ((type == \"enum\" || type == \"combo\") && info.values) {\n        var _LiteGraph$debug9;\n        (_LiteGraph$debug9 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug9 === void 0 || _LiteGraph$debug9.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"showEditPropertyValue ENUM COMBO\", input, type, dialog);\n        input = dialog.querySelector(\"select\");\n        input.addEventListener(\"change\", function (e) {\n          var _LiteGraph$debug10;\n          dialog.modified();\n          (_LiteGraph$debug10 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug10 === void 0 || _LiteGraph$debug10.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Enum change\", input, info, e.target);\n          setValue(e.target.value);\n          // var index = e.target.value;\n          // setValue( e.options[e.selectedIndex].value );\n        });\n      } else if (type == \"boolean\" || type == \"toggle\") {\n        var _LiteGraph$debug11;\n        (_LiteGraph$debug11 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug11 === void 0 || _LiteGraph$debug11.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"showEditPropertyValue TOGGLE\", input, type, dialog);\n        input = dialog.querySelector(\"input\");\n        if (input) {\n          input.addEventListener(\"click\", function (_event) {\n            dialog.modified();\n            setValue(!!input.checked);\n          });\n        }\n      } else {\n        var _LiteGraph$debug12;\n        input = dialog.querySelector(\"input\");\n        (_LiteGraph$debug12 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug12 === void 0 || _LiteGraph$debug12.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"showEditPropertyValue\", input, type, dialog);\n        if (input) {\n          input.addEventListener(\"blur\", function (_event) {\n            this.focus();\n          });\n          v = node.properties[property] !== undefined ? node.properties[property] : \"\";\n          if (type !== 'string') {\n            v = JSON.stringify(v);\n          }\n          input.value = v;\n          input.addEventListener(\"keydown\", function (e) {\n            if (e.keyCode == 27) {\n              // ESC\n              dialog.close();\n            } else if (e.keyCode == 13) {\n              // ENTER\n              inner(); // save\n            } else if (e.keyCode != 13) {\n              dialog.modified();\n              return;\n            }\n            e.preventDefault();\n            e.stopPropagation();\n          });\n        }\n      }\n      if (input) input.focus();\n      var button = dialog.querySelector(\"button\");\n      button.addEventListener(\"click\", inner);\n      function inner() {\n        setValue(input.value);\n      }\n      function setValue(value) {\n        var _node$graph;\n        if (info && info.values && info.values.constructor === Object && info.values[value] != undefined) value = info.values[value];\n        if (typeof node.properties[property] == \"number\") {\n          value = Number(value);\n        }\n        if (type == \"array\" || type == \"object\") {\n          value = JSON.parse(value);\n        }\n        node.properties[property] = value;\n        (_node$graph = node.graph) === null || _node$graph === void 0 || _node$graph.onGraphChanged({\n          action: \"propertyChanged\",\n          doSave: true\n        });\n        if (node.onPropertyChanged) {\n          node.onPropertyChanged(property, value);\n        }\n        if (options.onclose) options.onclose();\n        dialog.close();\n        node.setDirtyCanvas(true, true);\n      }\n      return dialog;\n    }\n\n    // TODO refactor, theer are different dialog, some uses createDialog, some dont\n  }, {\n    key: \"createDialog\",\n    value: function createDialog(html, options) {\n      var def_options = {\n        checkForInput: false,\n        closeOnLeave: true,\n        closeOnLeave_checkModified: true\n      };\n      options = Object.assign(def_options, options || {});\n      var dialog = document.createElement(\"div\");\n      dialog.className = \"graphdialog\";\n      dialog.innerHTML = html;\n      dialog.is_modified = false;\n      var rect = this.canvas.getBoundingClientRect();\n      var offsetx = -20;\n      var offsety = -20;\n      if (rect) {\n        offsetx -= rect.left;\n        offsety -= rect.top;\n      }\n      if (options.position) {\n        offsetx += options.position[0];\n        offsety += options.position[1];\n      } else if (options.event) {\n        offsetx += options.event.clientX;\n        offsety += options.event.clientY;\n      } else {\n        // centered\n        offsetx += this.canvas.width * 0.5;\n        offsety += this.canvas.height * 0.5;\n      }\n      dialog.style.left = offsetx + \"px\";\n      dialog.style.top = offsety + \"px\";\n      this.canvas.parentNode.appendChild(dialog);\n\n      // check for input and use default behaviour: save on enter, close on esc\n      if (options.checkForInput) {\n        var aI = [];\n        var focused = false;\n        aI = dialog.querySelectorAll(\"input\");\n        if (aI) {\n          aI.forEach(function (iX) {\n            iX.addEventListener(\"keydown\", function (e) {\n              dialog.modified();\n              if (e.keyCode == 27) {\n                dialog.close();\n              } else if (e.keyCode != 13) {\n                return;\n              }\n              // set value ?\n              e.preventDefault();\n              e.stopPropagation();\n            });\n            if (!focused) iX.focus();\n          });\n        }\n      }\n      dialog.modified = function () {\n        dialog.is_modified = true;\n      };\n      dialog.close = function () {\n        if (dialog.parentNode) {\n          dialog.parentNode.removeChild(dialog);\n        }\n      };\n      var dialogCloseTimer = null;\n      var prevent_timeout = false;\n      dialog.addEventListener(\"pointerleave\", function (_event) {\n        if (prevent_timeout) return;\n        if (options.closeOnLeave || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.dialog_close_on_mouse_leave) if (!dialog.is_modified && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.dialog_close_on_mouse_leave) dialogCloseTimer = setTimeout(dialog.close, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.dialog_close_on_mouse_leave_delay); // dialog.close();\n      });\n      dialog.addEventListener(\"pointerenter\", function (_event) {\n        if (options.closeOnLeave || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.dialog_close_on_mouse_leave) if (dialogCloseTimer) clearTimeout(dialogCloseTimer);\n      });\n      var selInDia = dialog.querySelectorAll(\"select\");\n      if (selInDia) {\n        // if filtering, check focus changed to comboboxes and prevent closing\n        selInDia.forEach(function (selIn) {\n          selIn.addEventListener(\"click\", function (_event) {\n            prevent_timeout++;\n          });\n          selIn.addEventListener(\"blur\", function (_event) {\n            prevent_timeout = 0;\n          });\n          selIn.addEventListener(\"change\", function (_event) {\n            prevent_timeout = -1;\n          });\n        });\n      }\n      return dialog;\n    }\n  }, {\n    key: \"createPanel\",\n    value: function createPanel(title, options) {\n      options = options || {};\n      var ref_window = options.window || window;\n      var root = document.createElement(\"div\");\n      root.className = \"litegraph dialog\";\n      root.innerHTML = \"<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div style='display:none;' class='dialog-alt-content'></div><div class='dialog-footer'></div>\";\n      root.header = root.querySelector(\".dialog-header\");\n      if (options.width) root.style.width = options.width + (options.width.constructor === Number ? \"px\" : \"\");\n      if (options.height) root.style.height = options.height + (options.height.constructor === Number ? \"px\" : \"\");\n      if (options.closable) {\n        var close = document.createElement(\"span\");\n        close.innerHTML = \"&#10005;\";\n        close.classList.add(\"close\");\n        close.addEventListener(\"click\", function () {\n          root.close();\n        });\n        root.header.appendChild(close);\n      }\n      root.title_element = root.querySelector(\".dialog-title\");\n      root.title_element.innerText = title;\n      root.content = root.querySelector(\".dialog-content\");\n      root.alt_content = root.querySelector(\".dialog-alt-content\");\n      root.footer = root.querySelector(\".dialog-footer\");\n      root.close = function () {\n        if (root.onClose && typeof root.onClose == \"function\") {\n          root.onClose();\n        }\n        if (root.parentNode) root.parentNode.removeChild(root);\n        /* XXX CHECK THIS */\n        if (this.parentNode) {\n          this.parentNode.removeChild(this);\n        }\n        /* XXX this was not working, was fixed with an IF, check this */\n      };\n\n      // function to swap panel content\n      root.toggleAltContent = function (force) {\n        var vTo, vAlt;\n        if (typeof force != \"undefined\") {\n          vTo = force ? \"block\" : \"none\";\n          vAlt = force ? \"none\" : \"block\";\n        } else {\n          vTo = root.alt_content.style.display != \"block\" ? \"block\" : \"none\";\n          vAlt = root.alt_content.style.display != \"block\" ? \"none\" : \"block\";\n        }\n        root.alt_content.style.display = vTo;\n        root.content.style.display = vAlt;\n      };\n      root.toggleFooterVisibility = function (force) {\n        var vTo;\n        if (typeof force != \"undefined\") {\n          vTo = force ? \"block\" : \"none\";\n        } else {\n          vTo = root.footer.style.display != \"block\" ? \"block\" : \"none\";\n        }\n        root.footer.style.display = vTo;\n      };\n      root.clear = function () {\n        this.content.innerHTML = \"\";\n      };\n      root.addHTML = function (code, classname, on_footer) {\n        var elem = document.createElement(\"div\");\n        if (classname) elem.className = classname;\n        elem.innerHTML = code;\n        if (on_footer) root.footer.appendChild(elem);else root.content.appendChild(elem);\n        return elem;\n      };\n      root.addButton = function (name, callback, options) {\n        var elem = document.createElement(\"button\");\n        elem.innerText = name;\n        elem.options = options;\n        elem.classList.add(\"btn\");\n        elem.addEventListener(\"click\", callback);\n        root.footer.appendChild(elem);\n        return elem;\n      };\n      root.addSeparator = function () {\n        var elem = document.createElement(\"div\");\n        elem.className = \"separator\";\n        root.content.appendChild(elem);\n      };\n      root.addWidget = function (type, name, value, options, callback) {\n        var _LiteGraph$debug13;\n        options = options || {};\n        var str_value = String(value);\n        type = type.toLowerCase();\n        if (type == \"number\") str_value = value.toFixed(3);\n        var elem = document.createElement(\"div\");\n        elem.className = \"property\";\n        elem.innerHTML = \"<span class='property_name'></span><span class='property_value'></span>\";\n        elem.querySelector(\".property_name\").innerText = options.label || name;\n        var value_element = elem.querySelector(\".property_value\");\n        value_element.innerText = str_value;\n        elem.dataset[\"property\"] = name;\n        elem.dataset[\"type\"] = options.type || type;\n        elem.options = options;\n        elem.value = value;\n        (_LiteGraph$debug13 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug13 === void 0 || _LiteGraph$debug13.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"addWidget\", type, value, value_element, options);\n        if (type == \"code\") {\n          elem.addEventListener(\"click\", function (_event) {\n            root.inner_showCodePad(this.dataset[\"property\"]);\n          });\n        } else if (type == \"boolean\") {\n          elem.classList.add(\"boolean\");\n          if (value) elem.classList.add(\"bool-on\");\n          elem.addEventListener(\"click\", function () {\n            // var v = node.properties[this.dataset[\"property\"]];\n            // node.setProperty(this.dataset[\"property\"],!v); this.innerText = v ? \"true\" : \"false\";\n            var propname = this.dataset[\"property\"];\n            this.value = !this.value;\n            this.classList.toggle(\"bool-on\");\n            this.querySelector(\".property_value\").innerText = this.value ? \"true\" : \"false\";\n            innerChange(propname, this.value);\n          });\n        } else if (type == \"string\" || type == \"number\") {\n          value_element.setAttribute(\"contenteditable\", true);\n          value_element.addEventListener(\"keydown\", function (e) {\n            if (e.code == \"Enter\" && (type != \"string\" || !e.shiftKey)) {\n              // allow for multiline\n              e.preventDefault();\n              this.blur();\n            }\n          });\n          value_element.addEventListener(\"blur\", function () {\n            var v = this.innerText;\n            var propname = this.parentNode.dataset[\"property\"];\n            var proptype = this.parentNode.dataset[\"type\"];\n            if (proptype == \"number\") v = Number(v);\n            innerChange(propname, v);\n          });\n        } else if (type == \"enum\" || type == \"combo\") {\n          var _LiteGraph$debug14;\n          str_value = LGraphCanvas.getPropertyPrintableValue(value, options.values);\n          value_element.innerText = str_value;\n          (_LiteGraph$debug14 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug14 === void 0 || _LiteGraph$debug14.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"addWidget ENUM COMBO\", type, str_value, value_element, options);\n          value_element.addEventListener(\"click\", function (event) {\n            var values = options.values || [];\n            var propname = this.parentNode.dataset[\"property\"];\n            var elem_that = this;\n            new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu(values, {\n              event: event,\n              className: \"dark\",\n              callback: inner_clicked\n            }, ref_window);\n            function inner_clicked(v) {\n              // node.setProperty(propname,v);\n              // graphcanvas.dirty_canvas = true;\n              elem_that.innerText = v;\n              innerChange(propname, v);\n              return false;\n            }\n          });\n        }\n        root.content.appendChild(elem);\n        function innerChange(name, value) {\n          var _LiteGraph$debug15;\n          (_LiteGraph$debug15 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug15 === void 0 || _LiteGraph$debug15.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"widgetInnerChange\", name, value, options);\n          // that.dirty_canvas = true;\n          if (options.callback) options.callback(name, value, options);\n          if (callback) callback(name, value, options);\n        }\n        return elem;\n      };\n      if (root.onOpen && typeof root.onOpen == \"function\") root.onOpen();\n      return root;\n    }\n  }, {\n    key: \"closePanels\",\n    value: function closePanels() {\n      var panel = document.querySelector(\"#node-panel\");\n      if (panel) panel.close();\n      panel = document.querySelector(\"#option-panel\");\n      if (panel) panel.close();\n    }\n  }, {\n    key: \"showShowGraphOptionsPanel\",\n    value: function showShowGraphOptionsPanel(refOpts, obEv) {\n      var graphcanvas;\n      if (this.constructor && this.constructor.name == \"HTMLDivElement\") {\n        var _obEv$event;\n        // assume coming from the menu event click\n        if (!(obEv !== null && obEv !== void 0 && (_obEv$event = obEv.event) !== null && _obEv$event !== void 0 && (_obEv$event = _obEv$event.target) !== null && _obEv$event !== void 0 && _obEv$event.lgraphcanvas)) {\n          var _LiteGraph$warn16, _LiteGraph$debug16;\n          (_LiteGraph$warn16 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn16 === void 0 || _LiteGraph$warn16.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"References not found to add optionPanel\", refOpts, obEv); // need a ref to canvas obj\n          if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) (_LiteGraph$debug16 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug16 === void 0 || _LiteGraph$debug16.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"!obEv || !obEv.event || !obEv.event.target || !obEv.event.target.lgraphcanvas\", obEv, obEv.event, obEv.event.target, obEv.event.target.lgraphcanvas);\n          return;\n        }\n        graphcanvas = obEv.event.target.lgraphcanvas;\n      } else {\n        // assume called internally\n        graphcanvas = this;\n      }\n      graphcanvas.closePanels();\n      var ref_window = graphcanvas.getCanvasWindow();\n      panel = graphcanvas.createPanel(\"Options\", {\n        closable: true,\n        window: ref_window,\n        onOpen: function onOpen() {\n          graphcanvas.OPTIONPANEL_IS_OPEN = true;\n        },\n        onClose: function onClose() {\n          graphcanvas.OPTIONPANEL_IS_OPEN = false;\n          graphcanvas.options_panel = null;\n        }\n      });\n      graphcanvas.options_panel = panel;\n      panel.id = \"option-panel\";\n      panel.classList.add(\"settings\");\n      function inner_refresh() {\n        panel.content.innerHTML = \"\"; // clear\n\n        var fUpdate = function fUpdate(name, value, options) {\n          switch (name) {\n            /* case \"Render mode\":\r\n                // Case \"\"..\r\n                if (options.values && options.key){\r\n                    var kV = Object.values(options.values).indexOf(value);\r\n                    if (kV>=0 && options.values[kV]){\r\n                        LiteGraph.debug?.(\"update graph options: \"+options.key+\": \"+kV);\r\n                        graphcanvas[options.key] = kV;\r\n                        //LiteGraph.debug?.(graphcanvas);\r\n                        break;\r\n                    }\r\n                }\r\n                LiteGraph.warn?.(\"unexpected options\");\r\n                LiteGraph.debug?.(options);\r\n                break;*/\n            default:\n              // LiteGraph.debug?.(\"want to update graph options: \"+name+\": \"+value);\n              if (options && options.key) {\n                name = options.key;\n              }\n              if (options.values) {\n                value = Object.values(options.values).indexOf(value);\n              }\n              // LiteGraph.debug?.(\"update graph option: \"+name+\": \"+value);\n              graphcanvas[name] = value;\n              break;\n          }\n        };\n\n        // panel.addWidget( \"string\", \"Graph name\", \"\", {}, fUpdate); // implement\n\n        var aProps = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.availableCanvasOptions;\n        aProps.sort();\n        for (var pI in aProps) {\n          var pX = aProps[pI];\n          panel.addWidget(\"boolean\", pX, graphcanvas[pX], {\n            key: pX,\n            on: \"True\",\n            off: \"False\"\n          }, fUpdate);\n        }\n        panel.addWidget(\"combo\", \"Render mode\", _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LINK_RENDER_MODES[graphcanvas.links_render_mode], {\n          key: \"links_render_mode\",\n          values: _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LINK_RENDER_MODES\n        }, fUpdate);\n        panel.addSeparator();\n        panel.footer.innerHTML = \"\"; // clear\n      }\n      inner_refresh();\n      graphcanvas.canvas.parentNode.appendChild(panel);\n    }\n  }, {\n    key: \"showShowNodePanel\",\n    value: function showShowNodePanel(node) {\n      this.SELECTED_NODE = node;\n      this.closePanels();\n      var ref_window = this.getCanvasWindow();\n      var graphcanvas = this;\n      var panel = this.createPanel(node.title || \"\", {\n        closable: true,\n        window: ref_window,\n        onOpen: function onOpen() {\n          graphcanvas.NODEPANEL_IS_OPEN = true;\n        },\n        onClose: function onClose() {\n          graphcanvas.NODEPANEL_IS_OPEN = false;\n          graphcanvas.node_panel = null;\n        }\n      });\n      graphcanvas.node_panel = panel;\n      panel.id = \"node-panel\";\n      panel.node = node;\n      panel.classList.add(\"settings\");\n      function inner_refresh() {\n        panel.content.innerHTML = \"\"; // clear\n        panel.addHTML(\"<span class='node_type'>\" + node.type + \"</span>\" + \"<span class='node_desc'>\" + (node.constructor.desc || \"\") + \"</span>\" + \"<span class='separator'></span>\");\n        panel.addHTML(\"<h3>Properties</h3>\");\n        var fUpdate = function fUpdate(name, value) {\n          graphcanvas.graph.beforeChange(node);\n          switch (name) {\n            case \"Title\":\n              node.title = value;\n              break;\n            case \"Mode\":\n              var kV = Object.values(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_MODES).indexOf(value);\n              if (kV >= 0 && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_MODES[kV]) {\n                node.changeMode(kV);\n              } else {\n                var _LiteGraph$warn17;\n                (_LiteGraph$warn17 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn17 === void 0 || _LiteGraph$warn17.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"unexpected mode: \" + value);\n              }\n              break;\n            case \"Color\":\n              if (LGraphCanvas.node_colors[value]) {\n                node.color = LGraphCanvas.node_colors[value].color;\n                node.bgcolor = LGraphCanvas.node_colors[value].bgcolor;\n              } else {\n                var _LiteGraph$warn18;\n                (_LiteGraph$warn18 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn18 === void 0 || _LiteGraph$warn18.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"unexpected color: \" + value);\n              }\n              break;\n            default:\n              node.setProperty(name, value);\n              break;\n          }\n          graphcanvas.graph.afterChange();\n          graphcanvas.dirty_canvas = true;\n        };\n        panel.addWidget(\"string\", \"Title\", node.title, {}, fUpdate);\n        panel.addWidget(\"combo\", \"Mode\", _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_MODES[node.mode], {\n          values: _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_MODES\n        }, fUpdate);\n        var nodeCol = \"\";\n        if (node.color !== undefined) {\n          nodeCol = Object.keys(LGraphCanvas.node_colors).filter(function (nK) {\n            return LGraphCanvas.node_colors[nK].color == node.color;\n          });\n        }\n        panel.addWidget(\"combo\", \"Color\", nodeCol, {\n          values: Object.keys(LGraphCanvas.node_colors)\n        }, fUpdate);\n        for (var pName in node.properties) {\n          var value = node.properties[pName];\n          var info = node.getPropertyInfo(pName);\n          // @TODO: Figure out if deleting this is a bug:\n          // var type = info.type || \"string\";\n\n          // in case the user wants control over the side panel widget\n          if (node.onAddPropertyToPanel && node.onAddPropertyToPanel(pName, panel, value, info, fUpdate)) {\n            continue;\n          }\n          panel.addWidget(info.widget || info.type, pName, value, info, fUpdate);\n        }\n        panel.addSeparator();\n        if (node.onShowCustomPanelInfo) node.onShowCustomPanelInfo(panel);\n        panel.footer.innerHTML = \"\"; // clear\n        panel.addButton(\"Delete\", function () {\n          if (node.block_delete) return;\n          node.graph.remove(node);\n          panel.close();\n        }).classList.add(\"delete\");\n      }\n      panel.inner_showCodePad = function (propname) {\n        panel.classList.remove(\"settings\");\n        panel.classList.add(\"centered\");\n\n        /* if(window.CodeFlask) //disabled for now\r\n        {\r\n            panel.content.innerHTML = \"<div class='code'></div>\";\r\n            var flask = new CodeFlask( \"div.code\", { language: 'js' });\r\n            flask.updateCode(node.properties[propname]);\r\n            flask.onUpdate( function(code) {\r\n                node.setProperty(propname, code);\r\n            });\r\n        }\r\n        else\r\n        {*/\n        panel.alt_content.innerHTML = \"<textarea class='code'></textarea>\";\n        var textarea = panel.alt_content.querySelector(\"textarea\");\n        var fDoneWith = function fDoneWith() {\n          panel.toggleAltContent(false); // if(node_prop_div) node_prop_div.style.display = \"block\"; // panel.close();\n          panel.toggleFooterVisibility(true);\n          textarea.parentNode.removeChild(textarea);\n          panel.classList.add(\"settings\");\n          panel.classList.remove(\"centered\");\n          inner_refresh();\n        };\n        textarea.value = node.properties[propname];\n        textarea.addEventListener(\"keydown\", function (e) {\n          if (e.code == \"Enter\" && e.ctrlKey) {\n            node.setProperty(propname, textarea.value);\n            fDoneWith();\n          }\n        });\n        panel.toggleAltContent(true);\n        panel.toggleFooterVisibility(false);\n        textarea.style.height = \"calc(100% - 40px)\";\n        /* }*/\n        var assign = panel.addButton(\"Assign\", function () {\n          node.setProperty(propname, textarea.value);\n          fDoneWith();\n        });\n        panel.alt_content.appendChild(assign); // panel.content.appendChild(assign);\n        var button = panel.addButton(\"Close\", fDoneWith);\n        button.style[\"float\"] = \"right\";\n        panel.alt_content.appendChild(button); // panel.content.appendChild(button);\n      };\n      inner_refresh();\n      this.canvas.parentNode.appendChild(panel);\n    }\n  }, {\n    key: \"showSubgraphPropertiesDialog\",\n    value: function showSubgraphPropertiesDialog(node) {\n      var _LiteGraph$log3;\n      (_LiteGraph$log3 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log3 === void 0 || _LiteGraph$log3.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"showing subgraph properties dialog\");\n      var old_panel = this.canvas.parentNode.querySelector(\".subgraph_dialog\");\n      if (old_panel) old_panel.close();\n      var panel = this.createPanel(\"Subgraph Inputs\", {\n        closable: true,\n        width: 500\n      });\n      panel.node = node;\n      panel.classList.add(\"subgraph_dialog\");\n      function inner_refresh() {\n        panel.clear();\n\n        // show currents\n        if (node.inputs) for (var i = 0; i < node.inputs.length; ++i) {\n          var input = node.inputs[i];\n          if (input.not_subgraph_input) continue;\n          var html = \"<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>\";\n          var elem = panel.addHTML(html, \"subgraph_property\");\n          elem.dataset[\"name\"] = input.name;\n          elem.dataset[\"slot\"] = i;\n          elem.querySelector(\".name\").innerText = input.name;\n          elem.querySelector(\".type\").innerText = input.type;\n          elem.querySelector(\"button\").addEventListener(\"click\", function (_event) {\n            node.removeInput(Number(this.parentNode.dataset[\"slot\"]));\n            inner_refresh();\n          });\n        }\n      }\n\n      // add extra\n      var html = \" + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>\";\n      var elem = panel.addHTML(html, \"subgraph_property extra\", true);\n      elem.querySelector(\"button\").addEventListener(\"click\", function (_event) {\n        var elem = this.parentNode;\n        var name = elem.querySelector(\".name\").value;\n        var type = elem.querySelector(\".type\").value;\n        if (!name || node.findInputSlot(name) != -1) return;\n        node.addInput(name, type);\n        elem.querySelector(\".name\").value = \"\";\n        elem.querySelector(\".type\").value = \"\";\n        inner_refresh();\n      });\n      inner_refresh();\n      this.canvas.parentNode.appendChild(panel);\n      return panel;\n    }\n  }, {\n    key: \"showSubgraphPropertiesDialogRight\",\n    value: function showSubgraphPropertiesDialogRight(node) {\n      // LiteGraph.log?.(\"showing subgraph properties dialog\");\n\n      // old_panel if old_panel is exist close it\n      var old_panel = this.canvas.parentNode.querySelector(\".subgraph_dialog\");\n      if (old_panel) old_panel.close();\n      // new panel\n      var panel = this.createPanel(\"Subgraph Outputs\", {\n        closable: true,\n        width: 500\n      });\n      panel.node = node;\n      panel.classList.add(\"subgraph_dialog\");\n      function inner_refresh() {\n        panel.clear();\n        // show currents\n        if (node.outputs) for (var i = 0; i < node.outputs.length; ++i) {\n          var input = node.outputs[i];\n          if (input.not_subgraph_output) continue;\n          var html = \"<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>\";\n          var elem = panel.addHTML(html, \"subgraph_property\");\n          elem.dataset[\"name\"] = input.name;\n          elem.dataset[\"slot\"] = i;\n          elem.querySelector(\".name\").innerText = input.name;\n          elem.querySelector(\".type\").innerText = input.type;\n          elem.querySelector(\"button\").addEventListener(\"click\", function (_event) {\n            node.removeOutput(Number(this.parentNode.dataset[\"slot\"]));\n            inner_refresh();\n          });\n        }\n      }\n\n      // add extra\n      var html = \" + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>\";\n      var elem = panel.addHTML(html, \"subgraph_property extra\", true);\n      elem.querySelector(\".name\").addEventListener(\"keydown\", function (_event) {\n        if (e.keyCode == 13) {\n          addOutput.apply(this);\n        }\n      });\n      elem.querySelector(\"button\").addEventListener(\"click\", function (_event) {\n        addOutput.apply(this);\n      });\n      function addOutput() {\n        var elem = this.parentNode;\n        var name = elem.querySelector(\".name\").value;\n        var type = elem.querySelector(\".type\").value;\n        if (!name || node.findOutputSlot(name) != -1) return;\n        node.addOutput(name, type);\n        elem.querySelector(\".name\").value = \"\";\n        elem.querySelector(\".type\").value = \"\";\n        inner_refresh();\n      }\n      inner_refresh();\n      this.canvas.parentNode.appendChild(panel);\n      return panel;\n    }\n  }, {\n    key: \"checkPanels\",\n    value: function checkPanels() {\n      if (!this.canvas) return;\n      var panels = this.canvas.parentNode.querySelectorAll(\".litegraph.dialog\");\n      for (var i = 0; i < panels.length; ++i) {\n        var panel = panels[i];\n        if (!panel.node) continue;\n        if (!panel.node.graph || panel.graph != this.graph) panel.close();\n      }\n    }\n  }, {\n    key: \"getCanvasMenuOptions\",\n    value: function getCanvasMenuOptions() {\n      var options = null;\n      if (this.getMenuOptions) {\n        options = this.getMenuOptions();\n      } else {\n        options = [{\n          content: \"Add Node\",\n          has_submenu: true,\n          callback: LGraphCanvas.onMenuAdd\n        }, {\n          content: \"Add Group\",\n          callback: LGraphCanvas.onGroupAdd\n        }\n        // { content: \"Arrange\", callback: that.graph.arrange },\n        // {content:\"Collapse All\", callback: LGraphCanvas.onMenuCollapseAll }\n        ];\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.showCanvasOptions) {\n          options.push({\n            content: \"Options\",\n            callback: this.showShowGraphOptionsPanel\n          });\n        }\n        if (Object.keys(this.selected_nodes).length > 1) {\n          options.push({\n            content: \"Align\",\n            has_submenu: true,\n            callback: LGraphCanvas.onGroupAlign\n          });\n        }\n        if (this._graph_stack && this._graph_stack.length > 0) {\n          options.push(null, {\n            content: \"Close subgraph\",\n            callback: this.closeSubgraph.bind(this)\n          });\n        }\n      }\n      if (this.getExtraMenuOptions) {\n        var extra = this.getExtraMenuOptions(this, options);\n        if (extra) {\n          options = options.concat(extra);\n        }\n      }\n      return options;\n    }\n\n    // called by processContextMenu to extract the menu list\n  }, {\n    key: \"getNodeMenuOptions\",\n    value: function getNodeMenuOptions(node) {\n      var options = null;\n      if (node.getMenuOptions) {\n        options = node.getMenuOptions(this);\n      } else {\n        options = [{\n          content: \"Inputs\",\n          has_submenu: true,\n          disabled: true,\n          callback: LGraphCanvas.showMenuNodeOptionalInputs\n        }, {\n          content: \"Outputs\",\n          has_submenu: true,\n          disabled: true,\n          callback: LGraphCanvas.showMenuNodeOptionalOutputs\n        }, null, {\n          content: \"Properties\",\n          has_submenu: true,\n          callback: LGraphCanvas.onShowMenuNodeProperties\n        }, null, {\n          content: \"Title\",\n          callback: LGraphCanvas.onShowPropertyEditor\n        }, {\n          content: \"Mode\",\n          has_submenu: true,\n          callback: LGraphCanvas.onMenuNodeMode\n        }];\n        if (node.resizable !== false) {\n          options.push({\n            content: \"Resize\",\n            callback: LGraphCanvas.onMenuResizeNode\n          });\n        }\n        options.push({\n          content: \"Collapse\",\n          callback: LGraphCanvas.onMenuNodeCollapse\n        }, {\n          content: \"Pin\",\n          callback: LGraphCanvas.onMenuNodePin\n        }, {\n          content: \"Colors\",\n          has_submenu: true,\n          callback: LGraphCanvas.onMenuNodeColors\n        }, {\n          content: \"Shapes\",\n          has_submenu: true,\n          callback: LGraphCanvas.onMenuNodeShapes\n        }, null);\n      }\n      if (node.onGetInputs) {\n        var inputs = node.onGetInputs();\n        if (inputs && inputs.length) {\n          options[0].disabled = false;\n        }\n      }\n      if (node.onGetOutputs) {\n        var outputs = node.onGetOutputs();\n        if (outputs && outputs.length) {\n          options[1].disabled = false;\n        }\n      }\n      if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.do_add_triggers_slots) options[1].disabled = false;\n      if (node.getExtraMenuOptions) {\n        var extra = node.getExtraMenuOptions(this, options);\n        if (extra) {\n          extra.push(null);\n          options = extra.concat(options);\n        }\n      }\n      if (node.clonable !== false) {\n        options.push({\n          content: \"Clone\",\n          callback: LGraphCanvas.onMenuNodeClone\n        });\n      }\n      /*\r\n      if(0) // @TODO: Figure out what this was for\r\n      options.push({\r\n          content: \"To Subgraph\",\r\n          callback: LGraphCanvas.onMenuNodeToSubgraph\r\n      });\r\n      */\n      if (Object.keys(this.selected_nodes).length > 1) {\n        options.push({\n          content: \"Align Selected To\",\n          has_submenu: true,\n          callback: LGraphCanvas.onNodeAlign\n        });\n      }\n      options.push(null, {\n        content: \"Remove\",\n        disabled: !(node.removable !== false && !node.block_delete),\n        callback: LGraphCanvas.onMenuNodeRemove\n      });\n      if (node.graph && node.graph.onGetNodeMenuOptions) {\n        node.graph.onGetNodeMenuOptions(options, node);\n      }\n      return options;\n    }\n  }, {\n    key: \"getGroupMenuOptions\",\n    value: function getGroupMenuOptions() {\n      var o = [{\n        content: \"Title\",\n        callback: LGraphCanvas.onShowPropertyEditor\n      }, {\n        content: \"Color\",\n        has_submenu: true,\n        callback: LGraphCanvas.onMenuNodeColors\n      }, {\n        content: \"Font size\",\n        property: \"font_size\",\n        type: \"Number\",\n        callback: LGraphCanvas.onShowPropertyEditor\n      }, null, {\n        content: \"Remove\",\n        callback: LGraphCanvas.onMenuNodeRemove\n      }];\n      return o;\n    }\n  }, {\n    key: \"processContextMenu\",\n    value: function processContextMenu(node, event) {\n      var that = this;\n      var canvas = LGraphCanvas.active_canvas;\n      var ref_window = canvas.getCanvasWindow();\n      var menu_info = null;\n      var options = {\n        event: event,\n        callback: inner_option_clicked,\n        extra: node\n      };\n      if (node) options.title = node.type;\n\n      // check if mouse is in input\n      var slot = null;\n      if (node) {\n        slot = node.getSlotInPosition(event.canvasX, event.canvasY);\n        LGraphCanvas.active_node = node;\n      }\n      if (slot) {\n        // on slot\n        menu_info = [];\n        if (node.getSlotMenuOptions) {\n          menu_info = node.getSlotMenuOptions(slot);\n        } else {\n          var _slot5, _slot$input;\n          if ((_slot5 = slot) !== null && _slot5 !== void 0 && (_slot5 = _slot5.output) !== null && _slot5 !== void 0 && (_slot5 = _slot5.links) !== null && _slot5 !== void 0 && _slot5.length || (_slot$input = slot.input) !== null && _slot$input !== void 0 && _slot$input.link) {\n            menu_info.push({\n              content: \"Disconnect Links\",\n              slot: slot\n            });\n          }\n          var _slot = slot.input || slot.output;\n          if (_slot.removable && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.canRemoveSlots) {\n            menu_info.push(_slot.locked ? \"Cannot remove\" : {\n              content: \"Remove Slot\",\n              slot: slot\n            });\n          }\n          if (!_slot.nameLocked && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.canRenameSlots) {\n            menu_info.push({\n              content: \"Rename Slot\",\n              slot: slot\n            });\n          }\n        }\n        var slotOb = slot.input || slot.output;\n        options.title = slotOb.type || \"*\";\n        if (slotOb.type == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION) {\n          options.title = \"Action\";\n        } else if (slotOb.type == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT) {\n          options.title = \"Event\";\n        }\n      } else {\n        if (node) {\n          // on node\n          menu_info = this.getNodeMenuOptions(node);\n        } else {\n          menu_info = this.getCanvasMenuOptions();\n          var group = this.graph.getGroupOnPos(event.canvasX, event.canvasY);\n          if (group) {\n            // on group\n            menu_info.push(null, {\n              content: \"Edit Group\",\n              has_submenu: true,\n              submenu: {\n                title: \"Group\",\n                extra: group,\n                options: this.getGroupMenuOptions(group)\n              }\n            });\n          }\n        }\n      }\n\n      // show menu\n      if (!menu_info) {\n        return;\n      }\n      new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu(menu_info, options, ref_window);\n      function inner_option_clicked(v, options) {\n        if (!v) {\n          return;\n        }\n        var info;\n        if (v.content == \"Remove Slot\") {\n          info = v.slot;\n          node.graph.beforeChange();\n          if (info.input) {\n            node.removeInput(info.slot);\n          } else if (info.output) {\n            node.removeOutput(info.slot);\n          }\n          node.graph.afterChange();\n          return;\n        } else if (v.content == \"Disconnect Links\") {\n          info = v.slot;\n          node.graph.beforeChange();\n          if (info.output) {\n            node.disconnectOutput(info.slot);\n          } else if (info.input) {\n            node.disconnectInput(info.slot);\n          }\n          node.graph.afterChange();\n          return;\n        } else if (v.content == \"Rename Slot\") {\n          info = v.slot;\n          var slot_info = info.input ? node.getInputInfo(info.slot) : node.getOutputInfo(info.slot);\n          var dialog = that.createDialog(\"<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>\", options);\n          var input = dialog.querySelector(\"input\");\n          if (input && slot_info) {\n            input.value = slot_info.label || \"\";\n          }\n          var inner = function inner() {\n            node.graph.beforeChange();\n            if (input.value) {\n              if (slot_info) {\n                slot_info.label = input.value;\n              }\n              that.setDirty(true);\n            }\n            dialog.close();\n            node.graph.afterChange();\n          };\n          dialog.querySelector(\"button\").addEventListener(\"click\", inner);\n          input.addEventListener(\"keydown\", function (e) {\n            dialog.is_modified = true;\n            if (e.keyCode == 27) {\n              // ESC\n              dialog.close();\n            } else if (e.keyCode == 13) {\n              inner(); // save\n            } else if (e.keyCode != 13 && e.target.localName != \"textarea\") {\n              return;\n            }\n            e.preventDefault();\n            e.stopPropagation();\n          });\n          input.focus();\n        }\n        // if(v.callback)\n        //\treturn v.callback.call(that, node, options, e, menu, that, event );\n      }\n    }\n  }, {\n    key: \"lowQualityRenderingRequired\",\n    value:\n    /**\r\n     * returns ture if low qualty rendering requered at requested scale\r\n     * */\n    function lowQualityRenderingRequired(activation_scale) {\n      if (this.ds.scale < activation_scale) {\n        return this.low_quality_rendering_counter > this.low_quality_rendering_threshold;\n      }\n      return false;\n    }\n  }], [{\n    key: \"getFileExtension\",\n    value: function getFileExtension(url) {\n      var urlObj = new URL(url);\n      var path = urlObj.pathname;\n      var lastDotIndex = path.lastIndexOf(\".\");\n      if (lastDotIndex === -1) {\n        return \"\";\n      }\n      return path.slice(lastDotIndex + 1).toLowerCase();\n    }\n  }, {\n    key: \"onGroupAdd\",\n    value: function onGroupAdd(info, entry, mouse_event) {\n      var canvas = LGraphCanvas.active_canvas;\n      var group = new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LGraphGroup();\n      group.pos = canvas.convertEventToCanvasOffset(mouse_event);\n      canvas.graph.add(group);\n    }\n\n    /**\r\n     * Determines the furthest nodes in each direction\r\n     * @param nodes {LGraphNode[]} the nodes to from which boundary nodes will be extracted\r\n     * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}\r\n     */\n  }, {\n    key: \"getBoundaryNodes\",\n    value: function getBoundaryNodes(nodes) {\n      var top = null;\n      var right = null;\n      var bottom = null;\n      var left = null;\n      for (var nID in nodes) {\n        var node = nodes[nID];\n        var _node$pos = _slicedToArray(node.pos, 2),\n          x = _node$pos[0],\n          y = _node$pos[1];\n        var _node$size = _slicedToArray(node.size, 2),\n          width = _node$size[0],\n          height = _node$size[1];\n        if (top === null || y < top.pos[1]) {\n          top = node;\n        }\n        if (right === null || x + width > right.pos[0] + right.size[0]) {\n          right = node;\n        }\n        if (bottom === null || y + height > bottom.pos[1] + bottom.size[1]) {\n          bottom = node;\n        }\n        if (left === null || x < left.pos[0]) {\n          left = node;\n        }\n      }\n      return {\n        \"top\": top,\n        \"right\": right,\n        \"bottom\": bottom,\n        \"left\": left\n      };\n    }\n  }, {\n    key: \"alignNodes\",\n    value: function alignNodes(nodes, direction, align_to) {\n      if (!nodes) {\n        return;\n      }\n      var canvas = LGraphCanvas.active_canvas;\n      var boundaryNodes = [];\n      if (align_to === undefined) {\n        boundaryNodes = LGraphCanvas.getBoundaryNodes(nodes);\n      } else {\n        boundaryNodes = {\n          \"top\": align_to,\n          \"right\": align_to,\n          \"bottom\": align_to,\n          \"left\": align_to\n        };\n      }\n      for (var _i25 = 0, _Object$entries2 = Object.entries(canvas.selected_nodes); _i25 < _Object$entries2.length; _i25++) {\n        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i25], 2),\n          _ = _Object$entries2$_i[0],\n          node = _Object$entries2$_i[1];\n        switch (direction) {\n          case \"right\":\n            node.pos[0] = boundaryNodes[\"right\"].pos[0] + boundaryNodes[\"right\"].size[0] - node.size[0];\n            break;\n          case \"left\":\n            node.pos[0] = boundaryNodes[\"left\"].pos[0];\n            break;\n          case \"top\":\n            node.pos[1] = boundaryNodes[\"top\"].pos[1];\n            break;\n          case \"bottom\":\n            node.pos[1] = boundaryNodes[\"bottom\"].pos[1] + boundaryNodes[\"bottom\"].size[1] - node.size[1];\n            break;\n        }\n      }\n      canvas.dirty_canvas = true;\n      canvas.dirty_bgcanvas = true;\n    }\n  }, {\n    key: \"onNodeAlign\",\n    value: function onNodeAlign(value, options, event, prev_menu, node) {\n      new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu([\"Top\", \"Bottom\", \"Left\", \"Right\"], {\n        event: event,\n        callback: inner_clicked,\n        parentMenu: prev_menu\n      });\n      function inner_clicked(value) {\n        LGraphCanvas.alignNodes(LGraphCanvas.active_canvas.selected_nodes, value.toLowerCase(), node);\n      }\n    }\n  }, {\n    key: \"onGroupAlign\",\n    value: function onGroupAlign(value, options, event, prev_menu) {\n      new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu([\"Top\", \"Bottom\", \"Left\", \"Right\"], {\n        event: event,\n        callback: inner_clicked,\n        parentMenu: prev_menu\n      });\n      function inner_clicked(value) {\n        LGraphCanvas.alignNodes(LGraphCanvas.active_canvas.selected_nodes, value.toLowerCase());\n      }\n    }\n  }, {\n    key: \"onMenuAdd\",\n    value: function onMenuAdd(node, options, e, prev_menu, _callback) {\n      var canvas = LGraphCanvas.active_canvas;\n      var ref_window = canvas.getCanvasWindow();\n      var graph = canvas.graph;\n      if (!graph) return;\n      function inner_onMenuAdded(base_category, prev_menu) {\n        var categories = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getNodeTypesCategories(canvas.filter || graph.filter).filter(function (category) {\n          return category.startsWith(base_category);\n        });\n        var entries = [];\n        categories.map(function (category) {\n          if (!category) return;\n          var base_category_regex = new RegExp('^(' + base_category + ')');\n          var category_name = category.replace(base_category_regex, \"\").split('/')[0];\n          var category_path = base_category === '' ? category_name + '/' : base_category + category_name + '/';\n          var name = category_name;\n          if (name.indexOf(\"::\") != -1)\n            // in case it has a namespace like \"shader::math/rand\" it hides the namespace\n            name = name.split(\"::\")[1];\n          var index = entries.findIndex(function (entry) {\n            return entry.value === category_path;\n          });\n          if (index === -1) {\n            entries.push({\n              value: category_path,\n              content: name,\n              has_submenu: true,\n              callback: function callback(value, event, mouseEvent, contextMenu) {\n                inner_onMenuAdded(value.value, contextMenu);\n              }\n            });\n          }\n        });\n        var nodes = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getNodeTypesInCategory(base_category.slice(0, -1), canvas.filter || graph.filter);\n        nodes.map(function (node) {\n          if (node.skip_list) return;\n          var entry = {\n            value: node.type,\n            content: node.title,\n            has_submenu: false,\n            callback: function callback(value, event, mouseEvent, contextMenu) {\n              var first_event = contextMenu.getFirstEvent();\n              canvas.graph.beforeChange();\n              var node = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.createNode(value.value);\n              if (node) {\n                node.pos = canvas.convertEventToCanvasOffset(first_event);\n                canvas.graph.add(node);\n              }\n              if (_callback) _callback(node);\n              canvas.graph.afterChange();\n            }\n          };\n          entries.push(entry);\n        });\n        new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu(entries, {\n          event: e,\n          parentMenu: prev_menu\n        }, ref_window);\n      }\n      inner_onMenuAdded('', prev_menu);\n      return false;\n    }\n  }, {\n    key: \"onMenuCollapseAll\",\n    value: function onMenuCollapseAll() {}\n  }, {\n    key: \"onMenuNodeEdit\",\n    value: function onMenuNodeEdit() {}\n  }, {\n    key: \"showMenuNodeOptionalInputs\",\n    value: function showMenuNodeOptionalInputs(v, options, e, prev_menu, node) {\n      if (!node) {\n        return;\n      }\n      var that = this;\n      var canvas = LGraphCanvas.active_canvas;\n      var ref_window = canvas.getCanvasWindow();\n      options = node.optional_inputs;\n      if (node.onGetInputs) {\n        options = node.onGetInputs();\n      }\n      var entries = [];\n      if (options) {\n        for (var i = 0; i < options.length; i++) {\n          var entry = options[i];\n          if (!entry) {\n            entries.push(null);\n            continue;\n          }\n          var label = entry[0];\n          if (!entry[2]) entry[2] = {};\n          if (entry[2].label) {\n            label = entry[2].label;\n          }\n          entry[2].removable = true;\n          var data = {\n            content: label,\n            value: entry\n          };\n          if (entry[1] == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION) {\n            data.className = \"event\";\n          }\n          entries.push(data);\n        }\n      }\n      if (node.onMenuNodeInputs) {\n        var retEntries = node.onMenuNodeInputs(entries);\n        if (retEntries) entries = retEntries;\n      }\n      if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.do_add_triggers_slots) {\n        // canvas.allow_addOutSlot_onExecuted\n        if (node.findInputSlot(\"onTrigger\") == -1) {\n          entries.push({\n            content: \"On Trigger\",\n            value: [\"onTrigger\", _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT, {\n              nameLocked: true,\n              removable: true\n            }],\n            className: \"event\"\n          }); // , opts: {}\n        }\n      }\n      if (!entries.length) {\n        var _LiteGraph$log4;\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) (_LiteGraph$log4 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log4 === void 0 || _LiteGraph$log4.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"no input entries\");\n        return;\n      }\n      new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu(entries, {\n        event: e,\n        callback: inner_clicked,\n        parentMenu: prev_menu,\n        node: node\n      }, ref_window);\n      function inner_clicked(v, e, prev) {\n        if (!node) {\n          return;\n        }\n        if (v.callback) {\n          v.callback.call(that, node, v, e, prev);\n        }\n        if (v.value) {\n          var _node$onNodeInputAdd;\n          node.graph.beforeChange();\n          var slotOpts = {}; // TODO CHECK THIS :: can be removed: removabled:true? .. optional: true?\n          if (v.value[2]) slotOpts = Object.assign(slotOpts, v.value[2]);\n          node.addInput(v.value[0], v.value[1], slotOpts);\n          (_node$onNodeInputAdd = node.onNodeInputAdd) === null || _node$onNodeInputAdd === void 0 || _node$onNodeInputAdd.call(node, v.value);\n          node.setDirtyCanvas(true, true);\n          node.graph.afterChange();\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"showMenuNodeOptionalOutputs\",\n    value: function showMenuNodeOptionalOutputs(v, options, e, prev_menu, node) {\n      if (!node) {\n        return;\n      }\n      var that = this;\n      var canvas = LGraphCanvas.active_canvas;\n      var ref_window = canvas.getCanvasWindow();\n      options = node.optional_outputs;\n      if (node.onGetOutputs) {\n        options = node.onGetOutputs();\n      }\n      var entries = [];\n      if (options) {\n        for (var i = 0; i < options.length; i++) {\n          var entry = options[i];\n          if (!entry) {\n            // separator?\n            entries.push(null);\n            continue;\n          }\n          if (node.flags && node.flags.skip_repeated_outputs && node.findOutputSlot(entry[0]) != -1) {\n            continue;\n          } // skip the ones already on\n          var label = entry[0];\n          if (!entry[2]) entry[2] = {};\n          if (entry[2].label) {\n            label = entry[2].label;\n          }\n          entry[2].removable = true;\n          var data = {\n            content: label,\n            value: entry\n          };\n          if (entry[1] == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT) {\n            data.className = \"event\";\n          }\n          entries.push(data);\n        }\n      }\n      if (this.onMenuNodeOutputs) {\n        entries = this.onMenuNodeOutputs(entries);\n      }\n      if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.do_add_triggers_slots) {\n        // canvas.allow_addOutSlot_onExecuted\n        if (node.findOutputSlot(\"onExecuted\") == -1) {\n          entries.push({\n            content: \"On Executed\",\n            value: [\"onExecuted\", _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT, {\n              nameLocked: true,\n              removable: true\n            }],\n            className: \"event\"\n          });\n        }\n      }\n      // add callback for modifing the menu elements onMenuNodeOutputs\n      if (node.onMenuNodeOutputs) {\n        var retEntries = node.onMenuNodeOutputs(entries);\n        if (retEntries) entries = retEntries;\n      }\n      if (!entries.length) {\n        return;\n      }\n      new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu(entries, {\n        event: e,\n        callback: inner_clicked,\n        parentMenu: prev_menu,\n        node: node\n      }, ref_window);\n      function inner_clicked(v, e, prev) {\n        if (!node) {\n          return;\n        }\n        if (v.callback) {\n          v.callback.call(that, node, v, e, prev);\n        }\n        if (!v.value) {\n          return;\n        }\n        var value = v.value[1];\n        if (value && (value.constructor === Object || value.constructor === Array)) {\n          // submenu why?\n          var entries = [];\n          for (var _i26 in value) {\n            entries.push({\n              content: _i26,\n              value: value[_i26]\n            });\n          }\n          new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu(entries, {\n            event: e,\n            callback: inner_clicked,\n            parentMenu: prev_menu,\n            node: node\n          });\n          return false;\n        } else {\n          var _node$onNodeOutputAdd;\n          node.graph.beforeChange();\n          var slotOpts = {}; // TODO CHECK THIS :: can be removed: removabled:true? .. optional: true?\n          if (v.value[2]) slotOpts = Object.assign(slotOpts, v.value[2]);\n          // if(v.opts) slotOpts = Object.assign(slotOpts, v.opts);\n\n          node.addOutput(v.value[0], v.value[1], slotOpts);\n          (_node$onNodeOutputAdd = node.onNodeOutputAdd) === null || _node$onNodeOutputAdd === void 0 || _node$onNodeOutputAdd.call(node, v.value); // a callback to the node when adding a slot\n          node.setDirtyCanvas(true, true);\n          node.graph.afterChange();\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"onShowMenuNodeProperties\",\n    value: function onShowMenuNodeProperties(value, options, e, prev_menu, node) {\n      if (!node || !node.properties) {\n        return;\n      }\n      var canvas = LGraphCanvas.active_canvas;\n      var ref_window = canvas.getCanvasWindow();\n      var entries = [];\n      for (var i in node.properties) {\n        value = node.properties[i] !== undefined ? node.properties[i] : \" \";\n        if (_typeof(value) == \"object\") value = JSON.stringify(value);\n        var info = node.getPropertyInfo(i);\n        if (info.type == \"enum\" || info.type == \"combo\") value = LGraphCanvas.getPropertyPrintableValue(value, info.values);\n\n        // value could contain invalid html characters, clean that\n        value = LGraphCanvas.decodeHTML(value);\n        entries.push({\n          content: \"<span class='property_name'>\" + (info.label ? info.label : i) + \"</span>\" + \"<span class='property_value'>\" + value + \"</span>\",\n          value: i\n        });\n      }\n      if (!entries.length) {\n        return;\n      }\n      new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu(entries, {\n        event: e,\n        callback: inner_clicked,\n        parentMenu: prev_menu,\n        allow_html: true,\n        node: node\n      }, ref_window);\n      function inner_clicked(v) {\n        if (!node) {\n          return;\n        }\n        var rect = this.getBoundingClientRect();\n        canvas.showEditPropertyValue(node, v.value, {\n          position: [rect.left, rect.top]\n        });\n      }\n      return false;\n    }\n  }, {\n    key: \"decodeHTML\",\n    value: function decodeHTML(str) {\n      var e = document.createElement(\"div\");\n      e.innerText = str;\n      return e.innerHTML;\n    }\n  }, {\n    key: \"onMenuResizeNode\",\n    value: function onMenuResizeNode(value, options, e, menu, node) {\n      if (!node) {\n        return;\n      }\n      var fApplyMultiNode = function fApplyMultiNode(node) {\n        node.size = node.computeSize();\n        if (node.onResize) node.onResize(node.size);\n      };\n      var graphcanvas = LGraphCanvas.active_canvas;\n      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n        fApplyMultiNode(node);\n      } else {\n        for (var i in graphcanvas.selected_nodes) {\n          fApplyMultiNode(graphcanvas.selected_nodes[i]);\n        }\n      }\n      node.setDirtyCanvas(true, true);\n    }\n  }, {\n    key: \"onShowPropertyEditor\",\n    value: function onShowPropertyEditor(item, options, e, menu, node) {\n      var property = item.property || \"title\";\n      var value = node[property];\n\n      // TODO refactor :: use createDialog ?\n\n      var dialog = document.createElement(\"div\");\n      dialog.is_modified = false;\n      dialog.className = \"graphdialog\";\n      dialog.innerHTML = \"<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>\";\n      dialog.close = function () {\n        var _dialog$parentNode2;\n        (_dialog$parentNode2 = dialog.parentNode) === null || _dialog$parentNode2 === void 0 || _dialog$parentNode2.removeChild(dialog);\n      };\n      var title = dialog.querySelector(\".name\");\n      title.innerText = property;\n      var input = dialog.querySelector(\".value\");\n      var inner = function inner() {\n        if (input) {\n          setValue(input.value);\n        }\n      };\n      if (input) {\n        input.value = value;\n        input.addEventListener(\"blur\", function (_event) {\n          this.focus();\n        });\n        input.addEventListener(\"keydown\", function (e) {\n          dialog.is_modified = true;\n          if (e.keyCode == 27) {\n            // ESC\n            dialog.close();\n          } else if (e.keyCode == 13) {\n            inner(); // save\n          } else if (e.keyCode != 13 && e.target.localName != \"textarea\") {\n            return;\n          }\n          e.preventDefault();\n          e.stopPropagation();\n        });\n      }\n      var graphcanvas = LGraphCanvas.active_canvas;\n      var canvas = graphcanvas.canvas;\n      var rect = canvas.getBoundingClientRect();\n      var offsetx = -20;\n      var offsety = -20;\n      if (rect) {\n        offsetx -= rect.left;\n        offsety -= rect.top;\n      }\n      if (event) {\n        dialog.style.left = event.clientX + offsetx + \"px\";\n        dialog.style.top = event.clientY + offsety + \"px\";\n      } else {\n        dialog.style.left = canvas.width * 0.5 + offsetx + \"px\";\n        dialog.style.top = canvas.height * 0.5 + offsety + \"px\";\n      }\n      var button = dialog.querySelector(\"button\");\n      button.addEventListener(\"click\", inner);\n      canvas.parentNode.appendChild(dialog);\n      if (input) input.focus();\n      var dialogCloseTimer = null;\n      dialog.addEventListener(\"pointerleave\", function (_event) {\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.dialog_close_on_mouse_leave && !dialog.is_modified) {\n          dialogCloseTimer = setTimeout(dialog.close, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.dialog_close_on_mouse_leave_delay);\n        }\n      });\n      dialog.addEventListener(\"pointerenter\", function (_event) {\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.dialog_close_on_mouse_leave && dialogCloseTimer) {\n          clearTimeout(dialogCloseTimer);\n        }\n      });\n      var setValue = function setValue(value) {\n        var _dialog$parentNode3;\n        switch (item.type) {\n          case \"Number\":\n            value = Number(value);\n            break;\n          case \"Boolean\":\n            value = Boolean(value);\n            break;\n        }\n        node[property] = value;\n        (_dialog$parentNode3 = dialog.parentNode) === null || _dialog$parentNode3 === void 0 || _dialog$parentNode3.removeChild(dialog);\n        node.setDirtyCanvas(true, true);\n      };\n    }\n  }, {\n    key: \"getPropertyPrintableValue\",\n    value: function getPropertyPrintableValue(value, values) {\n      if (!values) return String(value);\n      if (values.constructor === Array) {\n        return String(value);\n      }\n      if (values.constructor === Object) {\n        var desc_value = \"\";\n        for (var k in values) {\n          if (values[k] != value) continue;\n          desc_value = k;\n          break;\n        }\n        return String(value) + \" (\" + desc_value + \")\";\n      }\n    }\n  }, {\n    key: \"onMenuNodeCollapse\",\n    value: function onMenuNodeCollapse(value, options, e, menu, node) {\n      node.graph.beforeChange( /* ?*/);\n      var fApplyMultiNode = function fApplyMultiNode(node) {\n        node.collapse();\n      };\n      var graphcanvas = LGraphCanvas.active_canvas;\n      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n        fApplyMultiNode(node);\n      } else {\n        for (var i in graphcanvas.selected_nodes) {\n          fApplyMultiNode(graphcanvas.selected_nodes[i]);\n        }\n      }\n      node.graph.afterChange( /* ?*/);\n    }\n  }, {\n    key: \"onMenuNodePin\",\n    value: function onMenuNodePin(value, options, e, menu, node) {\n      node.pin();\n    }\n  }, {\n    key: \"onMenuNodeMode\",\n    value: function onMenuNodeMode(value, options, e, menu, node) {\n      new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_MODES, {\n        event: e,\n        callback: inner_clicked,\n        parentMenu: menu,\n        node: node\n      });\n      function inner_clicked(v) {\n        if (!node) {\n          return;\n        }\n        var kV = Object.values(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_MODES).indexOf(v);\n        var fApplyMultiNode = function fApplyMultiNode(node) {\n          if (kV >= 0 && _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_MODES[kV]) node.changeMode(kV);else {\n            var _LiteGraph$warn19;\n            (_LiteGraph$warn19 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn19 === void 0 || _LiteGraph$warn19.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"unexpected mode: \" + v);\n            node.changeMode(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ALWAYS);\n          }\n        };\n        var graphcanvas = LGraphCanvas.active_canvas;\n        if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n          fApplyMultiNode(node);\n        } else {\n          for (var i in graphcanvas.selected_nodes) {\n            fApplyMultiNode(graphcanvas.selected_nodes[i]);\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"onMenuNodeColors\",\n    value: function onMenuNodeColors(value, options, e, menu, node) {\n      if (!node) {\n        throw new Error(\"no node for color\");\n      }\n      var values = [];\n      values.push({\n        value: null,\n        content: \"<span style='display: block; padding-left: 4px;'>No color</span>\"\n      });\n      for (var i in LGraphCanvas.node_colors) {\n        var color = LGraphCanvas.node_colors[i];\n        value = {\n          value: i,\n          content: \"<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid \" + color.color + \"; background-color:\" + color.bgcolor + \"'>\" + i + \"</span>\"\n        };\n        values.push(value);\n      }\n      new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu(values, {\n        event: e,\n        callback: inner_clicked,\n        parentMenu: menu,\n        node: node\n      });\n      function inner_clicked(v) {\n        if (!node) {\n          return;\n        }\n        var color = v.value ? LGraphCanvas.node_colors[v.value] : null;\n        var fApplyColor = function fApplyColor(node) {\n          if (color) {\n            if (node.constructor === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LGraphGroup) {\n              node.color = color.groupcolor;\n            } else {\n              node.color = color.color;\n              node.bgcolor = color.bgcolor;\n            }\n          } else {\n            delete node.color;\n            delete node.bgcolor;\n          }\n        };\n        var graphcanvas = LGraphCanvas.active_canvas;\n        if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n          fApplyColor(node);\n        } else {\n          for (var _i27 in graphcanvas.selected_nodes) {\n            fApplyColor(graphcanvas.selected_nodes[_i27]);\n          }\n        }\n        node.setDirtyCanvas(true, true);\n      }\n      return false;\n    }\n  }, {\n    key: \"onMenuNodeShapes\",\n    value: function onMenuNodeShapes(value, options, e, menu, node) {\n      if (!node) {\n        throw new Error(\"no node passed\");\n      }\n      new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ContextMenu(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.VALID_SHAPES, {\n        event: e,\n        callback: inner_clicked,\n        parentMenu: menu,\n        node: node\n      });\n      function inner_clicked(v) {\n        if (!node) {\n          return;\n        }\n        node.graph.beforeChange( /* ?*/); // node\n\n        var fApplyMultiNode = function fApplyMultiNode(node) {\n          node.shape = v;\n        };\n        var graphcanvas = LGraphCanvas.active_canvas;\n        if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n          fApplyMultiNode(node);\n        } else {\n          for (var i in graphcanvas.selected_nodes) {\n            fApplyMultiNode(graphcanvas.selected_nodes[i]);\n          }\n        }\n        node.graph.afterChange( /* ?*/); // node\n        node.setDirtyCanvas(true);\n      }\n      return false;\n    }\n  }, {\n    key: \"onMenuNodeRemove\",\n    value: function onMenuNodeRemove(value, options, e, menu, node) {\n      if (!node) {\n        throw new Error(\"no node passed\");\n      }\n      var graph = node.graph;\n      graph.beforeChange();\n      var fApplyMultiNode = function fApplyMultiNode(node) {\n        if (node.removable === false) {\n          return;\n        }\n        graph.remove(node);\n      };\n      var graphcanvas = LGraphCanvas.active_canvas;\n      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n        fApplyMultiNode(node);\n      } else {\n        for (var i in graphcanvas.selected_nodes) {\n          fApplyMultiNode(graphcanvas.selected_nodes[i]);\n        }\n      }\n      graph.afterChange();\n      node.setDirtyCanvas(true, true);\n    }\n  }, {\n    key: \"onMenuNodeToSubgraph\",\n    value: function onMenuNodeToSubgraph(value, options, e, menu, node) {\n      var graph = node.graph;\n      var graphcanvas = LGraphCanvas.active_canvas;\n      if (!graphcanvas)\n        // ??\n        return;\n      var nodes_list = Object.values(graphcanvas.selected_nodes || {});\n      if (!nodes_list.length) nodes_list = [node];\n      var subgraph_node = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.createNode(\"graph/subgraph\");\n      subgraph_node.pos = node.pos.concat();\n      graph.add(subgraph_node);\n      subgraph_node.buildFromNodes(nodes_list);\n      graphcanvas.deselectAllNodes();\n      node.setDirtyCanvas(true, true);\n    }\n  }, {\n    key: \"onMenuNodeClone\",\n    value: function onMenuNodeClone(value, options, e, menu, node) {\n      node.graph.beforeChange();\n      var newSelected = {};\n      var fApplyMultiNode = function fApplyMultiNode(node) {\n        if (node.clonable === false) {\n          return;\n        }\n        var newnode = node.clone();\n        if (!newnode) {\n          return;\n        }\n        newnode.pos = [node.pos[0] + 5, node.pos[1] + 5];\n        node.graph.add(newnode);\n        newSelected[newnode.id] = newnode;\n      };\n      var graphcanvas = LGraphCanvas.active_canvas;\n      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n        fApplyMultiNode(node);\n      } else {\n        for (var i in graphcanvas.selected_nodes) {\n          fApplyMultiNode(graphcanvas.selected_nodes[i]);\n        }\n      }\n      if (Object.keys(newSelected).length) {\n        graphcanvas.selectNodes(newSelected);\n      }\n      node.graph.afterChange();\n      node.setDirtyCanvas(true, true);\n    }\n  }]);\n}();\n\n/* LGraphCanvas render */\n_defineProperty(LGraphCanvas, \"DEFAULT_BACKGROUND_IMAGE\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=\");\n_defineProperty(LGraphCanvas, \"link_type_colors\", {\n  \"-1\": \"#A86\",\n  \"number\": \"#AAA\",\n  \"node\": \"#DCA\",\n  \"string\": \"#77F\",\n  \"boolean\": \"#F77\"\n});\n_defineProperty(LGraphCanvas, \"gradients\", {});\n// cache of gradients\n_defineProperty(LGraphCanvas, \"search_limit\", -1);\n_defineProperty(LGraphCanvas, \"node_colors\", {\n  red: {\n    color: \"#322\",\n    bgcolor: \"#533\",\n    groupcolor: \"#A88\"\n  },\n  brown: {\n    color: \"#332922\",\n    bgcolor: \"#593930\",\n    groupcolor: \"#b06634\"\n  },\n  green: {\n    color: \"#232\",\n    bgcolor: \"#353\",\n    groupcolor: \"#8A8\"\n  },\n  blue: {\n    color: \"#223\",\n    bgcolor: \"#335\",\n    groupcolor: \"#88A\"\n  },\n  pale_blue: {\n    color: \"#2a363b\",\n    bgcolor: \"#3f5159\",\n    groupcolor: \"#3f789e\"\n  },\n  cyan: {\n    color: \"#233\",\n    bgcolor: \"#355\",\n    groupcolor: \"#8AA\"\n  },\n  purple: {\n    color: \"#323\",\n    bgcolor: \"#535\",\n    groupcolor: \"#a1309b\"\n  },\n  yellow: {\n    color: \"#432\",\n    bgcolor: \"#653\",\n    groupcolor: \"#b58b2a\"\n  },\n  black: {\n    color: \"#222\",\n    bgcolor: \"#000\",\n    groupcolor: \"#444\"\n  }\n});\nvar temp = new Float32Array(4);\nvar temp_vec2 = new Float32Array(2);\n\n/**\r\n * draws the shape of the given node in the canvas\r\n * @method drawNodeShape\r\n **/\nvar tmp_area = new Float32Array(4);\nvar margin_area = new Float32Array(4);\nvar link_bounding = new Float32Array(4);\nvar tempA = new Float32Array(2);\nvar tempB = new Float32Array(2);\n\n//# sourceURL=webpack://LiteGraphJS/./src/lgraphcanvas.js?");

/***/ }),

/***/ "./src/lgraphgroup.js":
/*!****************************!*\
  !*** ./src/lgraphgroup.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LGraphGroup: () => (/* binding */ LGraphGroup)\n/* harmony export */ });\n/* harmony import */ var _litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./litegraph.js */ \"./src/litegraph.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LGraphGroup = /*#__PURE__*/function () {\n  /**\r\n   * Constructor for the LGraphGroup class.\r\n   * @param {string} [title=\"Group\"] - The title of the group.\r\n   */\n  function LGraphGroup() {\n    var _LiteGraph$LGraphCanv, _LiteGraph$LGraphCanv2;\n    var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Group\";\n    _classCallCheck(this, LGraphGroup);\n    _defineProperty(this, \"isPointInside\", _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LGraphNode.prototype.isPointInside);\n    _defineProperty(this, \"setDirtyCanvas\", _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LGraphNode.prototype.setDirtyCanvas);\n    this.title = title;\n    this.font_size = 24;\n    this.color = (_LiteGraph$LGraphCanv = (_LiteGraph$LGraphCanv2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LGraphCanvas.node_colors.pale_blue) === null || _LiteGraph$LGraphCanv2 === void 0 ? void 0 : _LiteGraph$LGraphCanv2.groupcolor) !== null && _LiteGraph$LGraphCanv !== void 0 ? _LiteGraph$LGraphCanv : \"#AAA\";\n    this._bounding = new Float32Array([10, 10, 140, 80]);\n    this._pos = this._bounding.subarray(0, 2);\n    this._size = this._bounding.subarray(2, 4);\n    this._nodes = [];\n    this.graph = null;\n  }\n  return _createClass(LGraphGroup, [{\n    key: \"pos\",\n    get: function get() {\n      return this._pos;\n    },\n    set: function set(v) {\n      if (!v || v.length < 2) {\n        return;\n      }\n      this._pos[0] = v[0];\n      this._pos[1] = v[1];\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._size;\n    }\n\n    /**\r\n     * Updates the properties of the LGraphGroup instance based on the provided configuration object.\r\n     * @param {Object} o - The configuration object with properties to update.\r\n     * @param {string} o.title - The new title for the group.\r\n     * @param {Float32Array} o.bounding - The new bounding box for the group.\r\n     * @param {string} o.color - The new color for the group.\r\n     * @param {number} o.font_size - The new font size for the group.\r\n     */,\n    set: function set(v) {\n      if (!v || v.length < 2) {\n        return;\n      }\n      this._size[0] = Math.max(140, v[0]);\n      this._size[1] = Math.max(80, v[1]);\n    }\n  }, {\n    key: \"configure\",\n    value: function configure(o) {\n      this.title = o.title;\n      this._bounding.set(o.bounding);\n      this.color = o.color;\n      if (o.font_size) this.font_size = o.font_size;\n    }\n\n    /**\r\n     * Serializes the LGraphGroup instance into a plain JavaScript object.\r\n     * @returns {Object} - The serialized representation of the LGraphGroup instance.\r\n     * - title: string - The title of the group.\r\n     * - bounding: Array<number> - The bounding box coordinates [x, y, width, height].\r\n     * - color: string - The color of the group.\r\n     * - font_size: number - The font size of the group.\r\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var b = this._bounding;\n      return {\n        title: this.title,\n        bounding: b.map(function (value) {\n          return Math.round(value);\n        }),\n        color: this.color,\n        font_size: this.font_size\n      };\n    }\n\n    /**\r\n     * Moves the LGraphGroup instance by the specified deltas and optionally updates the positions of contained nodes.\r\n     * @param {number} deltax - The amount to move the group along the x-axis.\r\n     * @param {number} deltay - The amount to move the group along the y-axis.\r\n     * @param {boolean} ignore_nodes - Flag to indicate whether to move contained nodes along with the group.\r\n     */\n  }, {\n    key: \"move\",\n    value: function move(deltax, deltay, ignore_nodes) {\n      var _console$error, _console, _console$error2, _console2;\n      if (isNaN(deltax)) (_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, \"LGraphGroup.move() deltax NaN\");\n      if (isNaN(deltay)) (_console$error2 = (_console2 = console).error) === null || _console$error2 === void 0 || _console$error2.call(_console2, \"LGraphGroup.move() deltay NaN\");\n      this._pos[0] += deltax;\n      this._pos[1] += deltay;\n      if (ignore_nodes) {\n        return;\n      }\n      this._nodes.forEach(function (node) {\n        node.pos[0] += deltax;\n        node.pos[1] += deltay;\n      });\n    }\n\n    /**\r\n     * Recomputes and updates the list of nodes inside the LGraphGroup based on their bounding boxes.\r\n     * This method checks for nodes that overlap with the group's bounding box and updates the internal nodes list accordingly.\r\n     */\n  }, {\n    key: \"recomputeInsideNodes\",\n    value: function recomputeInsideNodes() {\n      var _this = this;\n      this._nodes.length = 0;\n      var nodes = this.graph._nodes;\n      var node_bounding = new Float32Array(4);\n      this._nodes = nodes.filter(function (node) {\n        node.getBounding(node_bounding);\n        return _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.overlapBounding(_this._bounding, node_bounding);\n      });\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://LiteGraphJS/./src/lgraphgroup.js?");

/***/ }),

/***/ "./src/lgraphnode.js":
/*!***************************!*\
  !*** ./src/lgraphnode.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LGraphNode: () => (/* binding */ LGraphNode)\n/* harmony export */ });\n/* harmony import */ var _litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./litegraph.js */ \"./src/litegraph.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/*\r\ntitle: string\r\npos: [x,y]\r\nsize: [x,y]\r\n\r\ninput|output: every connection\r\n    +  { name:string, type:string, pos: [x,y]=Optional, direction: \"input\"|\"output\", links: Array });\r\n\r\ngeneral properties:\r\n    + clip_area: if you render outside the node, it will be clipped\r\n    + unsafe_execution: not allowed for safe execution\r\n    + skip_repeated_outputs: when adding new outputs, it wont show if there is one already connected\r\n    + resizable: if set to false it wont be resizable with the mouse\r\n    + horizontal: slots are distributed horizontally\r\n    + widgets_start_y: widgets start at y distance from the top of the node\r\n\r\nflags object:\r\n    + collapsed: if it is collapsed\r\n\r\nsupported callbacks:\r\n    + onAdded: when added to graph (warning: this is called BEFORE the node is configured when loading)\r\n    + onRemoved: when removed from graph\r\n    + onStart:\twhen the graph starts playing\r\n    + onStop:\twhen the graph stops playing\r\n    + onDrawForeground: render the inside widgets inside the node\r\n    + onDrawBackground: render the background area inside the node (only in edit mode)\r\n    + onMouseDown\r\n    + onMouseMove\r\n    + onMouseUp\r\n    + onMouseEnter\r\n    + onMouseLeave\r\n    + onExecute: execute the node\r\n    + onPropertyChanged: when a property is changed in the panel (return true to skip default behaviour)\r\n    + onGetInputs: returns an array of possible inputs\r\n    + onGetOutputs: returns an array of possible outputs\r\n    + onBounding: in case this node has a bigger bounding than the node itself (the callback receives the bounding as [x,y,w,h])\r\n    + onDblClick: double clicked in the node\r\n    + onInputDblClick: input slot double clicked (can be used to automatically create a node connected)\r\n    + onOutputDblClick: output slot double clicked (can be used to automatically create a node connected)\r\n    + onConfigure: called after the node has been configured\r\n    + onSerialize: to add extra info when serializing (the callback receives the object that should be filled with the data)\r\n    + onSelected\r\n    + onDeselected\r\n    + onDropItem : DOM item dropped over the node\r\n    + onDropFile : file dropped over the node\r\n    + onConnectInput : if returns false the incoming connection will be canceled\r\n    + onConnectionsChange : a connection changed (new one or removed) (LiteGraph.INPUT or LiteGraph.OUTPUT, slot, true if connected, link_info, input_info )\r\n    + onAction: action slot triggered\r\n    + getExtraMenuOptions: to add option to context menu\r\n*/\n\n/**\r\n * Base Class for all the node type classes\r\n * @class LGraphNode\r\n * @param {String} name a name for the node\r\n */\n\nvar LGraphNode = /*#__PURE__*/function () {\n  function LGraphNode() {\n    var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Unnamed\";\n    _classCallCheck(this, LGraphNode);\n    this.title = title;\n    this.size = [_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_WIDTH, 60];\n    this.graph = null;\n    this._pos = new Float32Array(10, 10);\n    if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.use_uuids) {\n      this.id = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.uuidv4();\n    } else {\n      this.id = -1; // not know till not added\n    }\n    this.type = null;\n\n    // inputs available: array of inputs\n    this.inputs = [];\n    this.outputs = [];\n    this.connections = [];\n\n    // local data\n    this.properties = {}; // for the values\n    this.properties_info = []; // for the info\n\n    this.flags = {};\n  }\n  return _createClass(LGraphNode, [{\n    key: \"pos\",\n    get: function get() {\n      return this._pos;\n    }\n\n    /**\r\n     * configure a node from an object containing the serialized info\r\n     * @method configure\r\n     */,\n    set: function set(v) {\n      var _this$_pos;\n      if (!v || v.length < 2) {\n        return;\n      }\n      (_this$_pos = this._pos) !== null && _this$_pos !== void 0 ? _this$_pos : this._pos = new Float32Array(10, 10);\n      this._pos[0] = v[0];\n      this._pos[1] = v[1];\n    }\n  }, {\n    key: \"configure\",\n    value: function configure(info) {\n      var _this = this,\n        _this$inputs,\n        _this$outputs,\n        _this$onConfigure,\n        _this$graph;\n      /* @TODO: Atlasan has this commented, not sure if it stays that way\r\n      if(this.graph)\r\n          this.graph.onGraphChanged({action: \"nodeConfigure\", doSave: false});\r\n      */\n\n      Object.entries(info).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          key = _ref2[0],\n          value = _ref2[1];\n        if (key === \"properties\") {\n          for (var k in value) {\n            var _this$onPropertyChang;\n            _this.properties[k] = value[k];\n            (_this$onPropertyChang = _this.onPropertyChanged) === null || _this$onPropertyChang === void 0 || _this$onPropertyChang.call(_this, k, value[k]);\n          }\n          return;\n        }\n        if (value === null) {\n          return;\n        } else if (_typeof(value) === \"object\") {\n          if (_this[key] && _this[key].configure) {\n            _this[key].configure(value);\n          } else {\n            _this[key] = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.cloneObject(value, _this[key]);\n          }\n        } else {\n          _this[key] = value;\n        }\n      });\n      if (!info.title) {\n        this.title = this.constructor.title;\n      }\n      (_this$inputs = this.inputs) === null || _this$inputs === void 0 || _this$inputs.forEach(function (input, i) {\n        var _this$onConnectionsCh, _this$onInputAdded;\n        if (!input.link) return;\n        var link_info = _this.graph ? _this.graph.links[input.link] : null;\n        (_this$onConnectionsCh = _this.onConnectionsChange) === null || _this$onConnectionsCh === void 0 || _this$onConnectionsCh.call(_this, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.INPUT, i, true, link_info, input);\n        (_this$onInputAdded = _this.onInputAdded) === null || _this$onInputAdded === void 0 || _this$onInputAdded.call(_this, input);\n      });\n      (_this$outputs = this.outputs) === null || _this$outputs === void 0 || _this$outputs.forEach(function (output, i) {\n        var _this$onOutputAdded;\n        if (!output.links) return;\n        output.links.forEach(function () {\n          var _this$onConnectionsCh2;\n          var link_info = _this.graph; // ?.links[link] || null; // as per Atlasan\n          (_this$onConnectionsCh2 = _this.onConnectionsChange) === null || _this$onConnectionsCh2 === void 0 || _this$onConnectionsCh2.call(_this, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.OUTPUT, i, true, link_info, output);\n        });\n        (_this$onOutputAdded = _this.onOutputAdded) === null || _this$onOutputAdded === void 0 || _this$onOutputAdded.call(_this, output);\n      });\n      if (this.widgets) {\n        var _info$widgets_values;\n        this.widgets.forEach(function (w) {\n          if (!w) {\n            return;\n          }\n          if (w.options && w.options.property && _this.properties[w.options.property] !== undefined) {\n            w.value = JSON.parse(JSON.stringify(_this.properties[w.options.property]));\n          }\n        });\n        (_info$widgets_values = info.widgets_values) === null || _info$widgets_values === void 0 || _info$widgets_values.forEach(function (value, i) {\n          if (_this.widgets[i]) {\n            _this.widgets[i].value = value;\n          }\n        });\n      }\n      (_this$onConfigure = this.onConfigure) === null || _this$onConfigure === void 0 || _this$onConfigure.call(this, info);\n      (_this$graph = this.graph) === null || _this$graph === void 0 || _this$graph.onGraphChanged({\n        action: \"nodeConfigure\",\n        doSave: false\n      });\n    }\n\n    /**\r\n     * serialize the content\r\n     * @method serialize\r\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var _o$type, _this$onSerialize;\n      // create serialization object\n      var o = {\n        id: this.id,\n        type: this.type,\n        pos: this.pos,\n        size: this.size,\n        flags: _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.cloneObject(this.flags),\n        order: this.order,\n        mode: this.mode\n      };\n\n      // special case for when there were errors\n      if (this.constructor === LGraphNode && this.last_serialization) {\n        return this.last_serialization;\n      }\n      if (this.inputs) {\n        o.inputs = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.cloneObject(this.inputs);\n      }\n      if (this.outputs) {\n        // clear outputs last data (because data in connections is never serialized but stored inside the outputs info)\n        this.outputs.forEach(function (output) {\n          delete output._data;\n        });\n        o.outputs = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.cloneObject(this.outputs);\n      }\n      if (this.title && this.title != this.constructor.title) {\n        o.title = this.title;\n      }\n      if (this.properties) {\n        o.properties = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.cloneObject(this.properties);\n      }\n      if (this.widgets && this.serialize_widgets) {\n        o.widgets_values = this.widgets.map(function (widget) {\n          var _widget$value;\n          return (_widget$value = widget === null || widget === void 0 ? void 0 : widget.value) !== null && _widget$value !== void 0 ? _widget$value : null;\n        });\n      }\n      (_o$type = o.type) !== null && _o$type !== void 0 ? _o$type : o.type = this.constructor.type;\n      if (this.color) {\n        o.color = this.color;\n      }\n      if (this.bgcolor) {\n        o.bgcolor = this.bgcolor;\n      }\n      if (this.boxcolor) {\n        o.boxcolor = this.boxcolor;\n      }\n      if (this.shape) {\n        o.shape = this.shape;\n      }\n      if ((_this$onSerialize = this.onSerialize) !== null && _this$onSerialize !== void 0 && _this$onSerialize.call(this, o)) {\n        var _LiteGraph$warn;\n        (_LiteGraph$warn = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn === void 0 || _LiteGraph$warn.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter\");\n      }\n      return o;\n    }\n\n    /* Creates a clone of this node */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var _data$inputs, _data$outputs;\n      var node = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.createNode(this.type);\n      if (!node) {\n        return null;\n      }\n\n      // we clone it because serialize returns shared containers\n      var data = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.cloneObject(this.serialize());\n\n      // remove links\n      (_data$inputs = data.inputs) === null || _data$inputs === void 0 || _data$inputs.forEach(function (input) {\n        input.link = null;\n      });\n      (_data$outputs = data.outputs) === null || _data$outputs === void 0 || _data$outputs.forEach(function (output) {\n        if (output.links) output.links.length = 0;\n      });\n      delete data[\"id\"];\n      if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.use_uuids) {\n        data[\"id\"] = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.uuidv4();\n      }\n\n      // remove links\n      node.configure(data);\n      return node;\n    }\n\n    /**\r\n     * serialize and stringify\r\n     * @method toString\r\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return JSON.stringify(this.serialize());\n    }\n\n    // LGraphNode.prototype.deserialize = function(info) {} //this cannot be done from within, must be done in LiteGraph\n\n    /**\r\n     * get the title string\r\n     * @method getTitle\r\n     */\n  }, {\n    key: \"getTitle\",\n    value: function getTitle() {\n      var _this$title;\n      return (_this$title = this.title) !== null && _this$title !== void 0 ? _this$title : this.constructor.title;\n    }\n\n    /**\r\n     * sets the value of a property\r\n     * @method setProperty\r\n     * @param {String} name\r\n     * @param {*} value\r\n     */\n  }, {\n    key: \"setProperty\",\n    value: function setProperty(name, value) {\n      var _this$onPropertyChang2, _this$widgets;\n      this.properties || (this.properties = {});\n\n      // Check if the new value is the same as the current value\n      if (value === this.properties[name]) {\n        return;\n      }\n      var prevValue = this.properties[name];\n      this.properties[name] = value;\n\n      // Call onPropertyChanged and revert the change if needed\n      if (((_this$onPropertyChang2 = this.onPropertyChanged) === null || _this$onPropertyChang2 === void 0 ? void 0 : _this$onPropertyChang2.call(this, name, value, prevValue)) === false) {\n        this.properties[name] = prevValue;\n      }\n\n      // Update the widget value associated with the property name\n      var widgetToUpdate = (_this$widgets = this.widgets) === null || _this$widgets === void 0 ? void 0 : _this$widgets.find(function (widget) {\n        var _widget$options;\n        return widget && ((_widget$options = widget.options) === null || _widget$options === void 0 ? void 0 : _widget$options.property) === name;\n      });\n      if (widgetToUpdate) {\n        widgetToUpdate.value = value;\n      }\n    }\n\n    // Execution *************************\n    /**\r\n     * sets the output data\r\n     * @method setOutputData\r\n     * @param {number} slot\r\n     * @param {*} data\r\n     */\n  }, {\n    key: \"setOutputData\",\n    value: function setOutputData(slot, data) {\n      var _slot,\n        _this$outputs$slot$li,\n        _this2 = this;\n      if (!this.outputs) {\n        return;\n      }\n      if (((_slot = slot) === null || _slot === void 0 ? void 0 : _slot.constructor) === String) {\n        // not a niche case: consider that removable and optional slots will move indexes! just pass int value if preferred\n        slot = this.findOutputSlot(slot);\n      } else if (slot == -1 || slot >= this.outputs.length) {\n        return;\n      }\n      var output_info = this.outputs[slot];\n      if (!output_info) {\n        return;\n      }\n\n      // store data in the output itself in case we want to debug\n      output_info._data = data;\n\n      // if there are connections, pass the data to the connections\n      (_this$outputs$slot$li = this.outputs[slot].links) === null || _this$outputs$slot$li === void 0 || _this$outputs$slot$li.forEach(function (link_id) {\n        var link = _this2.graph.links[link_id];\n        if (link) {\n          link.data = data;\n        }\n      });\n    }\n\n    /**\r\n     * sets the output data type, useful when you want to be able to overwrite the data type\r\n     * @method setOutputDataType\r\n     * @param {number} slot\r\n     * @param {String} datatype\r\n     */\n  }, {\n    key: \"setOutputDataType\",\n    value: function setOutputDataType(slot, type) {\n      var _this$outputs$slot,\n        _this3 = this;\n      if (!this.outputs) {\n        return;\n      }\n      if (slot == -1 || slot >= this.outputs.length) {\n        return;\n      }\n      var output_info = this.outputs[slot];\n      if (!output_info) {\n        return;\n      }\n      // store data in the output itself in case we want to debug\n      output_info.type = type;\n\n      // if there are connections, pass the data to the connections\n      (_this$outputs$slot = this.outputs[slot]) === null || _this$outputs$slot === void 0 || (_this$outputs$slot = _this$outputs$slot.links) === null || _this$outputs$slot === void 0 || _this$outputs$slot.forEach(function (link_id) {\n        if (_this3.graph.links[link_id]) {\n          _this3.graph.links[link_id].type = type;\n        }\n      });\n    }\n\n    /**\r\n     * Retrieves the input data (data traveling through the connection) from one slot\r\n     * @method getInputData\r\n     * @param {number} slot\r\n     * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link\r\n     * @return {*} data or if it is not connected returns undefined\r\n     */\n  }, {\n    key: \"getInputData\",\n    value: function getInputData(slot, force_update, refresh_tree) {\n      if (!this.inputs) {\n        return;\n      } // undefined;\n\n      if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n        return;\n      }\n      var link_id = this.inputs[slot].link;\n      var link = this.graph.links[link_id];\n      if (!link) {\n        // bug: weird case but it happens sometimes\n        return null;\n      }\n      if (!force_update) {\n        return link.data;\n      }\n\n      // special case: used to extract data from the incoming connection before the graph has been executed\n      var node = this.graph.getNodeById(link.origin_id);\n      if (!node) {\n        return link.data;\n      }\n\n      // atlasan: refactor: This is a basic, but seems working, version. Consider moving this out of here and use a single ancestorsCalculation (for each event?)\n      if (refresh_tree) {\n        var uIdRand = this.id + \"_getInputData_forced_\" + Math.floor(Math.random() * 9999);\n        var optsAncestors = {\n          action: uIdRand,\n          options: {\n            action_call: uIdRand\n          }\n        };\n        this.refreshAncestors(optsAncestors);\n      }\n      if (node.updateOutputData) {\n        node.updateOutputData(link.origin_slot);\n      } else {\n        var _node$doExecute;\n        (_node$doExecute = node.doExecute) === null || _node$doExecute === void 0 || _node$doExecute.call(node);\n      }\n      return link.data;\n    }\n\n    /**\r\n     * Retrieves the input data type (in case this supports multiple input types)\r\n     * @method getInputDataType\r\n     * @param {number} slot\r\n     * @return {String} datatype in string format\r\n     */\n  }, {\n    key: \"getInputDataType\",\n    value: function getInputDataType(slot) {\n      if (!this.inputs) {\n        return null;\n      } // undefined;\n\n      if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n        return null;\n      }\n      var link_id = this.inputs[slot].link;\n      var link = this.graph.links[link_id];\n      if (!link) {\n        // bug: weird case but it happens sometimes\n        return null;\n      }\n      var node = this.graph.getNodeById(link.origin_id);\n      if (!node) {\n        return link.type;\n      }\n      var output_info = node.outputs[link.origin_slot];\n      if (output_info) {\n        return output_info.type;\n      }\n      return null;\n    }\n\n    /**\r\n     * Retrieves the input data from one slot using its name instead of slot number\r\n     * @method getInputDataByName\r\n     * @param {String} slot_name\r\n     * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link\r\n     * @return {*} data or if it is not connected returns null\r\n     */\n  }, {\n    key: \"getInputDataByName\",\n    value: function getInputDataByName(slot_name, force_update) {\n      var slot = this.findInputSlot(slot_name);\n      if (slot == -1) {\n        return null;\n      }\n      return this.getInputData(slot, force_update);\n    }\n\n    /**\r\n     * tells you if there is a connection in one input slot\r\n     * @method isInputConnected\r\n     * @param {number} slot\r\n     * @return {boolean}\r\n     */\n  }, {\n    key: \"isInputConnected\",\n    value: function isInputConnected(slot) {\n      if (!this.inputs) {\n        return false;\n      }\n      return slot < this.inputs.length && this.inputs[slot].link != null;\n    }\n\n    /**\r\n     * tells you info about an input connection (which node, type, etc)\r\n     * @method getInputInfo\r\n     * @param {number} slot\r\n     * @return {Object} object or null { link: id, name: string, type: string or 0 }\r\n     */\n  }, {\n    key: \"getInputInfo\",\n    value: function getInputInfo(slot) {\n      if (!this.inputs) {\n        return null;\n      }\n      if (slot < this.inputs.length) {\n        return this.inputs[slot];\n      }\n      return null;\n    }\n\n    /**\r\n     * Returns the link info in the connection of an input slot\r\n     * @method getInputLink\r\n     * @param {number} slot\r\n     * @return {LiteGraph.LLink} object or null\r\n     */\n  }, {\n    key: \"getInputLink\",\n    value: function getInputLink(slot) {\n      if (!this.inputs) {\n        return null;\n      }\n      if (slot < this.inputs.length) {\n        var slot_info = this.inputs[slot];\n        return this.graph.links[slot_info.link];\n      }\n      return null;\n    }\n\n    /**\r\n     * returns the node connected in the input slot\r\n     * @method getInputNode\r\n     * @param {number} slot\r\n     * @return {LGraphNode} node or null\r\n     */\n  }, {\n    key: \"getInputNode\",\n    value: function getInputNode(slot) {\n      if (!this.inputs) {\n        return null;\n      }\n      if (slot >= this.inputs.length) {\n        return null;\n      }\n      var input = this.inputs[slot];\n      if (!input || input.link === null) {\n        return null;\n      }\n      var link_info = this.graph.links[input.link];\n      if (!link_info) {\n        return null;\n      }\n      return this.graph.getNodeById(link_info.origin_id);\n    }\n\n    /**\r\n     * returns the value of an input with this name, otherwise checks if there is a property with that name\r\n     * @method getInputOrProperty\r\n     * @param {string} name\r\n     * @return {*} value\r\n     */\n  }, {\n    key: \"getInputOrProperty\",\n    value: function getInputOrProperty(name) {\n      if (this.inputs) {\n        for (var i = 0, l = this.inputs.length; i < l; ++i) {\n          var input_info = this.inputs[i];\n          if (name == input_info.name && input_info.link != null) {\n            var link = this.graph.links[input_info.link];\n            if (link) {\n              return link.data;\n            }\n          }\n        }\n      }\n      return this.properties ? this.properties[name] : null;\n    }\n\n    /**\r\n     * tells you the last output data that went in that slot\r\n     * @method getOutputData\r\n     * @param {number} slot\r\n     * @return {Object}  object or null\r\n     */\n  }, {\n    key: \"getOutputData\",\n    value: function getOutputData(slot) {\n      if (!this.outputs) {\n        return null;\n      }\n      if (slot >= this.outputs.length) {\n        return null;\n      }\n      var info = this.outputs[slot];\n      return info._data;\n    }\n\n    /**\r\n     * tells you info about an output connection (which node, type, etc)\r\n     * @method getOutputInfo\r\n     * @param {number} slot\r\n     * @return {Object}  object or null { name: string, type: string, links: [ ids of links in number ] }\r\n     */\n  }, {\n    key: \"getOutputInfo\",\n    value: function getOutputInfo(slot) {\n      if (!this.outputs) {\n        return null;\n      }\n      if (slot < this.outputs.length) {\n        return this.outputs[slot];\n      }\n      return null;\n    }\n\n    /**\r\n     * tells you if there is a connection in one output slot\r\n     * @method isOutputConnected\r\n     * @param {number} slot\r\n     * @return {boolean}\r\n     */\n  }, {\n    key: \"isOutputConnected\",\n    value: function isOutputConnected(slot) {\n      if (!this.outputs) {\n        return false;\n      }\n      return slot < this.outputs.length && this.outputs[slot].links && this.outputs[slot].links.length;\n    }\n\n    /**\r\n     * tells you if there is any connection in the output slots\r\n     * @method isAnyOutputConnected\r\n     * @return {boolean}\r\n     */\n  }, {\n    key: \"isAnyOutputConnected\",\n    value: function isAnyOutputConnected() {\n      return this.outputs ? this.outputs.some(function (output) {\n        return output.links && output.links.length;\n      }) : false;\n    }\n\n    /**\r\n     * retrieves all the nodes connected to this output slot\r\n     * @method getOutputNodes\r\n     * @param {number} slot\r\n     * @return {array}\r\n     */\n  }, {\n    key: \"getOutputNodes\",\n    value: function getOutputNodes(slot) {\n      var _this4 = this;\n      if (!this.outputs || slot >= this.outputs.length) {\n        return null;\n      }\n      var output = this.outputs[slot];\n      if (!output.links || output.links.length === 0) {\n        return null;\n      }\n      return output.links.map(function (link_id) {\n        return _this4.graph.links[link_id];\n      }).filter(function (link) {\n        return link;\n      }).map(function (link) {\n        return _this4.graph.getNodeById(link.target_id);\n      }).filter(function (target_node) {\n        return target_node;\n      });\n    }\n  }, {\n    key: \"addOnTriggerInput\",\n    value: function addOnTriggerInput() {\n      var trigS = this.findInputSlot(\"onTrigger\");\n      if (trigS == -1) {\n        // !trigS ||\n        this.addInput(\"onTrigger\", _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT, {\n          removable: true,\n          nameLocked: true\n        });\n        return this.findInputSlot(\"onTrigger\");\n      }\n      return trigS;\n    }\n  }, {\n    key: \"addOnExecutedOutput\",\n    value: function addOnExecutedOutput() {\n      var trigS = this.findOutputSlot(\"onExecuted\");\n      if (trigS == -1) {\n        // !trigS ||\n        this.addOutput(\"onExecuted\", _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION, {\n          removable: true,\n          nameLocked: true\n        });\n        return this.findOutputSlot(\"onExecuted\");\n      }\n      return trigS;\n    }\n  }, {\n    key: \"onAfterExecuteNode\",\n    value: function onAfterExecuteNode(param, options) {\n      var trigS = this.findOutputSlot(\"onExecuted\");\n      if (trigS != -1) {\n        var _LiteGraph$debug;\n        (_LiteGraph$debug = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug === void 0 || _LiteGraph$debug.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, this.id + \":\" + this.order + \" triggering slot onAfterExecute\", param, options);\n        this.triggerSlot(trigS, param, null, options);\n      }\n    }\n  }, {\n    key: \"changeMode\",\n    value: function changeMode(modeTo) {\n      switch (modeTo) {\n        case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ON_TRIGGER:\n          this.addOnTriggerInput();\n          this.addOnExecutedOutput();\n          break;\n        case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ON_EVENT:\n          // this.addOnExecutedOutput();\n          break;\n        case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NEVER:\n          break;\n        case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ALWAYS:\n          break;\n        case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ON_REQUEST:\n          break;\n        default:\n          return false;\n      }\n      this.mode = modeTo;\n      return true;\n    }\n\n    /**\r\n     * Triggers the execution of actions that were deferred when the action was triggered\r\n     * @method executePendingActions\r\n     */\n  }, {\n    key: \"executePendingActions\",\n    value: function executePendingActions() {\n      var _this5 = this;\n      if (!this._waiting_actions || !this._waiting_actions.length) return;\n      this._waiting_actions.forEach(function (p) {\n        _this5.onAction(p[0], p[1], p[2], p[3], p[4]);\n      });\n      this._waiting_actions.length = 0;\n    }\n\n    /**\r\n     * Triggers the node code execution, place a boolean/counter to mark the node as being executed\r\n     * @method doExecute\r\n     * @param {*} param\r\n     * @param {*} options\r\n     */\n  }, {\n    key: \"doExecute\",\n    value: function doExecute(param) {\n      var _this$onAfterExecuteN;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.onExecute) {\n        var _options$action_call;\n        // enable this to give the event an ID\n        (_options$action_call = options.action_call) !== null && _options$action_call !== void 0 ? _options$action_call : options.action_call = \"\".concat(this.id, \"_exec_\").concat(Math.floor(Math.random() * 9999));\n        if (this.graph.nodes_executing && this.graph.nodes_executing[this.id]) {\n          var _LiteGraph$debug2;\n          (_LiteGraph$debug2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug2 === void 0 || _LiteGraph$debug2.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"NODE already executing! Prevent! \" + this.id + \":\" + this.order);\n          return;\n        }\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ensureNodeSingleExecution && this.exec_version && this.exec_version >= this.graph.iteration && this.exec_version !== undefined) {\n          var _LiteGraph$debug3;\n          (_LiteGraph$debug3 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug3 === void 0 || _LiteGraph$debug3.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"!! NODE already EXECUTED THIS STEP !! \" + this.exec_version);\n          return;\n        }\n        // LiteGraph.debug?.(\"Actioned ? \"+this.id+\":\"+this.order+\" :: \"+this.action_call);\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ensureUniqueExecutionAndActionCall) {\n          // if(this.action_call && options && options.action_call && this.action_call == options.action_call){\n          if (this.graph.nodes_executedAction[this.id] && options && options.action_call && this.graph.nodes_executedAction[this.id] == options.action_call) {\n            var _LiteGraph$debug4;\n            (_LiteGraph$debug4 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug4 === void 0 || _LiteGraph$debug4.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"!! NODE already ACTION THIS STEP !! \" + options.action_call);\n            return;\n          }\n        }\n        this.graph.nodes_executing[this.id] = true; // .push(this.id);\n\n        this.onExecute(param, options);\n        this.graph.nodes_executing[this.id] = false; // .pop();\n\n        // save execution/action ref\n        this.exec_version = this.graph.iteration;\n        if (options && options.action_call) {\n          this.action_call = options.action_call; // if (param)\n          this.graph.nodes_executedAction[this.id] = options.action_call;\n        }\n      }\n      this.execute_triggered = 2; // the nFrames it will be used (-- each step), means \"how old\" is the event\n      (_this$onAfterExecuteN = this.onAfterExecuteNode) === null || _this$onAfterExecuteN === void 0 || _this$onAfterExecuteN.call(this, param, options); // callback\n    }\n    /**\r\n     * retrocompatibility :: old doExecute\r\n     * @method doExecute\r\n     * @param {*} param\r\n     * @param {*} options\r\n     */\n  }, {\n    key: \"execute\",\n    value: function execute(param) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.doExecute(param, options);\n    }\n\n    /**\r\n     * Triggers an action, wrapped by logics to control execution flow\r\n     * @method actionDo\r\n     * @param {String} action name\r\n     * @param {*} param\r\n     */\n  }, {\n    key: \"actionDo\",\n    value: function actionDo(action, param) {\n      var _this$onAfterExecuteN2;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var action_slot = arguments.length > 3 ? arguments[3] : undefined;\n      if (this.onAction) {\n        var _options$action_call2, _LiteGraph$debug5;\n        // enable this to give the event an ID\n        (_options$action_call2 = options.action_call) !== null && _options$action_call2 !== void 0 ? _options$action_call2 : options.action_call = \"\".concat(this.id, \"_\").concat(action ? action : \"action\", \"_\").concat(Math.floor(Math.random() * 9999));\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ensureNodeSingleAction) {\n          if (this.graph.nodes_actioning && this.graph.nodes_actioning[this.id] == options.action_call) {\n            // == action){\n            // LiteGraph.debug?.(\"NODE already actioning! Prevent! \"+this.id+\":\"+this.order+\" :: \"+options.action_call);\n            return;\n          }\n        }\n        (_LiteGraph$debug5 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug5 === void 0 || _LiteGraph$debug5.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"CheckActioned ? \" + this.id + \":\" + this.order + \" :: \" + this.action_call);\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ensureUniqueExecutionAndActionCall) {\n          // if(this.action_call && options && options.action_call && this.action_call == options.action_call){\n          if (this.graph.nodes_executedAction[this.id] && options && options.action_call && this.graph.nodes_executedAction[this.id] == options.action_call) {\n            var _LiteGraph$debug6;\n            (_LiteGraph$debug6 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug6 === void 0 || _LiteGraph$debug6.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"!! NODE already ACTION THIS STEP !! \" + options.action_call);\n            ç;\n            return;\n          }\n        }\n        this.graph.nodes_actioning[this.id] = action ? action : \"actioning\"; // .push(this.id);\n\n        this.onAction(action, param, options, action_slot);\n        this.graph.nodes_actioning[this.id] = false; // .pop();\n\n        // save execution/action ref\n        if (options && options.action_call) {\n          this.action_call = options.action_call; // if (param)\n          this.graph.nodes_executedAction[this.id] = options.action_call;\n        }\n      }\n      this.action_triggered = 2; // the nFrames it will be used (-- each step), means \"how old\" is the event\n      (_this$onAfterExecuteN2 = this.onAfterExecuteNode) === null || _this$onAfterExecuteN2 === void 0 || _this$onAfterExecuteN2.call(this, param, options);\n    }\n\n    /**\r\n     * Triggers an event in this node, this will trigger any output with the same name\r\n     * @method trigger\r\n     * @param {String} event name ( \"on_play\", ... ) if action is equivalent to false then the event is send to all\r\n     * @param {*} param\r\n     */\n  }, {\n    key: \"trigger\",\n    value: function trigger(action, param, options) {\n      var _this6 = this;\n      if (!this.outputs || this.outputs.length === 0) {\n        return;\n      }\n      this.graph && (this.graph._last_trigger_time = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getTime());\n      this.outputs.forEach(function (output, i) {\n        if (output && output.type === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT && (!action || output.name === action)) {\n          _this6.triggerSlot(i, param, null, options);\n        }\n      });\n    }\n\n    /**\r\n     * Triggers a slot event in this node: cycle output slots and launch execute/action on connected nodes\r\n     * @method triggerSlot\r\n     * @param {Number} slot the index of the output slot\r\n     * @param {*} param\r\n     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot\r\n     */\n  }, {\n    key: \"triggerSlot\",\n    value: function triggerSlot(slot, param, link_id) {\n      var _LiteGraph$warn2;\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      if (!this.outputs) {\n        return;\n      }\n      if (slot == null) {\n        var _LiteGraph$error;\n        (_LiteGraph$error = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.error) === null || _LiteGraph$error === void 0 || _LiteGraph$error.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"triggerSlot\", \"slot must be a number\");\n        return;\n      }\n      if (slot.constructor !== Number) (_LiteGraph$warn2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn2 === void 0 || _LiteGraph$warn2.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"triggerSlot\", \"slot must be a number, use node.trigger('name') if you want to use a string\");\n      var output = this.outputs[slot];\n      if (!output) {\n        return;\n      }\n      var links = output.links;\n      if (!links || !links.length) {\n        return;\n      }\n\n      // check for ancestors calls\n      if (this.graph && this.graph.ancestorsCall) {\n        // LiteGraph.debug?.(\"ancestors call, prevent triggering slot \"+slot+\" on \"+this.id+\":\"+this.order);\n        return;\n      }\n      if (this.graph) {\n        this.graph._last_trigger_time = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getTime();\n      }\n\n      // for every link attached here\n      for (var k = 0; k < links.length; ++k) {\n        var id = links[k];\n        if (link_id != null && link_id != id) {\n          // to skip links\n          continue;\n        }\n        var link_info = this.graph.links[links[k]];\n        if (!link_info) {\n          // not connected\n          continue;\n        }\n        link_info._last_time = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.getTime();\n        var node = this.graph.getNodeById(link_info.target_id);\n        if (!node) {\n          // node not found?\n          continue;\n        }\n        if (node.mode === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ON_TRIGGER) {\n          // generate unique trigger ID if not present\n          if (!options.action_call) options.action_call = \"\".concat(this.id, \"_trigg_\").concat(Math.floor(Math.random() * 9999));\n          if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.refreshAncestorsOnTriggers) node.refreshAncestors({\n            action: \"trigger\",\n            param: param,\n            options: options\n          });\n          if (node.onExecute) {\n            // -- wrapping node.onExecute(param); --\n            node.doExecute(param, options); // @BUG: Possible misname here\n          }\n        } else if (node.onAction) {\n          var _LiteGraph$debug7;\n          // generate unique action ID if not present\n          if (!options.action_call) options.action_call = \"\".concat(this.id, \"_act_\").concat(Math.floor(Math.random() * 9999));\n          // pass the action name\n          var target_connection = node.inputs[link_info.target_slot];\n          (_LiteGraph$debug7 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug7 === void 0 || _LiteGraph$debug7.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"triggerSlot\", \"will call onACTION: \" + this.id + \":\" + this.order + \" :: \" + target_connection.name);\n\n          // METHOD 1 ancestors\n          if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.refreshAncestorsOnActions) node.refreshAncestors({\n            action: target_connection.name,\n            param: param,\n            options: options\n          });\n\n          // instead of executing them now, it will be executed in the next graph loop, to ensure data flow\n          if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.use_deferred_actions && node.onExecute) {\n            var _node, _node$_waiting_action;\n            (_node$_waiting_action = (_node = node)._waiting_actions) !== null && _node$_waiting_action !== void 0 ? _node$_waiting_action : _node._waiting_actions = [];\n            node._waiting_actions.push([target_connection.name, param, options, link_info.target_slot]);\n          } else {\n            // wrap node.onAction(target_connection.name, param);\n            node.actionDo(target_connection.name, param, options, link_info.target_slot);\n          }\n        }\n      }\n    }\n\n    /**\r\n     * clears the trigger slot animation\r\n     * @method clearTriggeredSlot\r\n     * @param {Number} slot the index of the output slot\r\n     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot\r\n     */\n  }, {\n    key: \"clearTriggeredSlot\",\n    value: function clearTriggeredSlot(slot, link_id) {\n      var _this7 = this;\n      if (!this.outputs || !this.outputs[slot] || !this.outputs[slot].links) {\n        return;\n      }\n      this.outputs[slot].links.forEach(function (id) {\n        if (link_id !== null && link_id !== id) {\n          // Skip links\n          return;\n        }\n        var link_info = _this7.graph.links[id];\n        if (!link_info) {\n          // Not connected\n          return;\n        }\n        link_info._last_time = 0;\n      });\n    }\n\n    /**\r\n     * changes node size and triggers callback\r\n     * @method setSize\r\n     * @param {vec2} size\r\n     */\n  }, {\n    key: \"setSize\",\n    value: function setSize(size) {\n      var _this$onResize;\n      this.size = size;\n      (_this$onResize = this.onResize) === null || _this$onResize === void 0 || _this$onResize.call(this, this.size);\n    }\n\n    /**\r\n     * add a new property to this node\r\n     * @method addProperty\r\n     * @param {string} name\r\n     * @param {*} default_value\r\n     * @param {string} type string defining the output type (\"vec3\",\"number\",...)\r\n     * @param {Object} extra_info this can be used to have special properties of the property (like values, etc)\r\n     */\n  }, {\n    key: \"addProperty\",\n    value: function addProperty(name, default_value, type, extra_info) {\n      var _this$properties_info, _this$properties;\n      var o = _objectSpread({\n        name: name,\n        type: type,\n        default_value: default_value\n      }, extra_info);\n      this.properties_info = (_this$properties_info = this.properties_info) !== null && _this$properties_info !== void 0 ? _this$properties_info : [];\n      this.properties_info.push(o);\n      this.properties = (_this$properties = this.properties) !== null && _this$properties !== void 0 ? _this$properties : {};\n      this.properties[name] = default_value;\n      return o;\n    }\n\n    /**\r\n     * Add a new input or output slot to use in this node.\r\n     * @param {string} name - Name of the slot.\r\n     * @param {string} type - Type of the slot (\"vec3\", \"number\", etc). For a generic type, use \"0\".\r\n     * @param {Object} extra_info - Additional information for the slot (e.g., label, color, position).\r\n     * @param {boolean} isInput - Whether the slot being added is an input slot.\r\n     * @returns {Object} The newly added slot (input or output).\r\n     *\r\n     * @NOTE: These methods are slightly different, and it would be optimal to keep them separate,\r\n     * but our goal here is to refactor them so they *aren't* slightly different.\r\n     */\n  }, {\n    key: \"addInput\",\n    value: function addInput(name, type, extra_info) {\n      return this.addSlot(name, type, extra_info, true);\n    }\n  }, {\n    key: \"addOutput\",\n    value: function addOutput(name, type, extra_info) {\n      return this.addSlot(name, type, extra_info, false);\n    }\n  }, {\n    key: \"addSlot\",\n    value: function addSlot(name, type, extra_info, isInput) {\n      var slot = isInput ? _objectSpread({\n        name: name,\n        type: type,\n        link: null\n      }, extra_info) : _objectSpread({\n        name: name,\n        type: type,\n        links: null\n      }, extra_info);\n      if (isInput) {\n        var _this$inputs2, _this$onInputAdded2;\n        this.inputs = (_this$inputs2 = this.inputs) !== null && _this$inputs2 !== void 0 ? _this$inputs2 : [];\n        this.inputs.push(slot);\n        (_this$onInputAdded2 = this.onInputAdded) === null || _this$onInputAdded2 === void 0 || _this$onInputAdded2.call(this, slot);\n        _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registerNodeAndSlotType(this, type);\n      } else {\n        var _this$outputs2, _this$onOutputAdded2;\n        this.outputs = (_this$outputs2 = this.outputs) !== null && _this$outputs2 !== void 0 ? _this$outputs2 : [];\n        this.outputs.push(slot);\n        (_this$onOutputAdded2 = this.onOutputAdded) === null || _this$onOutputAdded2 === void 0 || _this$onOutputAdded2.call(this, slot);\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.auto_load_slot_types) {\n          _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registerNodeAndSlotType(this, type, true);\n        }\n      }\n      this.setSize(this.computeSize());\n      this.setDirtyCanvas(true, true);\n      return slot;\n    }\n\n    /**\r\n     * Add multiple input or output slots to use in this node.\r\n     * @param {Array} array - Array of triplets like [[name, type, extra_info], [...]].\r\n     * @param {boolean} isInput - Whether the slots being added are input slots.\r\n     *\r\n     * @NOTE: These methods are slightly different, and it would be optimal to keep them separate,\r\n     * but our goal here is to refactor them so they *aren't* slightly different.\r\n     */\n  }, {\n    key: \"addInputs\",\n    value: function addInputs(array) {\n      this.addSlots(array, true);\n    }\n  }, {\n    key: \"addOutputs\",\n    value: function addOutputs(array) {\n      this.addSlots(array, false);\n    }\n  }, {\n    key: \"addSlots\",\n    value: function addSlots(array, isInput) {\n      var _this8 = this,\n        _this$setDirtyCanvas;\n      if (typeof array === 'string') array = [array];\n      array.forEach(function (info) {\n        var _info$, _info$2;\n        var slot = isInput ? _objectSpread({\n          name: info[0],\n          type: info[1],\n          link: null\n        }, (_info$ = info[2]) !== null && _info$ !== void 0 ? _info$ : {}) : _objectSpread({\n          name: info[0],\n          type: info[1],\n          links: null\n        }, (_info$2 = info[2]) !== null && _info$2 !== void 0 ? _info$2 : {});\n        if (isInput) {\n          var _this8$inputs, _this8$onInputAdded;\n          _this8.inputs = (_this8$inputs = _this8.inputs) !== null && _this8$inputs !== void 0 ? _this8$inputs : [];\n          _this8.inputs.push(slot);\n          (_this8$onInputAdded = _this8.onInputAdded) === null || _this8$onInputAdded === void 0 || _this8$onInputAdded.call(_this8, slot);\n          _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registerNodeAndSlotType(_this8, info[1]);\n        } else {\n          var _this8$outputs, _this8$onOutputAdded;\n          _this8.outputs = (_this8$outputs = _this8.outputs) !== null && _this8$outputs !== void 0 ? _this8$outputs : [];\n          _this8.outputs.push(slot);\n          (_this8$onOutputAdded = _this8.onOutputAdded) === null || _this8$onOutputAdded === void 0 || _this8$onOutputAdded.call(_this8, slot);\n          if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.auto_load_slot_types) {\n            _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registerNodeAndSlotType(_this8, info[1], true);\n          }\n        }\n      });\n      this.setSize(this.computeSize());\n      (_this$setDirtyCanvas = this.setDirtyCanvas) === null || _this$setDirtyCanvas === void 0 || _this$setDirtyCanvas.call(this, true, true);\n    }\n\n    /**\r\n     * remove an existing input slot\r\n     * @method removeInput\r\n     * @param {number} slot\r\n     *\r\n     * @NOTE: These two are different enough yet I can't even mash them together meaningfully.\r\n     */\n  }, {\n    key: \"removeInput\",\n    value: function removeInput(slot) {\n      var _this9 = this,\n        _this$onInputRemoved;\n      this.disconnectInput(slot);\n      var removedInput = this.inputs.splice(slot, 1)[0];\n      this.inputs.slice(slot).filter(function (input) {\n        return !!input;\n      }).forEach(function (input) {\n        var link = _this9.graph.links[input.link];\n        (link === null || link === void 0 ? void 0 : link.target_slot) && link.target_slot--;\n      });\n      this.setSize(this.computeSize());\n      (_this$onInputRemoved = this.onInputRemoved) === null || _this$onInputRemoved === void 0 || _this$onInputRemoved.call(this, slot, removedInput);\n      this.setDirtyCanvas(true, true);\n    }\n\n    /**\r\n     * remove an existing output slot\r\n     * @method removeOutput\r\n     * @param {number} slot\r\n     */\n  }, {\n    key: \"removeOutput\",\n    value: function removeOutput(slot) {\n      var _this10 = this,\n        _this$onOutputRemoved;\n      this.disconnectOutput(slot);\n      this.outputs = this.outputs.filter(function (_, index) {\n        return index !== slot;\n      });\n      this.outputs.slice(slot).forEach(function (output) {\n        if (!output || !output.links) {\n          return;\n        }\n        output.links.forEach(function (linkId) {\n          var link = _this10.graph.links[linkId];\n          if (link) {\n            link.origin_slot -= 1;\n          }\n        });\n      });\n      this.setSize(this.computeSize());\n      (_this$onOutputRemoved = this.onOutputRemoved) === null || _this$onOutputRemoved === void 0 || _this$onOutputRemoved.call(this, slot);\n      this.setDirtyCanvas(true, true);\n    }\n\n    /**\r\n     * Add a special connection to this node (used for special kinds of graphs)\r\n     * @method addConnection\r\n     * @param {string} name - The name of the connection\r\n     * @param {string} type - String defining the input type (\"vec3\", \"number\", etc.)\r\n     * @param {Float32[]} pos - Position of the connection inside the node as an array [x, y]\r\n     * @param {string} direction - Specifies if it is an input or output connection\r\n     */\n  }, {\n    key: \"addConnection\",\n    value: function addConnection(name, type, pos, direction) {\n      var o = {\n        name: name,\n        type: type,\n        pos: pos,\n        direction: direction,\n        links: null\n      };\n      this.connections.push(o);\n      return o;\n    }\n\n    /**\r\n     * computes the minimum size of a node according to its inputs and output slots\r\n     * @method computeSize\r\n     * @param {vec2} minHeight\r\n     * @return {vec2} the total size\r\n     */\n  }, {\n    key: \"computeSize\",\n    value: function computeSize(out) {\n      if (this.constructor.size) {\n        return this.constructor.size.concat();\n      }\n      var size = out || new Float32Array([0, 0]);\n      var font_size = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TEXT_SIZE; // although it should be graphcanvas.inner_text_font size\n\n      // computeWidth\n      var get_text_width = function get_text_width(text) {\n        if (!text) {\n          return 0;\n        }\n        return font_size * text.length * 0.6;\n      };\n      var title_width = get_text_width(this.title);\n      var input_width = 0;\n      var output_width = 0;\n      if (this.inputs) {\n        input_width = this.inputs.reduce(function (maxWidth, input) {\n          var text = input.label || input.name || \"\";\n          var text_width = get_text_width(text);\n          return Math.max(maxWidth, text_width);\n        }, 0);\n      }\n      if (this.outputs) {\n        output_width = this.outputs.reduce(function (maxWidth, output) {\n          var text = output.label || output.name || \"\";\n          var text_width = get_text_width(text);\n          return Math.max(maxWidth, text_width);\n        }, 0);\n      }\n      size[0] = Math.max(input_width + output_width + 10, title_width);\n      size[0] = Math.max(size[0], _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_WIDTH);\n      if (this.widgets && this.widgets.length) {\n        size[0] = Math.max(size[0], _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_WIDTH * 1.5);\n      }\n\n      // computeHeight\n\n      // minimum height calculated by slots or 1\n      var rowHeight = Math.max(this.inputs ? this.inputs.length : 1, this.outputs ? this.outputs.length : 1, 1) * _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_SLOT_HEIGHT;\n\n      // add margin (should this be always?)\n      size[1] = rowHeight + (this.constructor.slot_start_y || 0);\n\n      // minimum height calculated by widgets\n      var widgetsHeight = 0;\n      if (this.widgets && this.widgets.length) {\n        for (var i = 0, l = this.widgets.length; i < l; ++i) {\n          if (this.widgets[i].computeSize) widgetsHeight += this.widgets[i].computeSize(size[0])[1] + 4;else widgetsHeight += _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_WIDGET_HEIGHT + 4;\n        }\n        widgetsHeight += 8;\n      }\n\n      // compute height using widgets height\n      if (this.widgets_up) size[1] = Math.max(size[1], widgetsHeight);else if (this.widgets_start_y != null) size[1] = Math.max(size[1], widgetsHeight + this.widgets_start_y);else size[1] += widgetsHeight;\n      if (this.constructor.min_height && size[1] < this.constructor.min_height) {\n        size[1] = this.constructor.min_height;\n      }\n      size[1] += 6; // margin\n      return size;\n    }\n\n    /**\r\n     * returns all the info available about a property of this node.\r\n     *\r\n     * @method getPropertyInfo\r\n     * @param {String} property name of the property\r\n     * @return {Object} the object with all the available info\r\n    */\n  }, {\n    key: \"getPropertyInfo\",\n    value: function getPropertyInfo(property) {\n      var info = null;\n\n      // there are several ways to define info about a property\n      // legacy mode\n      if (this.properties_info) {\n        for (var i = 0; i < this.properties_info.length; ++i) {\n          if (this.properties_info[i].name == property) {\n            info = this.properties_info[i];\n            break;\n          }\n        }\n      }\n      // litescene mode using the constructor\n      if (this.constructor[\"@\".concat(property)]) info = this.constructor[\"@\".concat(property)];\n      if (this.constructor.widgets_info && this.constructor.widgets_info[property]) info = this.constructor.widgets_info[property];\n\n      // litescene mode using the constructor\n      if (!info && this.onGetPropertyInfo) {\n        info = this.onGetPropertyInfo(property);\n      }\n      if (!info) info = {};\n      if (!info.type) info.type = _typeof(this.properties[property]);\n      if (info.widget == \"combo\") info.type = \"enum\";\n      return info;\n    }\n\n    /**\r\n     * Defines a widget inside the node, it will be rendered on top of the node, you can control lots of properties\r\n     *\r\n     * @method addWidget\r\n     * @param {String} type the widget type (could be \"number\",\"string\",\"combo\"\r\n     * @param {String} name the text to show on the widget\r\n     * @param {String} value the default value\r\n     * @param {Function|String} callback function to call when it changes (optionally, it can be the name of the property to modify)\r\n     * @param {Object} options the object that contains special properties of this widget\r\n     * @return {Object} the created widget object\r\n     */\n  }, {\n    key: \"addWidget\",\n    value: function addWidget(type, name, value, callback, options) {\n      var _this$widgets2;\n      (_this$widgets2 = this.widgets) !== null && _this$widgets2 !== void 0 ? _this$widgets2 : this.widgets = [];\n      if (!options && callback && callback.constructor === Object) {\n        options = callback;\n        callback = null;\n      }\n      if (options && options.constructor === String)\n        // options can be the property name\n        options = {\n          property: options\n        };\n      if (callback && callback.constructor === String) {\n        var _options;\n        // callback can be the property name\n        (_options = options) !== null && _options !== void 0 ? _options : options = {};\n        options.property = callback;\n        callback = null;\n      }\n      if (callback && callback.constructor !== Function) {\n        var _LiteGraph$warn3;\n        (_LiteGraph$warn3 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn3 === void 0 || _LiteGraph$warn3.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"addWidget: callback must be a function\");\n        callback = null;\n      }\n      var w = {\n        type: type.toLowerCase(),\n        name: name,\n        value: value,\n        callback: callback,\n        options: options || {}\n      };\n      if (w.options.y !== undefined) {\n        w.y = w.options.y;\n      }\n      if (!callback && !w.options.callback && !w.options.property) {\n        var _LiteGraph$warn4;\n        (_LiteGraph$warn4 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn4 === void 0 || _LiteGraph$warn4.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"LiteGraph addWidget(...) without a callback or property assigned\");\n      }\n      if (type == \"combo\" && !w.options.values) {\n        throw Error(\"LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }\");\n      }\n      this.widgets.push(w);\n      this.setSize(this.computeSize());\n      return w;\n    }\n  }, {\n    key: \"addCustomWidget\",\n    value: function addCustomWidget(custom_widget) {\n      var _this$widgets3;\n      (_this$widgets3 = this.widgets) !== null && _this$widgets3 !== void 0 ? _this$widgets3 : this.widgets = [];\n      this.widgets.push(custom_widget);\n      return custom_widget;\n    }\n\n    /**\r\n     * Returns the bounding box of the object, used for rendering purposes\r\n     * @method getBounding\r\n     * @param {Float32[]} [out] - [Optional] A place to store the output to reduce garbage\r\n     * @param {boolean} [compute_outer] - [Optional] Set to true to include the shadow and connection points in the bounding calculation\r\n     * @return {Float32[]} The bounding box in the format of [topLeftCornerX, topLeftCornerY, width, height]\r\n     */\n  }, {\n    key: \"getBounding\",\n    value: function getBounding() {\n      var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Float32Array(4);\n      var compute_outer = arguments.length > 1 ? arguments[1] : undefined;\n      var nodePos = this.pos;\n      var isCollapsed = this.flags.collapsed;\n      var nodeSize = this.size;\n      var left_offset = 0;\n      // 1 offset due to how nodes are rendered\n      var right_offset = 1;\n      var top_offset = 0;\n      var bottom_offset = 0;\n      if (compute_outer) {\n        // 4 offset for collapsed node connection points\n        left_offset = 4;\n        // 6 offset for right shadow and collapsed node connection points\n        right_offset = 6 + left_offset;\n        // 4 offset for collapsed nodes top connection points\n        top_offset = 4;\n        // 5 offset for bottom shadow and collapsed node connection points\n        bottom_offset = 5 + top_offset;\n      }\n      out[0] = nodePos[0] - left_offset;\n      out[1] = nodePos[1] - _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT - top_offset;\n      out[2] = isCollapsed ? (this._collapsed_width || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_COLLAPSED_WIDTH) + right_offset : nodeSize[0] + right_offset;\n      out[3] = isCollapsed ? _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT + bottom_offset : nodeSize[1] + _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT + bottom_offset;\n      if (this.onBounding) {\n        this.onBounding(out);\n      }\n      return out;\n    }\n\n    /**\r\n     * checks if a point is inside the shape of a node\r\n     * @method isPointInside\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @return {boolean}\r\n     */\n  }, {\n    key: \"isPointInside\",\n    value: function isPointInside(x, y) {\n      var margin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var skip_title = arguments.length > 3 ? arguments[3] : undefined;\n      var margin_top = this.graph && this.graph.isLive() ? 0 : _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT;\n      if (skip_title) {\n        margin_top = 0;\n      }\n      if (this.flags && this.flags.collapsed) {\n        // if ( distance([x,y], [this.pos[0] + this.size[0]*0.5, this.pos[1] + this.size[1]*0.5]) < LiteGraph.NODE_COLLAPSED_RADIUS)\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(x, y, this.pos[0] - margin, this.pos[1] - _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT - margin, (this._collapsed_width || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_COLLAPSED_WIDTH) + 2 * margin, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT + 2 * margin)) {\n          return true;\n        }\n      } else if (this.pos[0] - 4 - margin < x && this.pos[0] + this.size[0] + 4 + margin > x && this.pos[1] - margin_top - margin < y && this.pos[1] + this.size[1] + margin > y) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\r\n     * checks if a point is inside a node slot, and returns info about which slot\r\n     * @method getSlotInPosition\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @return {Object} if found the object contains { input|output: slot object, slot: number, link_pos: [x,y] }\r\n     */\n  }, {\n    key: \"getSlotInPosition\",\n    value: function getSlotInPosition(x, y) {\n      // search for inputs\n      var link_pos = new Float32Array(2);\n      if (this.inputs) {\n        for (var i = 0, l = this.inputs.length; i < l; ++i) {\n          var input = this.inputs[i];\n          this.getConnectionPos(true, i, link_pos);\n          if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(x, y, link_pos[0] - 10, link_pos[1] - 5, 20, 10)) {\n            return {\n              input: input,\n              slot: i,\n              link_pos: link_pos\n            };\n          }\n        }\n      }\n      if (this.outputs) {\n        for (var _i = 0, _l = this.outputs.length; _i < _l; ++_i) {\n          var output = this.outputs[_i];\n          this.getConnectionPos(false, _i, link_pos);\n          if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isInsideRectangle(x, y, link_pos[0] - 10, link_pos[1] - 5, 20, 10)) {\n            return {\n              output: output,\n              slot: _i,\n              link_pos: link_pos\n            };\n          }\n        }\n      }\n      return null;\n    }\n\n    /**\r\n     * returns the input slot with a given name (used for dynamic slots), -1 if not found\r\n     * @method findInputSlot\r\n     * @param {string} name the name of the slot\r\n     * @param {boolean} returnObj if the obj itself wanted\r\n     * @return {number_or_object} the slot (-1 if not found)\r\n     */\n  }, {\n    key: \"findInputSlot\",\n    value: function findInputSlot(name, returnObj) {\n      if (!this.inputs) {\n        return -1;\n      }\n      for (var i = 0, l = this.inputs.length; i < l; ++i) {\n        if (name == this.inputs[i].name) {\n          return !returnObj ? i : this.inputs[i];\n        }\n      }\n      return -1;\n    }\n\n    /**\r\n     * returns the output slot with a given name (used for dynamic slots), -1 if not found\r\n     * @method findOutputSlot\r\n     * @param {string} name the name of the slot\r\n     * @param {boolean} returnObj if the obj itself wanted\r\n     * @return {number_or_object} the slot (-1 if not found)\r\n     */\n  }, {\n    key: \"findOutputSlot\",\n    value: function findOutputSlot(name) {\n      var returnObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (!this.outputs) {\n        return -1;\n      }\n      for (var i = 0, l = this.outputs.length; i < l; ++i) {\n        if (name == this.outputs[i].name) {\n          return !returnObj ? i : this.outputs[i];\n        }\n      }\n      return -1;\n    }\n\n    // TODO refactor: USE SINGLE findInput/findOutput functions! :: merge options\n\n    /**\r\n     * returns the first free input slot\r\n     * @method findInputSlotFree\r\n     * @param {object} options\r\n     * @return {number_or_object} the slot (-1 if not found)\r\n     */\n  }, {\n    key: \"findInputSlotFree\",\n    value: function findInputSlotFree() {\n      var optsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var optsDef = {\n        returnObj: false,\n        typesNotAccepted: []\n      };\n      var opts = Object.assign(optsDef, optsIn);\n      if (!this.inputs) {\n        return -1;\n      }\n      for (var i = 0, l = this.inputs.length; i < l; ++i) {\n        if (this.inputs[i].link && this.inputs[i].link != null) {\n          continue;\n        }\n        if (opts.typesNotAccepted && opts.typesNotAccepted.includes && opts.typesNotAccepted.includes(this.inputs[i].type)) {\n          continue;\n        }\n        return !opts.returnObj ? i : this.inputs[i];\n      }\n      return -1;\n    }\n\n    /**\r\n     * returns the first output slot free\r\n     * @method findOutputSlotFree\r\n     * @param {object} options\r\n     * @return {number_or_object} the slot (-1 if not found)\r\n     */\n  }, {\n    key: \"findOutputSlotFree\",\n    value: function findOutputSlotFree() {\n      var optsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var optsDef = {\n        returnObj: false,\n        typesNotAccepted: []\n      };\n      var opts = Object.assign(optsDef, optsIn);\n      if (!this.outputs) {\n        return -1;\n      }\n      for (var i = 0, l = this.outputs.length; i < l; ++i) {\n        if (this.outputs[i].links && this.outputs[i].links != null) {\n          continue;\n        }\n        if (opts.typesNotAccepted && opts.typesNotAccepted.includes && opts.typesNotAccepted.includes(this.outputs[i].type)) {\n          continue;\n        }\n        return !opts.returnObj ? i : this.outputs[i];\n      }\n      return -1;\n    }\n\n    /**\r\n     * findSlotByType for INPUTS\r\n     */\n  }, {\n    key: \"findInputSlotByType\",\n    value: function findInputSlotByType(type, returnObj, preferFreeSlot, doNotUseOccupied) {\n      return this.findSlotByType(true, type, returnObj, preferFreeSlot, doNotUseOccupied);\n    }\n\n    /**\r\n     * findSlotByType for OUTPUTS\r\n     */\n  }, {\n    key: \"findOutputSlotByType\",\n    value: function findOutputSlotByType(type, returnObj, preferFreeSlot, doNotUseOccupied) {\n      return this.findSlotByType(false, type, returnObj, preferFreeSlot, doNotUseOccupied);\n    }\n\n    /**\r\n     * returns the output (or input) slot with a given type, -1 if not found\r\n     * @method findSlotByType\r\n     * @param {boolean} input uise inputs instead of outputs\r\n     * @param {string} type the type of the slot\r\n     * @param {boolean} returnObj if the obj itself wanted\r\n     * @param {boolean} preferFreeSlot if we want a free slot (if not found, will return the first of the type anyway)\r\n     * @return {number_or_object} the slot (-1 if not found)\r\n     */\n  }, {\n    key: \"findSlotByType\",\n    value: function findSlotByType() {\n      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var type = arguments.length > 1 ? arguments[1] : undefined;\n      var returnObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var preferFreeSlot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var doNotUseOccupied = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var aSlots = input ? this.inputs : this.outputs;\n      if (!aSlots) {\n        return -1;\n      }\n      // !! empty string type is considered 0, * !!\n      if (type == \"\" || type == \"*\") type = 0;\n      for (var i = 0, l = aSlots.length; i < l; ++i) {\n        var aSource = (type + \"\").toLowerCase().split(\",\");\n        var aDest = aSlots[i].type == \"0\" || aSlots[i].type == \"*\" ? \"0\" : aSlots[i].type;\n        aDest = (aDest + \"\").toLowerCase().split(\",\");\n        for (var sI = 0; sI < aSource.length; sI++) {\n          for (var dI = 0; dI < aDest.length; dI++) {\n            if (aSource[sI] == \"_event_\") aSource[sI] = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT;\n            if (aDest[sI] == \"_event_\") aDest[sI] = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT;\n            if (aSource[sI] == \"*\") aSource[sI] = 0;\n            if (aDest[sI] == \"*\") aDest[sI] = 0;\n            if (aSource[sI] == aDest[dI]) {\n              if (preferFreeSlot && aSlots[i].links && aSlots[i].links !== null) continue;\n              return !returnObj ? i : aSlots[i];\n            }\n          }\n        }\n      }\n      // if didnt find some, stop checking for free slots\n      if (preferFreeSlot && !doNotUseOccupied) {\n        for (var _i2 = 0, _l2 = aSlots.length; _i2 < _l2; ++_i2) {\n          var _aSource = (type + \"\").toLowerCase().split(\",\");\n          var _aDest = aSlots[_i2].type == \"0\" || aSlots[_i2].type == \"*\" ? \"0\" : aSlots[_i2].type;\n          _aDest = (_aDest + \"\").toLowerCase().split(\",\");\n          for (var _sI = 0; _sI < _aSource.length; _sI++) {\n            for (var _dI = 0; _dI < _aDest.length; _dI++) {\n              if (_aSource[_sI] == \"*\") _aSource[_sI] = 0;\n              if (_aDest[_sI] == \"*\") _aDest[_sI] = 0;\n              if (_aSource[_sI] == _aDest[_dI]) {\n                return !returnObj ? _i2 : aSlots[_i2];\n              }\n            }\n          }\n        }\n      }\n      return -1;\n    }\n\n    /**\r\n     * connect this node output to the input of another node BY TYPE\r\n     * @method connectByType\r\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\r\n     * @param {LGraphNode} node the target node\r\n     * @param {string} target_type the input slot type of the target node\r\n     * @return {Object} the link_info is created, otherwise null\r\n     */\n  }, {\n    key: \"connectByType\",\n    value: function connectByType(slot, target_node) {\n      var target_slotType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"*\";\n      var optsIn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var optsDef = {\n        createEventInCase: true,\n        firstFreeIfOutputGeneralInCase: true,\n        generalTypeInCase: true\n      };\n      var opts = Object.assign(optsDef, optsIn);\n      if (target_node && target_node.constructor === Number) {\n        target_node = this.graph.getNodeById(target_node);\n      }\n      var target_slot = target_node.findInputSlotByType(target_slotType, false, true);\n      if (target_slot >= 0 && target_slot !== null) {\n        var _LiteGraph$debug8;\n        (_LiteGraph$debug8 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug8 === void 0 || _LiteGraph$debug8.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"CONNbyTYPE type \" + target_slotType + \" for \" + target_slot);\n        return this.connect(slot, target_node, target_slot);\n      } else {\n        var _LiteGraph$debug12;\n        // LiteGraph.log?.(\"type \"+target_slotType+\" not found or not free?\")\n        if (opts.createEventInCase && target_slotType == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT) {\n          var _LiteGraph$debug9;\n          // WILL CREATE THE onTrigger IN SLOT\n          (_LiteGraph$debug9 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug9 === void 0 || _LiteGraph$debug9.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"connect WILL CREATE THE onTrigger \" + target_slotType + \" to \" + target_node);\n          return this.connect(slot, target_node, -1);\n        }\n        // connect to the first general output slot if not found a specific type and\n        if (opts.generalTypeInCase) {\n          var _LiteGraph$debug10;\n          target_slot = target_node.findInputSlotByType(0, false, true, true);\n          (_LiteGraph$debug10 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug10 === void 0 || _LiteGraph$debug10.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"connect TO a general type (*, 0), if not found the specific type \", target_slotType, \" to \", target_node, \"RES_SLOT:\", target_slot);\n          if (target_slot >= 0) {\n            return this.connect(slot, target_node, target_slot);\n          }\n        }\n        // connect to the first free input slot if not found a specific type and this output is general\n        if (opts.firstFreeIfOutputGeneralInCase && (target_slotType == 0 || target_slotType == \"*\" || target_slotType == \"\")) {\n          var _LiteGraph$debug11;\n          target_slot = target_node.findInputSlotFree({\n            typesNotAccepted: [_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT]\n          });\n          (_LiteGraph$debug11 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug11 === void 0 || _LiteGraph$debug11.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"connect TO TheFirstFREE \", target_slotType, \" to \", target_node, \"RES_SLOT:\", target_slot);\n          if (target_slot >= 0) {\n            return this.connect(slot, target_node, target_slot);\n          }\n        }\n        (_LiteGraph$debug12 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug12 === void 0 || _LiteGraph$debug12.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"no way to connect type: \", target_slotType, \" to targetNODE \", target_node);\n        // TODO filter\n\n        return null;\n      }\n    }\n\n    /**\r\n     * connect this node input to the output of another node BY TYPE\r\n     * @method connectByType\r\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\r\n     * @param {LGraphNode} node the target node\r\n     * @param {string} target_type the output slot type of the target node\r\n     * @return {Object} the link_info is created, otherwise null\r\n     */\n  }, {\n    key: \"connectByTypeOutput\",\n    value: function connectByTypeOutput(slot, source_node) {\n      var source_slotType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"*\";\n      var optsIn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var optsDef = {\n        createEventInCase: true,\n        firstFreeIfInputGeneralInCase: true,\n        generalTypeInCase: true\n      };\n      var opts = Object.assign(optsDef, optsIn);\n      if (source_node && source_node.constructor === Number) {\n        source_node = this.graph.getNodeById(source_node);\n      }\n      var source_slot = source_node.findOutputSlotByType(source_slotType, false, true);\n      if (source_slot >= 0 && source_slot !== null) {\n        var _LiteGraph$debug13;\n        (_LiteGraph$debug13 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug13 === void 0 || _LiteGraph$debug13.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"CONNbyTYPE OUT! type \" + source_slotType + \" for \" + source_slot);\n        return source_node.connect(source_slot, this, slot);\n      } else {\n        var _LiteGraph$debug14, _LiteGraph$log;\n        // connect to the first general output slot if not found a specific type and\n        if (opts.generalTypeInCase) {\n          source_slot = source_node.findOutputSlotByType(0, false, true, true);\n          if (source_slot >= 0) {\n            return source_node.connect(source_slot, this, slot);\n          }\n        }\n        if (opts.createEventInCase && source_slotType == _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT) {\n          // WILL CREATE THE onExecuted OUT SLOT\n          if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.do_add_triggers_slots) {\n            source_slot = source_node.addOnExecutedOutput();\n            return source_node.connect(source_slot, this, slot);\n          }\n        }\n        // connect to the first free output slot if not found a specific type and this input is general\n        if (opts.firstFreeIfInputGeneralInCase && (source_slotType == 0 || source_slotType == \"*\" || source_slotType == \"\" || source_slotType == \"undefined\")) {\n          source_slot = source_node.findOutputSlotFree({\n            typesNotAccepted: [_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT]\n          });\n          if (source_slot >= 0) {\n            return source_node.connect(source_slot, this, slot);\n          }\n        }\n        (_LiteGraph$debug14 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug14 === void 0 || _LiteGraph$debug14.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"no way to connect byOUT type: \", source_slotType, \" to sourceNODE \", source_node);\n        // TODO filter\n\n        (_LiteGraph$log = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log === void 0 || _LiteGraph$log.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"type OUT! \" + source_slotType + \" not found or not free?\");\n        return null;\n      }\n    }\n\n    /**\r\n     * connect this node output to the input of another node\r\n     * @method connect\r\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\r\n     * @param {LGraphNode} node the target node\r\n     * @param {number_or_string} target_slot the input slot of the target node (could be the number of the slot or the string with the name of the slot, or -1 to connect a trigger)\r\n     * @return {Object} the link_info is created, otherwise null\r\n     */\n  }, {\n    key: \"connect\",\n    value: function connect(slot, target_node) {\n      var _this$onConnectOutput, _target_node$onConnec, _target_node, _this$onConnectOutput2, _output$links, _this$onConnectionsCh3, _target_node$onConnec2, _target_node2;\n      var target_slot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      if (!this.graph) {\n        var _LiteGraph$log2;\n        // could be connected before adding it to a graph\n        (_LiteGraph$log2 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log2 === void 0 || _LiteGraph$log2.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them.\"); // due to link ids being associated with graphs\n        return null;\n      }\n\n      // seek for the output slot\n      if (slot.constructor === String) {\n        slot = this.findOutputSlot(slot);\n        if (slot == -1) {\n          var _LiteGraph$log3;\n          (_LiteGraph$log3 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log3 === void 0 || _LiteGraph$log3.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Connect: Error, no slot of name \".concat(slot));\n          return null;\n        }\n      } else if (!this.outputs || slot >= this.outputs.length) {\n        var _LiteGraph$log4;\n        (_LiteGraph$log4 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log4 === void 0 || _LiteGraph$log4.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Connect: Error, slot number not found\");\n        return null;\n      }\n      if (target_node && target_node.constructor === Number) {\n        target_node = this.graph.getNodeById(target_node);\n      }\n      if (!target_node) {\n        throw new Error(\"target node is null\");\n      }\n\n      // avoid loopback\n      if (target_node == this) {\n        return null;\n      }\n\n      // you can specify the slot by name\n      if (target_slot.constructor === String) {\n        target_slot = target_node.findInputSlot(target_slot);\n        if (target_slot == -1) {\n          var _LiteGraph$log5;\n          (_LiteGraph$log5 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log5 === void 0 || _LiteGraph$log5.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Connect: Error, no slot of name \".concat(target_slot));\n          return null;\n        }\n      } else if (target_slot === _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT) {\n        if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.do_add_triggers_slots) {\n          // search for first slot with event? :: NO this is done outside\n          // LiteGraph.log?.(\"Connect: Creating triggerEvent\");\n          // force mode\n          target_node.changeMode(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ON_TRIGGER);\n          target_slot = target_node.findInputSlot(\"onTrigger\");\n        } else {\n          return null; // -- break --\n        }\n      } else if (!target_node.inputs || target_slot >= target_node.inputs.length) {\n        var _LiteGraph$log6;\n        (_LiteGraph$log6 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log6 === void 0 || _LiteGraph$log6.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Connect: Error, slot number not found\");\n        return null;\n      }\n      var changed = false;\n      var input = target_node.inputs[target_slot];\n      var link_info = null;\n      var output = this.outputs[slot];\n      if (!this.outputs[slot]) {\n        var _LiteGraph$log7;\n        (_LiteGraph$log7 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log7 === void 0 || _LiteGraph$log7.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Invalid slot passed: \", slot, this.outputs);\n        return null;\n      }\n      if (target_node.onBeforeConnectInput) {\n        target_slot = target_node.onBeforeConnectInput(target_node); // callback\n      }\n      if (((_this$onConnectOutput = this.onConnectOutput) === null || _this$onConnectOutput === void 0 ? void 0 : _this$onConnectOutput.call(this, slot, input.type, input, target_node, target_slot)) === false) {\n        return null;\n      }\n\n      // check target_slot and check connection types\n      if (target_slot === false || target_slot === null || !_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.isValidConnection(output.type, input.type)) {\n        this.setDirtyCanvas(false, true);\n        if (changed) this.graph.connectionChange(this, link_info);\n        return null;\n      } else {\n        var _LiteGraph$debug15;\n        (_LiteGraph$debug15 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.debug) === null || _LiteGraph$debug15 === void 0 || _LiteGraph$debug15.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"DBG targetSlot\", target_slot);\n      }\n\n      // allows nodes to block connection, callback\n      if (((_target_node$onConnec = (_target_node = target_node).onConnectInput) === null || _target_node$onConnec === void 0 ? void 0 : _target_node$onConnec.call(_target_node, target_slot, output.type, output, this, slot)) === false) {\n        return null;\n      }\n      if (((_this$onConnectOutput2 = this.onConnectOutput) === null || _this$onConnectOutput2 === void 0 ? void 0 : _this$onConnectOutput2.call(this, slot, input.type, input, target_node, target_slot)) === false) {\n        return null;\n      }\n\n      // if there is something already plugged there, disconnect\n      if (target_node.inputs[target_slot] && target_node.inputs[target_slot].link != null) {\n        this.graph.beforeChange();\n        target_node.disconnectInput(target_slot, {\n          doProcessChange: false\n        });\n        changed = true;\n      }\n      if ((_output$links = output.links) !== null && _output$links !== void 0 && _output$links.length) {\n        switch (output.type) {\n          case _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT:\n            if (!_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.allow_multi_output_for_events) {\n              this.graph.beforeChange();\n              this.disconnectOutput(slot, false, {\n                doProcessChange: false\n              }); // Input(target_slot, {doProcessChange: false});\n              changed = true;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n      var nextId;\n      if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.use_uuids) nextId = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.uuidv4();else nextId = ++this.graph.last_link_id;\n\n      // create link class\n      link_info = new _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.LLink(nextId, input.type || output.type, this.id, slot, target_node.id, target_slot);\n\n      // add to graph links list\n      this.graph.links[link_info.id] = link_info;\n\n      // connect in output\n      if (output.links == null) {\n        output.links = [];\n      }\n      output.links.push(link_info.id);\n      // connect in input\n      if (typeof target_node.inputs[target_slot] == \"undefined\") {\n        var _LiteGraph$warn5;\n        (_LiteGraph$warn5 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.warn) === null || _LiteGraph$warn5 === void 0 || _LiteGraph$warn5.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"FIXME error, target_slot does not exists on target_node\", target_node, target_slot);\n      }\n      target_node.inputs[target_slot].link = link_info.id;\n      (_this$onConnectionsCh3 = this.onConnectionsChange) === null || _this$onConnectionsCh3 === void 0 || _this$onConnectionsCh3.call(this, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.OUTPUT, slot, true, link_info, output);\n      // link_info has been created now, so its updated\n      (_target_node$onConnec2 = (_target_node2 = target_node).onConnectionsChange) === null || _target_node$onConnec2 === void 0 || _target_node$onConnec2.call(_target_node2, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.INPUT, target_slot, true, link_info, input);\n      if (this.graph && this.graph.onNodeConnectionChange) {\n        this.graph.onNodeConnectionChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.INPUT, target_node, target_slot, this, slot);\n        this.graph.onNodeConnectionChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.OUTPUT, this, slot, target_node, target_slot);\n      }\n      this.graph.onGraphChanged({\n        action: \"connect\"\n      });\n      this.setDirtyCanvas(false, true);\n      this.graph.afterChange();\n      this.graph.connectionChange(this, link_info);\n      return link_info;\n    }\n\n    /**\r\n     * disconnect one output to an specific node\r\n     * @method disconnectOutput\r\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\r\n     * @param {LGraphNode} target_node the target node to which this slot is connected [Optional, if not target_node is specified all nodes will be disconnected]\r\n     * @return {boolean} if it was disconnected successfully\r\n     */\n  }, {\n    key: \"disconnectOutput\",\n    value: function disconnectOutput(slot, target_node) {\n      var optsIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var optsDef = {\n        doProcessChange: true\n      };\n      var opts = Object.assign(optsDef, optsIn);\n      if (slot.constructor === String) {\n        slot = this.findOutputSlot(slot);\n        if (slot == -1) {\n          var _LiteGraph$log8;\n          (_LiteGraph$log8 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log8 === void 0 || _LiteGraph$log8.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Connect: Error, no slot of name \".concat(slot));\n          return false;\n        }\n      } else if (!this.outputs || slot >= this.outputs.length) {\n        var _LiteGraph$log9;\n        (_LiteGraph$log9 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log9 === void 0 || _LiteGraph$log9.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Connect: Error, slot number not found\");\n        return false;\n      }\n\n      // get output slot\n      var output = this.outputs[slot];\n      if (!output || !output.links || output.links.length == 0) {\n        return false;\n      }\n\n      // one of the output links in this slot\n      if (target_node) {\n        if (target_node.constructor === Number) {\n          target_node = this.graph.getNodeById(target_node);\n        }\n        if (!target_node) {\n          throw new Error(\"Target Node not found\");\n        }\n        for (var i = 0, l = output.links.length; i < l; i++) {\n          var link_id = output.links[i];\n          var link_info = this.graph.links[link_id];\n\n          // is the link we are searching for...\n          if (link_info.target_id == target_node.id) {\n            var _this$graph2, _target_node$onConnec3, _target_node3, _this$onConnectionsCh4;\n            output.links.splice(i, 1); // remove here\n            var input = target_node.inputs[link_info.target_slot];\n            input.link = null; // remove there\n            delete this.graph.links[link_id]; // remove the link from the links pool\n            (_this$graph2 = this.graph) === null || _this$graph2 === void 0 || _this$graph2.onGraphChanged({\n              action: \"disconnectOutput\",\n              doSave: opts.doProcessChange\n            });\n            (_target_node$onConnec3 = (_target_node3 = target_node).onConnectionsChange) === null || _target_node$onConnec3 === void 0 || _target_node$onConnec3.call(_target_node3, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.INPUT, link_info.target_slot, false, link_info, input);\n            // link_info hasn't been modified so its ok\n            (_this$onConnectionsCh4 = this.onConnectionsChange) === null || _this$onConnectionsCh4 === void 0 || _this$onConnectionsCh4.call(this, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.OUTPUT, slot, false, link_info, output);\n            if (this.graph && this.graph.onNodeConnectionChange) {\n              this.graph.onNodeConnectionChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.OUTPUT, this, slot);\n              this.graph.onNodeConnectionChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.OUTPUT, this, slot);\n              this.graph.onNodeConnectionChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.INPUT, target_node, link_info.target_slot);\n            }\n            break;\n          }\n        }\n      } else {\n        // all the links in this output slot\n        for (var _i3 = 0, _l3 = output.links.length; _i3 < _l3; _i3++) {\n          var _this$graph3;\n          var _link_id = output.links[_i3];\n          var _link_info = this.graph.links[_link_id];\n          if (!_link_info) {\n            // bug: it happens sometimes\n            continue;\n          }\n          target_node = this.graph.getNodeById(_link_info.target_id);\n          input = null;\n          (_this$graph3 = this.graph) === null || _this$graph3 === void 0 || _this$graph3.onGraphChanged({\n            action: \"disconnectOutput\",\n            doSave: opts.doProcessChange\n          });\n          if (target_node) {\n            input = target_node.inputs[_link_info.target_slot];\n            input.link = null; // remove other side link\n            if (target_node.onConnectionsChange) {\n              target_node.onConnectionsChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.INPUT, _link_info.target_slot, false, _link_info, input);\n            } // link_info hasn't been modified so its ok\n            if (this.graph && this.graph.onNodeConnectionChange) {\n              this.graph.onNodeConnectionChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.INPUT, target_node, _link_info.target_slot);\n            }\n          }\n          delete this.graph.links[_link_id]; // remove the link from the links pool\n          if (this.onConnectionsChange) {\n            this.onConnectionsChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.OUTPUT, slot, false, _link_info, output);\n          }\n          if (this.graph && this.graph.onNodeConnectionChange) {\n            this.graph.onNodeConnectionChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.OUTPUT, this, slot);\n            this.graph.onNodeConnectionChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.INPUT, target_node, _link_info.target_slot);\n          }\n        }\n        output.links = null;\n      }\n      this.setDirtyCanvas(false, true);\n      this.graph.connectionChange(this);\n      return true;\n    }\n\n    /**\r\n     * disconnect one input\r\n     * @method disconnectInput\r\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\r\n     * @return {boolean} if it was disconnected successfully\r\n     */\n  }, {\n    key: \"disconnectInput\",\n    value: function disconnectInput(slot) {\n      var optsIn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var optsDef = {\n        doProcessChange: true\n      };\n      var opts = Object.assign(optsDef, optsIn);\n\n      // seek for the output slot\n      if (slot.constructor === String) {\n        slot = this.findInputSlot(slot);\n        if (slot == -1) {\n          var _LiteGraph$log10;\n          (_LiteGraph$log10 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log10 === void 0 || _LiteGraph$log10.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Connect: Error, no slot of name \".concat(slot));\n          return false;\n        }\n      } else if (!this.inputs || slot >= this.inputs.length) {\n        var _LiteGraph$log11;\n        (_LiteGraph$log11 = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.log) === null || _LiteGraph$log11 === void 0 || _LiteGraph$log11.call(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph, \"Connect: Error, slot number not found\");\n        return false;\n      }\n      var input = this.inputs[slot];\n      if (!input) {\n        return false;\n      }\n      var link_id = this.inputs[slot].link;\n      if (link_id != null) {\n        this.inputs[slot].link = null;\n\n        // remove other side\n        var link_info = this.graph.links[link_id];\n        if (link_info) {\n          var _this$graph4;\n          var target_node = this.graph.getNodeById(link_info.origin_id);\n          if (!target_node) {\n            return false;\n          }\n          var output = target_node.outputs[link_info.origin_slot];\n          if (!output || !output.links || output.links.length == 0) {\n            return false;\n          }\n\n          // search in the inputs list for this link\n          for (var i = 0, l = output.links.length; i < l; i++) {\n            if (output.links[i] == link_id) {\n              output.links.splice(i, 1);\n              break;\n            }\n          }\n          delete this.graph.links[link_id]; // remove from the pool\n          (_this$graph4 = this.graph) === null || _this$graph4 === void 0 || _this$graph4.onGraphChanged({\n            action: \"disconnectInput\",\n            doSave: opts.doProcessChange\n          });\n          if (this.onConnectionsChange) {\n            this.onConnectionsChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.INPUT, slot, false, link_info, input);\n          }\n          if (target_node.onConnectionsChange) {\n            target_node.onConnectionsChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.OUTPUT, i, false, link_info, output);\n          }\n          if (this.graph && this.graph.onNodeConnectionChange) {\n            this.graph.onNodeConnectionChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.OUTPUT, target_node, i);\n            this.graph.onNodeConnectionChange(_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.INPUT, this, slot);\n          }\n        }\n      } // link != null\n\n      this.setDirtyCanvas(false, true);\n      if (this.graph) this.graph.connectionChange(this);\n      return true;\n    }\n\n    /**\r\n     * Returns the center of a connection point in canvas coordinates\r\n     * @method getConnectionPos\r\n     * @param {boolean} is_input - True if it is an input slot, false if it is an output slot\r\n     * @param {number | string} slot - Could be the number of the slot or the string with the name of the slot\r\n     * @param {vec2} [out] - [Optional] A place to store the output to reduce garbage\r\n     * @return {Float32[]} The position as [x, y]\r\n     */\n  }, {\n    key: \"getConnectionPos\",\n    value: function getConnectionPos(is_input, slot_number) {\n      var out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Float32Array(2);\n      var num_slots = 0;\n      if (is_input && this.inputs) {\n        num_slots = this.inputs.length;\n      }\n      if (!is_input && this.outputs) {\n        num_slots = this.outputs.length;\n      }\n      var offset = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_SLOT_HEIGHT * 0.5;\n      if (this.flags.collapsed) {\n        var w = this._collapsed_width || _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_COLLAPSED_WIDTH;\n        if (this.horizontal) {\n          out[0] = this.pos[0] + w * 0.5;\n          if (is_input) {\n            out[1] = this.pos[1] - _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT;\n          } else {\n            out[1] = this.pos[1];\n          }\n        } else {\n          if (is_input) {\n            out[0] = this.pos[0];\n          } else {\n            out[0] = this.pos[0] + w;\n          }\n          out[1] = this.pos[1] - _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT * 0.5;\n        }\n        return out;\n      }\n\n      // weird feature that never got finished\n      if (is_input && slot_number == -1) {\n        out[0] = this.pos[0] + _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT * 0.5;\n        out[1] = this.pos[1] + _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT * 0.5;\n        return out;\n      }\n\n      // hard-coded pos\n      if (is_input && num_slots > slot_number && this.inputs[slot_number].pos) {\n        out[0] = this.pos[0] + this.inputs[slot_number].pos[0];\n        out[1] = this.pos[1] + this.inputs[slot_number].pos[1];\n        return out;\n      } else if (!is_input && num_slots > slot_number && this.outputs[slot_number].pos) {\n        out[0] = this.pos[0] + this.outputs[slot_number].pos[0];\n        out[1] = this.pos[1] + this.outputs[slot_number].pos[1];\n        return out;\n      }\n\n      // horizontal distributed slots\n      if (this.horizontal) {\n        out[0] = this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);\n        if (is_input) {\n          out[1] = this.pos[1] - _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_TITLE_HEIGHT;\n        } else {\n          out[1] = this.pos[1] + this.size[1];\n        }\n        return out;\n      }\n\n      // default vertical slots\n      if (is_input) {\n        out[0] = this.pos[0] + offset;\n      } else {\n        out[0] = this.pos[0] + this.size[0] + 1 - offset;\n      }\n      out[1] = this.pos[1] + (slot_number + 0.7) * _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NODE_SLOT_HEIGHT + (this.constructor.slot_start_y || 0);\n      return out;\n    }\n\n    /* Force align to grid */\n  }, {\n    key: \"alignToGrid\",\n    value: function alignToGrid() {\n      this.pos[0] = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CANVAS_GRID_SIZE * Math.round(this.pos[0] / _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CANVAS_GRID_SIZE);\n      this.pos[1] = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CANVAS_GRID_SIZE * Math.round(this.pos[1] / _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.CANVAS_GRID_SIZE);\n    }\n\n    /* Console output */\n  }, {\n    key: \"trace\",\n    value: function trace(msg) {\n      var _this$console$push, _this$console;\n      if (!this.console) {\n        this.console = [];\n      }\n      (_this$console$push = (_this$console = this.console).push) === null || _this$console$push === void 0 || _this$console$push.call(_this$console, msg);\n      if (this.console.length > LGraphNode.MAX_CONSOLE) {\n        var _this$console$shift, _this$console2;\n        (_this$console$shift = (_this$console2 = this.console).shift) === null || _this$console$shift === void 0 || _this$console$shift.call(_this$console2);\n      }\n      if (this.graph.onNodeTrace) this.graph.onNodeTrace(this, msg);\n    }\n\n    /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */\n  }, {\n    key: \"setDirtyCanvas\",\n    value: function setDirtyCanvas(dirty_foreground, dirty_background) {\n      if (!this.graph) {\n        return;\n      }\n      this.graph.sendActionToCanvas(\"setDirty\", [dirty_foreground, dirty_background]);\n    }\n  }, {\n    key: \"loadImage\",\n    value: function loadImage(url) {\n      var img = new Image();\n      img.src = _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.node_images_path + url;\n      img.ready = false;\n      var that = this;\n      img.onload = function () {\n        this.ready = true;\n        that.setDirtyCanvas(true);\n      };\n      return img;\n    }\n\n    // safe LGraphNode action execution (not sure if safe)\n    /*\r\n    LGraphNode.prototype.executeAction = function(action)\r\n    {\r\n    if(action == \"\") return false;\r\n      if( action.indexOf(\";\") != -1 || action.indexOf(\"}\") != -1)\r\n    {\r\n        this.trace(\"Error: Action contains unsafe characters\");\r\n        return false;\r\n    }\r\n      var tokens = action.split(\"(\");\r\n    var func_name = tokens[0];\r\n    if( typeof(this[func_name]) != \"function\")\r\n    {\r\n        this.trace(\"Error: Action not found on node: \" + func_name);\r\n        return false;\r\n    }\r\n      var code = action;\r\n      try\r\n    {\r\n        var _foo = eval;\r\n        eval = null;\r\n        (new Function(\"with(this) { \" + code + \"}\")).call(this);\r\n        eval = _foo;\r\n    }\r\n    catch (err)\r\n    {\r\n        this.trace(\"Error executing action {\" + action + \"} :\" + err);\r\n        return false;\r\n    }\r\n      return true;\r\n    }\r\n    */\n\n    /* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */\n  }, {\n    key: \"captureInput\",\n    value: function captureInput(v) {\n      if (!this.graph || !this.graph.list_of_graphcanvas) {\n        return;\n      }\n      var list = this.graph.list_of_graphcanvas;\n      for (var i = 0; i < list.length; ++i) {\n        var c = list[i];\n        // releasing somebody elses capture?!\n        if (!v && c.node_capturing_input != this) {\n          continue;\n        }\n\n        // change\n        c.node_capturing_input = v ? this : null;\n      }\n    }\n\n    /**\r\n     * Collapse the node to make it smaller on the canvas\r\n     * @method collapse\r\n     **/\n  }, {\n    key: \"collapse\",\n    value: function collapse(force) {\n      this.graph.onGraphChanged({\n        action: \"collapse\"\n      });\n      if (this.constructor.collapsable === false && !force) {\n        return;\n      }\n      if (!this.flags.collapsed) {\n        this.flags.collapsed = true;\n      } else {\n        this.flags.collapsed = false;\n      }\n      this.setDirtyCanvas(true, true);\n    }\n\n    /**\r\n     * Forces the node to do not move or realign on Z\r\n     * @method pin\r\n     **/\n  }, {\n    key: \"pin\",\n    value: function pin(v) {\n      this.graph.onGraphChanged({\n        action: \"pin\"\n      });\n      if (v === undefined) {\n        this.flags.pinned = !this.flags.pinned;\n      } else {\n        this.flags.pinned = v;\n      }\n    }\n  }, {\n    key: \"localToScreen\",\n    value: function localToScreen(x, y, graphcanvas) {\n      return [(x + this.pos[0]) * graphcanvas.scale + graphcanvas.offset[0], (y + this.pos[1]) * graphcanvas.scale + graphcanvas.offset[1]];\n    }\n  }, {\n    key: \"refreshAncestors\",\n    value: function refreshAncestors() {\n      var optsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var optsDef = {\n        action: \"\",\n        param: null,\n        options: null,\n        passParam: true\n      };\n      var opts = Object.assign(optsDef, optsIn);\n      if (!this.inputs) {\n        return;\n      }\n      if (_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.preventAncestorRecalculation) {\n        if (this.graph.node_ancestorsCalculated && this.graph.node_ancestorsCalculated[this.id]) {\n          // LiteGraph.debug?.(\"NODE already calculated subtree! Prevent! \"+this.id+\":\"+this.order);\n          return;\n        }\n      }\n      if (!opts.action || opts.action == \"\") opts.action = this.id + \"_ancestors\";\n      if (!opts.param || opts.param == \"\") opts.param = this.id + \"_ancestors\";\n      if (!opts.options) opts.options = {};\n      opts.options = Object.assign({\n        action_call: opts.action\n      }, opts.options);\n\n      // LiteGraph.debug?.(\"ancestors processing\");\n      // LiteGraph.debug?.(this.id+\":\"+this.order+\" \"+opts.options.action_call);\n\n      this.graph.ancestorsCall = true; // prevent triggering slots\n\n      var optsAncestors = {\n        modesSkip: [_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.NEVER, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ON_EVENT, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ON_TRIGGER],\n        modesOnly: [_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ALWAYS, _litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ON_REQUEST],\n        typesSkip: [_litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION],\n        typesOnly: []\n      };\n      var aAncestors = this.graph.getAncestors(this, optsAncestors);\n      for (iN in aAncestors) {\n        aAncestors[iN].doExecute(opts.param, opts.options);\n        this.graph.node_ancestorsCalculated[aAncestors[iN].id] = true;\n      }\n      this.graph.ancestorsCall = false; // restore triggering slots\n      this.graph.node_ancestorsCalculated[this.id] = true;\n      return true;\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://LiteGraphJS/./src/lgraphnode.js?");

/***/ }),

/***/ "./src/litegraph.js":
/*!**************************!*\
  !*** ./src/litegraph.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiteGraph: () => (/* binding */ LiteGraph)\n/* harmony export */ });\n/* harmony import */ var _llink_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./llink.js */ \"./src/llink.js\");\n/* harmony import */ var _lgraph_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lgraph.js */ \"./src/lgraph.js\");\n/* harmony import */ var _lgraphnode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lgraphnode.js */ \"./src/lgraphnode.js\");\n/* harmony import */ var _lgraphgroup_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lgraphgroup.js */ \"./src/lgraphgroup.js\");\n/* harmony import */ var _lgraphcanvas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lgraphcanvas.js */ \"./src/lgraphcanvas.js\");\n/* harmony import */ var _dragandscale_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dragandscale.js */ \"./src/dragandscale.js\");\n/* harmony import */ var _contextmenu_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./contextmenu.js */ \"./src/contextmenu.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n\n\n\n/**\r\n * @class LiteGraph\r\n *\r\n * @NOTE:\r\n * Try to avoid adding things to this class.\r\n * https://dzone.com/articles/singleton-anti-pattern\r\n */\nvar LiteGraph = new ( /*#__PURE__*/function () {\n  function _class() {\n    _classCallCheck(this, _class);\n    _defineProperty(this, \"extendClass\", function (target, origin) {\n      for (var i in origin) {\n        // copy class properties\n        if (target.hasOwnProperty(i)) {\n          continue;\n        }\n        target[i] = origin[i];\n      }\n      if (origin.prototype) {\n        // copy prototype properties\n        for (var _i in origin.prototype) {\n          // only enumerable\n          if (!origin.prototype.hasOwnProperty(_i)) {\n            continue;\n          }\n          if (target.prototype.hasOwnProperty(_i)) {\n            // avoid overwriting existing ones\n            continue;\n          }\n\n          // copy getters\n          if (origin.prototype.__lookupGetter__(_i)) {\n            target.prototype.__defineGetter__(_i, origin.prototype.__lookupGetter__(_i));\n          } else {\n            target.prototype[_i] = origin.prototype[_i];\n          }\n\n          // and setters\n          if (origin.prototype.__lookupSetter__(_i)) {\n            target.prototype.__defineSetter__(_i, origin.prototype.__lookupSetter__(_i));\n          }\n        }\n      }\n    });\n    // used to create nodes from wrapping functions\n    _defineProperty(this, \"getParameterNames\", function (func) {\n      // split & filter [\"\"]\n      return (func + \"\").replace(/[/][/].*$/gm, \"\") // strip single-line comments\n      .replace(/\\s+/g, \"\") // strip white space\n      .replace(/[/][*][^/*]*[*][/]/g, \"\") // strip multi-line comments  /**/\n      .split(\"){\", 1)[0].replace(/^[^(]*[(]/, \"\") // extract the parameters\n      .replace(/=[^,]+/g, \"\") // strip any ES6 defaults\n      .split(\",\").filter(Boolean);\n    });\n    _defineProperty(this, \"clamp\", function (v, a, b) {\n      return a > v ? a : b < v ? b : v;\n    });\n    // @BUG: Re-add these\n    _defineProperty(this, \"pointerAddListener\", function () {\n      var _console$error, _console;\n      (_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, \"Removed and being re-integrated sorta\");\n    });\n    _defineProperty(this, \"pointerRemoveListener\", function () {\n      var _console$error2, _console2;\n      (_console$error2 = (_console2 = console).error) === null || _console$error2 === void 0 || _console$error2.call(_console2, \"Removed and being re-integrated sorta\");\n    });\n    _defineProperty(this, \"closeAllContextMenus\", function () {\n      LiteGraph.warn('LiteGraph.closeAllContextMenus is deprecated in favor of ContextMenu.closeAll()');\n      _contextmenu_js__WEBPACK_IMPORTED_MODULE_6__.ContextMenu.closeAll();\n    });\n    this.VERSION = \"0.10.2\";\n\n    // from OG LiteGraph, just bringing it back for compatibility\n    this.LLink = _llink_js__WEBPACK_IMPORTED_MODULE_0__.LLink;\n    this.LGraph = _lgraph_js__WEBPACK_IMPORTED_MODULE_1__.LGraph;\n    this.LGraphNode = _lgraphnode_js__WEBPACK_IMPORTED_MODULE_2__.LGraphNode;\n    this.LGraphGroup = _lgraphgroup_js__WEBPACK_IMPORTED_MODULE_3__.LGraphGroup;\n    this.LGraphCanvas = _lgraphcanvas_js__WEBPACK_IMPORTED_MODULE_4__.LGraphCanvas;\n    this.DragAndScale = _dragandscale_js__WEBPACK_IMPORTED_MODULE_5__.DragAndScale;\n    this.ContextMenu = _contextmenu_js__WEBPACK_IMPORTED_MODULE_6__.ContextMenu;\n    this.CANVAS_GRID_SIZE = 10;\n    this.NODE_TITLE_HEIGHT = 30;\n    this.NODE_TITLE_TEXT_Y = 20;\n    this.NODE_SLOT_HEIGHT = 20;\n    this.NODE_WIDGET_HEIGHT = 20;\n    this.NODE_WIDTH = 140;\n    this.NODE_MIN_WIDTH = 50;\n    this.NODE_COLLAPSED_RADIUS = 10;\n    this.NODE_COLLAPSED_WIDTH = 80;\n    this.NODE_TITLE_COLOR = \"#999\";\n    this.NODE_SELECTED_TITLE_COLOR = \"#FFF\";\n    this.NODE_TEXT_SIZE = 14;\n    this.NODE_TEXT_COLOR = \"#AAA\";\n    this.NODE_SUBTEXT_SIZE = 12;\n    this.NODE_DEFAULT_COLOR = \"#333\";\n    this.NODE_DEFAULT_BGCOLOR = \"#353535\";\n    this.NODE_DEFAULT_BOXCOLOR = \"#666\";\n    this.NODE_DEFAULT_SHAPE = \"box\";\n    this.NODE_BOX_OUTLINE_COLOR = \"#FFF\";\n    this.DEFAULT_SHADOW_COLOR = \"rgba(0,0,0,0.5)\";\n    this.DEFAULT_GROUP_FONT = 24;\n    this.WIDGET_BGCOLOR = \"#222\";\n    this.WIDGET_OUTLINE_COLOR = \"#666\";\n    this.WIDGET_TEXT_COLOR = \"#DDD\";\n    this.WIDGET_SECONDARY_TEXT_COLOR = \"#999\";\n    this.LINK_COLOR = \"#9A9\";\n    this.EVENT_LINK_COLOR = \"#A86\";\n    this.CONNECTING_LINK_COLOR = \"#AFA\";\n    this.MAX_NUMBER_OF_NODES = 1000; // avoid infinite loops\n    this.DEFAULT_POSITION = [100, 100]; // default node position\n    this.VALID_SHAPES = [\"default\", \"box\", \"round\", \"card\"]; // ,\"circle\"\n\n    // shapes are used for nodes but also for slots\n    this.BOX_SHAPE = 1;\n    this.ROUND_SHAPE = 2;\n    this.CIRCLE_SHAPE = 3;\n    this.CARD_SHAPE = 4;\n    this.ARROW_SHAPE = 5;\n    this.GRID_SHAPE = 6; // intended for slot arrays\n\n    // enums\n    this.INPUT = 1;\n    this.OUTPUT = 2;\n    this.EVENT = -1; // for outputs\n    this.ACTION = -1; // for inputs\n\n    this.NODE_MODES = [\"Always\", \"On Event\", \"Never\", \"On Trigger\", \"On Request\"]; // helper, will add \"On Request\" and more in the future\n    this.NODE_MODES_COLORS = [\"#666\", \"#422\", \"#333\", \"#224\", \"#626\"]; // use with node_box_coloured_by_mode\n    this.ALWAYS = 0;\n    this.ON_EVENT = 1;\n    this.NEVER = 2;\n    this.ON_TRIGGER = 3;\n    this.ON_REQUEST = 4; // used from event-based nodes, where ancestors are recursively executed on needed\n\n    this.UP = 1;\n    this.DOWN = 2;\n    this.LEFT = 3;\n    this.RIGHT = 4;\n    this.CENTER = 5;\n    this.LINK_RENDER_MODES = [\"Straight\", \"Linear\", \"Spline\"]; // helper\n    this.STRAIGHT_LINK = 0;\n    this.LINEAR_LINK = 1;\n    this.SPLINE_LINK = 2;\n    this.NORMAL_TITLE = 0;\n    this.NO_TITLE = 1;\n    this.TRANSPARENT_TITLE = 2;\n    this.AUTOHIDE_TITLE = 3;\n    this.VERTICAL_LAYOUT = \"vertical\"; // arrange nodes vertically\n\n    this.proxy = null; // used to redirect calls\n    this.node_images_path = \"\";\n    this.catch_exceptions = true;\n    this.throw_errors = true;\n    this.allow_scripts = false; // if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration), which could lead to exploits\n    this.use_deferred_actions = true; // executes actions during the graph execution flow\n    this.registered_node_types = {}; // nodetypes by string\n    this.node_types_by_file_extension = {}; // used for dropping files in the canvas\n    this.Nodes = {}; // node types by classname\n    this.Globals = {}; // used to store vars between graphs\n\n    this.searchbox_extras = {}; // used to add extra features to the search box\n    this.auto_sort_node_types = false; // [true!] If set to true, will automatically sort node types / categories in the context menus\n\n    this.node_box_coloured_when_on = false; // [true!] this make the nodes box (top left circle) coloured when triggered (execute/action), visual feedback\n    this.node_box_coloured_by_mode = false; // [true!] nodebox based on node mode, visual feedback\n\n    this.dialog_close_on_mouse_leave = true; // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false\n    this.dialog_close_on_mouse_leave_delay = 500;\n    this.shift_click_do_break_link_from = false; // [false!] prefer false if results too easy to break links - implement with ALT or TODO custom keys\n    this.click_do_break_link_to = false; // [false!]prefer false, way too easy to break links\n\n    this.search_hide_on_mouse_leave = true; // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false\n    this.search_filter_enabled = false; // [true!] enable filtering slots type in the search widget, !requires auto_load_slot_types or manual set registered_slot_[in/out]_types and slot_types_[in/out]\n    this.search_show_all_on_open = true; // [true!] opens the results list when opening the search widget\n\n    this.show_node_tooltip = false; // [true!] show a tooltip with node property \"tooltip\" over the selected node\n    this.show_node_tooltip_use_descr_property = false; // enabled tooltip from desc when property tooltip not set\n\n    this.auto_load_slot_types = false; // [if want false, use true, run, get vars values to be statically set, than disable] nodes types and nodeclass association with node types need to be calculated, if dont want this, calculate once and set registered_slot_[in/out]_types and slot_types_[in/out]\n\n    // set these values if not using auto_load_slot_types\n    this.registered_slot_in_types = {}; // slot types for nodeclass\n    this.registered_slot_out_types = {}; // slot types for nodeclass\n    this.slot_types_in = []; // slot types IN\n    this.slot_types_out = []; // slot types OUT\n    this.slot_types_default_in = []; // specify for each IN slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search\n    this.slot_types_default_out = []; // specify for each OUT slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search\n\n    this.graphDefaultConfig = {\n      align_to_grid: true,\n      links_ontop: false\n    };\n    this.alt_drag_do_clone_nodes = false; // [true!] very handy, ALT click to clone and drag the new node\n    this.alt_shift_drag_connect_clone_with_input = true; // [true!] very handy, when cloning, keep input connections with SHIFT\n\n    this.do_add_triggers_slots = false; // [true!] will create and connect event slots when using action/events connections, !WILL CHANGE node mode when using onTrigger (enable mode colors), onExecuted does not need this\n\n    this.allow_multi_output_for_events = true; // [false!] being events, it is strongly reccomended to use them sequentially, one by one\n\n    this.middle_click_slot_add_default_node = false; // [true!] allows to create and connect a ndoe clicking with the third button (wheel)\n\n    this.release_link_on_empty_shows_menu = false; // [true!] dragging a link to empty space will open a menu, add from list, search or defaults\n    this.two_fingers_opens_menu = false; // [true!] using pointer event isPrimary, when is not simulate right click\n\n    this.backspace_delete = true; // [false!] delete key is enough, don't mess with text edit and custom\n\n    this.ctrl_shift_v_paste_connect_unselected_outputs = false; // [true!] allows ctrl + shift + v to paste nodes with the outputs of the unselected nodes connected with the inputs of the newly pasted nodes\n\n    this.actionHistory_enabled = false; // cntrlZ, cntrlY\n    this.actionHistoryMaxSave = 40;\n\n    /* EXECUTING ACTIONS AFTER UPDATING VALUES - ANCESTORS */\n    this.refreshAncestorsOnTriggers = false; // [true!]\n    this.refreshAncestorsOnActions = false; // [true!]\n    this.ensureUniqueExecutionAndActionCall = false; // [true!] the new tecnique.. let's make it working best of\n\n    // if true, all newly created nodes/links will use string UUIDs for their id fields instead of integers.\n    // use this if you must have node IDs that are unique across all graphs and subgraphs.\n    this.use_uuids = false;\n\n    // enable filtering elements of the context menu with keypress (+ arrows for navigation, escape to close)\n    this.context_menu_filter_enabled = false; // FIX event handler removal\n\n    this.showCanvasOptions = false; // [true!] customize availableCanvasOptions\n    this.availableCanvasOptions = [\"allow_addOutSlot_onExecuted\", \"free_resize\", \"highquality_render\", \"use_gradients\",\n    // set to true to render titlebar with gradients\n    \"pause_rendering\", \"clear_background\", \"read_only\",\n    // if set to true users cannot modify the graph\n    // \"render_only_selected\", // not implemented\n    \"live_mode\", \"show_info\", \"allow_dragcanvas\", \"allow_dragnodes\", \"allow_interaction\",\n    // allow to control widgets, buttons, collapse, etc\n    \"allow_searchbox\", \"move_destination_link_without_shift\",\n    // rename: old allow_reconnect_links //allows to change a connection, no need to hold shift\n    \"set_canvas_dirty_on_mouse_event\",\n    // forces to redraw the canvas if the mouse does anything\n    \"always_render_background\", \"render_shadows\", \"render_canvas_border\", \"render_connections_shadows\",\n    // too much cpu\n    \"render_connections_border\",\n    // ,\"render_curved_connections\", // always on, or specific fixed graph\n    \"render_connection_arrows\", \"render_collapsed_slots\", \"render_execution_order\", \"render_title_colored\", \"render_link_tooltip\"];\n    // ,\"editor_alpha\" //= 1; //used for transition\n\n    this.actionHistoryMaxSave = 40;\n    this.canRemoveSlots = true;\n    this.canRemoveSlots_onlyOptional = true;\n    this.canRenameSlots = true;\n    this.canRenameSlots_onlyOptional = true;\n    this.ensureNodeSingleExecution = false; // OLD this will prevent nodes to be executed more than once for step (comparing graph.iteration)\n    this.ensureNodeSingleAction = false; // OLD this will prevent nodes to be executed more than once for action call!\n    this.preventAncestorRecalculation = false; // OLD(?) when calculating the ancestors, set a flag to prevent recalculate the subtree\n\n    this.ensureUniqueExecutionAndActionCall = true; // NEW ensure single event execution\n\n    this.allowMultiOutputForEvents = false; // being events, it is strongly reccomended to use them sequentually, one by one\n\n    this.log_methods = ['error', 'warn', 'info', 'log', 'debug'];\n    // this.loggingSetup();\n\n    // this.debug = 1; // has custom get set, in this.debug_level is stored the actual numeric value\n    // this.debug_level = 1;\n    this.logging_set_level(2);\n  }\n\n  // get and set debug (log)level\n  // from -1 (none), 0 (error), .. to 4 (debug) based on console methods 'error', 'warn', 'info', 'log', 'debug'\n  return _createClass(_class, [{\n    key: \"logging_set_level\",\n    value: function logging_set_level(v) {\n      this.debug_level = Number(v);\n    }\n\n    // entrypoint to debug log\n  }, {\n    key: \"logging\",\n    value: function logging(lvl /**/) {\n      var _console3;\n      // arguments\n\n      if (lvl > this.debug_level) return; // -- break, debug only below or equal current --\n\n      function clean_args(args) {\n        var aRet = [];\n        for (var iA = 1; iA < args.length; iA++) {\n          if (typeof args[iA] !== \"undefined\") aRet.push(args[iA]);\n        }\n        return aRet;\n      }\n      var lvl_txt = \"debug\";\n      if (lvl >= 0 && lvl <= 4) lvl_txt = ['error', 'warn', 'info', 'log', 'debug'][lvl];\n      if (typeof console[lvl_txt] !== \"function\") {\n        console.warn(\"[LG-log] invalid console method\", lvl_txt, clean_args(arguments));\n        throw new RangeError();\n      }\n      (_console3 = console)[lvl_txt].apply(_console3, [\"[LG]\"].concat(_toConsumableArray(clean_args(arguments))));\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      this.logging.apply(this, [0].concat(Array.prototype.slice.call(arguments)));\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      this.logging.apply(this, [1].concat(Array.prototype.slice.call(arguments)));\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      this.logging.apply(this, [2].concat(Array.prototype.slice.call(arguments)));\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      this.logging.apply(this, [3].concat(Array.prototype.slice.call(arguments)));\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      this.logging.apply(this, [4].concat(Array.prototype.slice.call(arguments)));\n    }\n\n    /**\r\n     * Register a node class so it can be listed when the user wants to create a new one\r\n     * @method registerNodeType\r\n     * @param {String} type name of the node and path\r\n     * @param {Class} base_class class containing the structure of a node\r\n     */\n  }, {\n    key: \"registerNodeType\",\n    value: function registerNodeType(type, base_class) {\n      var _this$debug, _LiteGraph$onNodeType, _this$debug3, _this$debug4, _base_class$title;\n      if (!base_class.prototype) {\n        throw new Error(\"Cannot register a simple object, it must be a class with a prototype\");\n      }\n      base_class.type = type;\n      (_this$debug = this.debug) === null || _this$debug === void 0 || _this$debug.call(this, \"registerNodeType\", \"start\", type);\n      var classname = base_class.name;\n      var pos = type.lastIndexOf(\"/\");\n      base_class.category = type.substring(0, pos);\n      if (!base_class.title) {\n        base_class.title = classname;\n      }\n      var propertyDescriptors = Object.getOwnPropertyDescriptors(_lgraphnode_js__WEBPACK_IMPORTED_MODULE_2__.LGraphNode.prototype);\n\n      // Iterate over each property descriptor\n      Object.keys(propertyDescriptors).forEach(function (propertyName) {\n        // Check if the property already exists on the target prototype\n        if (!base_class.prototype.hasOwnProperty(propertyName)) {\n          // If the property doesn't exist, copy it from the source to the target\n          Object.defineProperty(base_class.prototype, propertyName, propertyDescriptors[propertyName]);\n        }\n      });\n      var prev = this.registered_node_types[type];\n      if (prev) {\n        var _this$debug2;\n        (_this$debug2 = this.debug) === null || _this$debug2 === void 0 || _this$debug2.call(this, \"registerNodeType\", \"replacing node type\", type, prev);\n      }\n      if (!Object.prototype.hasOwnProperty.call(base_class.prototype, \"shape\")) {\n        Object.defineProperty(base_class.prototype, \"shape\", {\n          set: function set(v) {\n            switch (v) {\n              case \"default\":\n                delete this._shape;\n                break;\n              case \"box\":\n                this._shape = LiteGraph.BOX_SHAPE;\n                break;\n              case \"round\":\n                this._shape = LiteGraph.ROUND_SHAPE;\n                break;\n              case \"circle\":\n                this._shape = LiteGraph.CIRCLE_SHAPE;\n                break;\n              case \"card\":\n                this._shape = LiteGraph.CARD_SHAPE;\n                break;\n              default:\n                this._shape = v;\n            }\n          },\n          get: function get() {\n            return this._shape;\n          },\n          enumerable: true,\n          configurable: true\n        });\n\n        // used to know which nodes to create when dragging files to the canvas\n        if (base_class.supported_extensions) {\n          for (var _i2 in base_class.supported_extensions) {\n            var _ext = base_class.supported_extensions[_i2];\n            if (_ext && _ext.constructor === String) {\n              this.node_types_by_file_extension[_ext.toLowerCase()] = base_class;\n            }\n          }\n        }\n      }\n      this.registered_node_types[type] = base_class;\n      if (base_class.constructor.name) {\n        this.Nodes[classname] = base_class;\n      }\n      (_LiteGraph$onNodeType = LiteGraph.onNodeTypeRegistered) === null || _LiteGraph$onNodeType === void 0 || _LiteGraph$onNodeType.call(LiteGraph, type, base_class);\n      if (prev) {\n        var _LiteGraph$onNodeType2;\n        (_LiteGraph$onNodeType2 = LiteGraph.onNodeTypeReplaced) === null || _LiteGraph$onNodeType2 === void 0 || _LiteGraph$onNodeType2.call(LiteGraph, type, base_class, prev);\n      }\n\n      // warnings\n      if (base_class.prototype.onPropertyChange) {\n        LiteGraph.warn(\"LiteGraph node class \" + type + \" has onPropertyChange method, it must be called onPropertyChanged with d at the end\");\n      }\n\n      // used to know which nodes create when dragging files to the canvas\n      if (base_class.supported_extensions) {\n        for (var i = 0; i < base_class.supported_extensions.length; i++) {\n          var ext = base_class.supported_extensions[i];\n          if (ext && ext.constructor === String) this.node_types_by_file_extension[ext.toLowerCase()] = base_class;\n        }\n      }\n      (_this$debug3 = this.debug) === null || _this$debug3 === void 0 || _this$debug3.call(this, \"registerNodeType\", \"type registered\", type);\n      if (this.auto_load_slot_types) (_this$debug4 = this.debug) === null || _this$debug4 === void 0 || _this$debug4.call(this, \"registerNodeType\", \"do auto_load_slot_types\", type);\n      new base_class((_base_class$title = base_class.title) !== null && _base_class$title !== void 0 ? _base_class$title : \"tmpnode\");\n    }\n\n    /**\r\n     * removes a node type from the system\r\n     * @method unregisterNodeType\r\n     * @param {String|Object} type name of the node or the node constructor itself\r\n     */\n  }, {\n    key: \"unregisterNodeType\",\n    value: function unregisterNodeType(type) {\n      var base_class = type.constructor === String ? this.registered_node_types[type] : type;\n      if (!base_class) {\n        throw new Error(\"node type not found: \" + type);\n      }\n      delete this.registered_node_types[base_class.type];\n      if (base_class.constructor.name) {\n        delete this.Nodes[base_class.constructor.name];\n      }\n    }\n\n    /**\r\n    * Save a slot type and his node\r\n    * @method registerSlotType\r\n    * @param {String|Object} type name of the node or the node constructor itself\r\n    * @param {String} slot_type name of the slot type (variable type), eg. string, number, array, boolean, ..\r\n    */\n  }, {\n    key: \"registerNodeAndSlotType\",\n    value: function registerNodeAndSlotType(type, slot_type) {\n      var out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var base_class = type.constructor === String && this.registered_node_types[type] !== \"anonymous\" ? this.registered_node_types[type] : type;\n      var class_type = base_class.constructor.type;\n      var allTypes = [];\n      if (typeof slot_type === \"string\") {\n        allTypes = slot_type.split(\",\");\n      } else if (slot_type == this.EVENT || slot_type == this.ACTION) {\n        allTypes = [\"_event_\"];\n      } else {\n        allTypes = [\"*\"];\n      }\n      for (var i = 0; i < allTypes.length; ++i) {\n        var slotType = allTypes[i];\n        if (slotType === \"\") {\n          slotType = \"*\";\n        }\n        var registerTo = out ? \"registered_slot_out_types\" : \"registered_slot_in_types\";\n        if (this[registerTo][slotType] === undefined) {\n          this[registerTo][slotType] = {\n            nodes: []\n          };\n        }\n        if (!this[registerTo][slotType].nodes.includes(class_type)) {\n          this[registerTo][slotType].nodes.push(class_type);\n        }\n\n        // check if is a new type\n        if (!out) {\n          if (!this.slot_types_in.includes(slotType.toLowerCase())) {\n            this.slot_types_in.push(slotType.toLowerCase());\n            this.slot_types_in.sort();\n          }\n        } else {\n          if (!this.slot_types_out.includes(slotType.toLowerCase())) {\n            this.slot_types_out.push(slotType.toLowerCase());\n            this.slot_types_out.sort();\n          }\n        }\n      }\n    }\n\n    /**\r\n     * Create a new nodetype by passing an object with some properties\r\n     * like onCreate, inputs:Array, outputs:Array, properties, onExecute\r\n     * @method buildNodeClassFromObject\r\n     * @param {String} name node name with namespace (p.e.: 'math/sum')\r\n     * @param {Object} object methods expected onCreate, inputs, outputs, properties, onExecute\r\n     */\n  }, {\n    key: \"buildNodeClassFromObject\",\n    value: function buildNodeClassFromObject(name, object) {\n      var ctor_code = \"\";\n      if (object.inputs) for (var i = 0; i < object.inputs.length; ++i) {\n        var _name = object.inputs[i][0];\n        var _type = object.inputs[i][1];\n        if (_type && _type.constructor === String) _type = '\"' + _type + '\"';\n        ctor_code += \"this.addInput('\" + _name + \"',\" + _type + \");\\n\";\n      }\n      if (object.outputs) for (var _i3 = 0; _i3 < object.outputs.length; ++_i3) {\n        var _name2 = object.outputs[_i3][0];\n        var _type2 = object.outputs[_i3][1];\n        if (_type2 && _type2.constructor === String) _type2 = '\"' + _type2 + '\"';\n        ctor_code += \"this.addOutput('\" + _name2 + \"',\" + _type2 + \");\\n\";\n      }\n      if (object.properties) for (var _i4 in object.properties) {\n        var prop = object.properties[_i4];\n        if (prop && prop.constructor === String) prop = '\"' + prop + '\"';\n        ctor_code += \"this.addProperty('\" + _i4 + \"',\" + prop + \");\\n\";\n      }\n      ctor_code += \"if(this.onCreate)this.onCreate()\";\n      var classobj = Function(ctor_code);\n      for (var _i5 in object) if (_i5 != \"inputs\" && _i5 != \"outputs\" && _i5 != \"properties\") classobj.prototype[_i5] = object[_i5];\n      classobj.title = object.title || name.split(\"/\").pop();\n      classobj.desc = object.desc || \"Generated from object\";\n      this.registerNodeType(name, classobj);\n      return classobj;\n    }\n\n    /**\r\n     * Create a new nodetype by passing a function, it wraps it with a proper class and generates inputs according to the parameters of the function.\r\n     * Useful to wrap simple methods that do not require properties, and that only process some input to generate an output.\r\n     * @method wrapFunctionAsNode\r\n     * @param {String} name node name with namespace (p.e.: 'math/sum')\r\n     * @param {Function} func\r\n     * @param {Array} param_types [optional] an array containing the type of every parameter, otherwise parameters will accept any type\r\n     * @param {String} return_type [optional] string with the return type, otherwise it will be generic\r\n     * @param {Object} properties [optional] properties to be configurable\r\n     */\n  }, {\n    key: \"wrapFunctionAsNode\",\n    value: function wrapFunctionAsNode(name, func, param_types, return_type, properties) {\n      var names = LiteGraph.getParameterNames(func);\n      var code = names.map(function (name, i) {\n        var paramType = param_types !== null && param_types !== void 0 && param_types[i] ? \"'\".concat(param_types[i], \"'\") : \"0\";\n        return \"this.addInput('\".concat(name, \"', \").concat(paramType, \");\");\n      }).join(\"\\n\");\n      var returnTypeStr = return_type ? \"'\".concat(return_type, \"'\") : 0;\n      var propertiesStr = properties ? \"this.properties = \".concat(JSON.stringify(properties), \";\") : \"\";\n      var classObj = new Function(\"\\n            \".concat(code, \"\\n            this.addOutput('out', \").concat(returnTypeStr, \");\\n            \").concat(propertiesStr, \"\\n        \"));\n      classObj.title = name.split(\"/\").pop();\n      classObj.desc = \"Generated from \".concat(func.name);\n      classObj.prototype.onExecute = function () {\n        var _this = this;\n        var params = names.map(function (name, i) {\n          return _this.getInputData(i);\n        });\n        var result = func.apply(this, params);\n        this.setOutputData(0, result);\n      };\n      this.registerNodeType(name, classObj);\n      return classObj;\n    }\n\n    /**\r\n     * Removes all previously registered node's types\r\n     */\n  }, {\n    key: \"clearRegisteredTypes\",\n    value: function clearRegisteredTypes() {\n      this.registered_node_types = {};\n      this.node_types_by_file_extension = {};\n      this.Nodes = {};\n      this.searchbox_extras = {};\n    }\n\n    /**\r\n     * Adds this method to all nodetypes, existing and to be created\r\n     * (You can add it to LGraphNode.prototype but then existing node types wont have it)\r\n     * @method addNodeMethod\r\n     * @param {Function} func\r\n     */\n  }, {\n    key: \"addNodeMethod\",\n    value: function addNodeMethod(name, func) {\n      _lgraphnode_js__WEBPACK_IMPORTED_MODULE_2__.LGraphNode.prototype[name] = func;\n      for (var i in this.registered_node_types) {\n        var type = this.registered_node_types[i];\n        if (type.prototype[name]) {\n          type.prototype[\"_\" + name] = type.prototype[name];\n        } // keep old in case of replacing\n        type.prototype[name] = func;\n      }\n    }\n\n    /**\r\n     * Create a node of a given type with a name. The node is not attached to any graph yet.\r\n     * @method createNode\r\n     * @param {String} type full name of the node class. p.e. \"math/sin\"\r\n     * @param {String} name a name to distinguish from other nodes\r\n     * @param {Object} options to set options\r\n     */\n  }, {\n    key: \"createNode\",\n    value: function createNode(type, title) {\n      var _this$registered_node, _ref, _title, _node, _node$title, _node2, _node2$properties, _node3, _node3$properties_inf, _node4, _node4$flags, _node5, _node5$size, _node6, _node6$pos, _node7, _node7$mode, _node$onNodeCreated, _node8;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var base_class = (_this$registered_node = this.registered_node_types[type]) !== null && _this$registered_node !== void 0 ? _this$registered_node : null;\n      if (!base_class) {\n        var _this$log;\n        (_this$log = this.log) === null || _this$log === void 0 || _this$log.call(this, \"GraphNode type \\\"\".concat(type, \"\\\" not registered.\"));\n        return null;\n      }\n      title = (_ref = (_title = title) !== null && _title !== void 0 ? _title : base_class.title) !== null && _ref !== void 0 ? _ref : type;\n      var node = null;\n      if (LiteGraph.catch_exceptions) {\n        try {\n          node = new base_class(title);\n        } catch (err) {\n          var _this$error;\n          (_this$error = this.error) === null || _this$error === void 0 || _this$error.call(this, err);\n          return null;\n        }\n      } else {\n        node = new base_class(title);\n      }\n      node.type = type;\n      (_node$title = (_node = node).title) !== null && _node$title !== void 0 ? _node$title : _node.title = title;\n      (_node2$properties = (_node2 = node).properties) !== null && _node2$properties !== void 0 ? _node2$properties : _node2.properties = {};\n      (_node3$properties_inf = (_node3 = node).properties_info) !== null && _node3$properties_inf !== void 0 ? _node3$properties_inf : _node3.properties_info = [];\n      (_node4$flags = (_node4 = node).flags) !== null && _node4$flags !== void 0 ? _node4$flags : _node4.flags = {};\n      (_node5$size = (_node5 = node).size) !== null && _node5$size !== void 0 ? _node5$size : _node5.size = node.computeSize();\n      (_node6$pos = (_node6 = node).pos) !== null && _node6$pos !== void 0 ? _node6$pos : _node6.pos = LiteGraph.DEFAULT_POSITION.concat();\n      (_node7$mode = (_node7 = node).mode) !== null && _node7$mode !== void 0 ? _node7$mode : _node7.mode = LiteGraph.ALWAYS;\n\n      // extra options\n      Object.assign(node, options);\n\n      // callback\n      (_node$onNodeCreated = (_node8 = node).onNodeCreated) === null || _node$onNodeCreated === void 0 || _node$onNodeCreated.call(_node8);\n      return node;\n    }\n\n    /**\r\n     * Returns a registered node type with a given name\r\n     * @method getNodeType\r\n     * @param {String} type full name of the node class. p.e. \"math/sin\"\r\n     * @return {Class} the node class\r\n     */\n  }, {\n    key: \"getNodeType\",\n    value: function getNodeType(type) {\n      return this.registered_node_types[type];\n    }\n\n    /**\r\n     * Returns a list of node types matching one category\r\n     * @method getNodeType\r\n     * @param {String} category category name\r\n     * @return {Array} array with all the node classes\r\n     */\n  }, {\n    key: \"getNodeTypesInCategory\",\n    value: function getNodeTypesInCategory(category, filter) {\n      var filteredTypes = Object.values(this.registered_node_types).filter(function (type) {\n        if (type.filter !== filter) {\n          return false;\n        }\n        if (category === \"\") {\n          return type.category === null;\n        } else {\n          return type.category === category;\n        }\n      });\n      if (this.auto_sort_node_types) {\n        filteredTypes.sort(function (a, b) {\n          return a.title.localeCompare(b.title);\n        });\n      }\n      return filteredTypes;\n    }\n\n    /**\r\n     * Returns a list with all the node type categories\r\n     * @method getNodeTypesCategories\r\n     * @param {String} filter only nodes with ctor.filter equal can be shown\r\n     * @return {Array} array with all the names of the categories\r\n     */\n  }, {\n    key: \"getNodeTypesCategories\",\n    value: function getNodeTypesCategories(filter) {\n      var categories = {\n        \"\": 1\n      };\n      Object.values(this.registered_node_types).forEach(function (type) {\n        if (type.category && !type.skip_list && type.filter === filter) {\n          categories[type.category] = 1;\n        }\n      });\n      var result = Object.keys(categories);\n      return this.auto_sort_node_types ? result.sort() : result;\n    }\n\n    // debug purposes: reloads all the js scripts that matches a wildcard\n  }, {\n    key: \"reloadNodes\",\n    value: function reloadNodes(folder_wildcard) {\n      var _this$log4;\n      var tmp = document.getElementsByTagName(\"script\");\n      // weird, this array changes by its own, so we use a copy\n      var script_files = [];\n      for (var i = 0; i < tmp.length; i++) {\n        script_files.push(tmp[i]);\n      }\n      var docHeadObj = document.getElementsByTagName(\"head\")[0];\n      folder_wildcard = document.location.href + folder_wildcard;\n      for (var _i6 = 0; _i6 < script_files.length; _i6++) {\n        var src = script_files[_i6].src;\n        if (!src || src.substr(0, folder_wildcard.length) != folder_wildcard) {\n          continue;\n        }\n        try {\n          var _this$log2;\n          (_this$log2 = this.log) === null || _this$log2 === void 0 || _this$log2.call(this, \"Reloading: \" + src);\n          var dynamicScript = document.createElement(\"script\");\n          dynamicScript.type = \"text/javascript\";\n          dynamicScript.src = src;\n          docHeadObj.appendChild(dynamicScript);\n          docHeadObj.removeChild(script_files[_i6]);\n        } catch (err) {\n          var _this$log3;\n          if (LiteGraph.throw_errors) {\n            throw err;\n          }\n          (_this$log3 = this.log) === null || _this$log3 === void 0 || _this$log3.call(this, \"Error while reloading \" + src);\n        }\n      }\n      (_this$log4 = this.log) === null || _this$log4 === void 0 || _this$log4.call(this, \"Nodes reloaded\");\n    }\n\n    // separated just to improve if it doesn't work\n  }, {\n    key: \"cloneObject\",\n    value: function cloneObject(obj, target) {\n      if (obj == null) {\n        return null;\n      }\n      var clonedObj = JSON.parse(JSON.stringify(obj));\n      if (!target) {\n        return clonedObj;\n      }\n      for (var key in clonedObj) {\n        if (Object.prototype.hasOwnProperty.call(clonedObj, key)) {\n          target[key] = clonedObj[key];\n        }\n      }\n      return target;\n    }\n\n    /*\r\n        * https://gist.github.com/jed/982883?permalink_comment_id=852670#gistcomment-852670\r\n        */\n  }, {\n    key: \"uuidv4\",\n    value: function uuidv4() {\n      return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, function (a) {\n        return (a ^ Math.random() * 16 >> a / 4).toString(16);\n      });\n    }\n\n    /**\r\n     * Returns if the types of two slots are compatible (taking into account wildcards, etc)\r\n     * @method isValidConnection\r\n     * @param {String} type_a\r\n     * @param {String} type_b\r\n     * @return {Boolean} true if they can be connected\r\n     */\n  }, {\n    key: \"isValidConnection\",\n    value: function isValidConnection(type_a, type_b) {\n      if (type_a === \"\" || type_a === \"*\") type_a = 0;\n      if (type_b === \"\" || type_b === \"*\") type_b = 0;\n      if (!type_a || !type_b || type_a === type_b || type_a === LiteGraph.EVENT && type_b === LiteGraph.ACTION) {\n        return true;\n      }\n      type_a = String(type_a).toLowerCase();\n      type_b = String(type_b).toLowerCase();\n      if (!type_a.includes(\",\") && !type_b.includes(\",\")) {\n        return type_a === type_b;\n      }\n      var supported_types_a = type_a.split(\",\");\n      var supported_types_b = type_b.split(\",\");\n      var _iterator = _createForOfIteratorHelper(supported_types_a),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var supported_type_a = _step.value;\n          var _iterator2 = _createForOfIteratorHelper(supported_types_b),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var supported_type_b = _step2.value;\n              if (this.isValidConnection(supported_type_a, supported_type_b)) {\n                return true;\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return false;\n    }\n\n    /**\r\n     * Register a string in the search box so when the user types it it will recommend this node\r\n     * @method registerSearchboxExtra\r\n     * @param {String} node_type the node recommended\r\n     * @param {String} description text to show next to it\r\n     * @param {Object} data it could contain info of how the node should be configured\r\n     * @return {Boolean} true if they can be connected\r\n     */\n  }, {\n    key: \"registerSearchboxExtra\",\n    value: function registerSearchboxExtra(node_type, description, data) {\n      this.searchbox_extras[description.toLowerCase()] = {\n        type: node_type,\n        desc: description,\n        data: data\n      };\n    }\n\n    /**\r\n     * Wrapper to load files (from url using fetch or from file using FileReader)\r\n     * @method fetchFile\r\n     * @param {String|File|Blob} url the url of the file (or the file itself)\r\n     * @param {String} type an string to know how to fetch it: \"text\",\"arraybuffer\",\"json\",\"blob\"\r\n     * @param {Function} on_complete callback(data)\r\n     * @param {Function} on_error in case of an error\r\n     * @return {FileReader|Promise} returns the object used to\r\n     */\n  }, {\n    key: \"fetchFile\",\n    value: function fetchFile(url, type, on_complete, on_error) {\n      var _this2 = this;\n      if (!url) return null;\n      type = type || \"text\";\n      if (url.constructor === String) {\n        if (url.substr(0, 4) == \"http\" && LiteGraph.proxy) {\n          url = LiteGraph.proxy + url.substr(url.indexOf(\":\") + 3);\n        }\n        return fetch(url).then(function (response) {\n          if (!response.ok) throw new Error(\"File not found\"); // it will be catch below\n          if (type == \"arraybuffer\") return response.arrayBuffer();else if (type == \"text\" || type == \"string\") return response.text();else if (type == \"json\") return response.json();else if (type == \"blob\") return response.blob();\n        }).then(function (data) {\n          if (on_complete) on_complete(data);\n        })[\"catch\"](function (error) {\n          var _this2$error;\n          (_this2$error = _this2.error) === null || _this2$error === void 0 || _this2$error.call(_this2, \"error fetching file:\", url);\n          if (on_error) on_error(error);\n        });\n      } else if (url.constructor === File || url.constructor === Blob) {\n        var reader = new FileReader();\n        reader.onload = function (e) {\n          var v = e.target.result;\n          if (type == \"json\") v = JSON.parse(v);\n          if (on_complete) on_complete(v);\n        };\n        if (type == \"arraybuffer\") return reader.readAsArrayBuffer(url);else if (type == \"text\" || type == \"json\") return reader.readAsText(url);else if (type == \"blob\") return reader.readAsBinaryString(url);\n      }\n      return null;\n    }\n\n    // @TODO These weren't even directly bound, so could be used as free functions\n  }, {\n    key: \"compareObjects\",\n    value: function compareObjects(a, b) {\n      var aKeys = Object.keys(a);\n      if (aKeys.length !== Object.keys(b).length) {\n        return false;\n      }\n      return aKeys.every(function (key) {\n        return a[key] === b[key];\n      });\n    }\n  }, {\n    key: \"distance\",\n    value: function distance(a, b) {\n      var _a = _slicedToArray(a, 2),\n        xA = _a[0],\n        yA = _a[1];\n      var _b = _slicedToArray(b, 2),\n        xB = _b[0],\n        yB = _b[1];\n      return Math.sqrt(Math.pow(xB - xA, 2) + Math.pow(yB - yA, 2));\n    }\n  }, {\n    key: \"colorToString\",\n    value: function colorToString(c) {\n      return \"rgba(\" + Math.round(c[0] * 255).toFixed() + \",\" + Math.round(c[1] * 255).toFixed() + \",\" + Math.round(c[2] * 255).toFixed() + \",\" + (c.length == 4 ? c[3].toFixed(2) : \"1.0\") + \")\";\n    }\n  }, {\n    key: \"canvasFillTextMultiline\",\n    value: function canvasFillTextMultiline(context, text, x, y, maxWidth, lineHeight) {\n      var words = (text + \"\").trim().split(' ');\n      var line = '';\n      var ret = {\n        lines: [],\n        maxW: 0,\n        height: 0\n      };\n      if (words.length > 1) {\n        for (var n = 0; n < words.length; n++) {\n          var testLine = line + words[n] + ' ';\n          var metrics = context.measureText(testLine);\n          var testWidth = metrics.width;\n          if (testWidth > maxWidth && n > 0) {\n            context.fillText(line, x, y + lineHeight * ret.lines.length);\n            line = words[n] + ' ';\n            // y += lineHeight;\n            ret.max = testWidth;\n            ret.lines.push(line);\n          } else {\n            line = testLine;\n          }\n        }\n      } else {\n        line = words[0];\n      }\n      context.fillText(line, x, y + lineHeight * ret.lines.length);\n      ret.lines.push(line);\n      ret.height = lineHeight * ret.lines.length || lineHeight;\n      return ret;\n    }\n  }, {\n    key: \"isInsideRectangle\",\n    value: function isInsideRectangle(x, y, left, top, width, height) {\n      return x > left && x < left + width && y > top && y < top + height;\n    }\n\n    // [minx,miny,maxx,maxy]\n  }, {\n    key: \"growBounding\",\n    value: function growBounding(bounding, x, y) {\n      if (x < bounding[0]) {\n        bounding[0] = x;\n      } else if (x > bounding[2]) {\n        bounding[2] = x;\n      }\n      if (y < bounding[1]) {\n        bounding[1] = y;\n      } else if (y > bounding[3]) {\n        bounding[3] = y;\n      }\n    }\n\n    // point inside bounding box\n  }, {\n    key: \"isInsideBounding\",\n    value: function isInsideBounding(p, bb) {\n      return p[0] >= bb[0][0] && p[1] >= bb[0][1] && p[0] <= bb[1][0] && p[1] <= bb[1][1];\n    }\n\n    // bounding overlap, format: [ startx, starty, width, height ]\n  }, {\n    key: \"overlapBounding\",\n    value: function overlapBounding(a, b) {\n      var A_end_x = a[0] + a[2];\n      var A_end_y = a[1] + a[3];\n      var B_end_x = b[0] + b[2];\n      var B_end_y = b[1] + b[3];\n      return !(a[0] > B_end_x || a[1] > B_end_y || A_end_x < b[0] || A_end_y < b[1]);\n    }\n\n    // Convert a hex value to its decimal value - the inputted hex must be in the\n    //\tformat of a hex triplet - the kind we use for HTML colours. The function\n    //\twill return an array with three values.\n  }, {\n    key: \"hex2num\",\n    value: function hex2num(hex) {\n      if (hex.charAt(0) == \"#\") {\n        hex = hex.slice(1);\n      } // Remove the '#' char - if there is one.\n      hex = hex.toUpperCase();\n      var hex_alphabets = \"0123456789ABCDEF\";\n      var value = new Array(3);\n      var k = 0;\n      var int1, int2;\n      for (var i = 0; i < 6; i += 2) {\n        int1 = hex_alphabets.indexOf(hex.charAt(i));\n        int2 = hex_alphabets.indexOf(hex.charAt(i + 1));\n        value[k] = int1 * 16 + int2;\n        k++;\n      }\n      return value;\n    }\n\n    // Give a array with three values as the argument and the function will return\n    //\tthe corresponding hex triplet.\n  }, {\n    key: \"num2hex\",\n    value: function num2hex(triplet) {\n      var hex_alphabets = \"0123456789ABCDEF\";\n      var hex = \"#\";\n      var int1, int2;\n      for (var i = 0; i < 3; i++) {\n        int1 = triplet[i] / 16;\n        int2 = triplet[i] % 16;\n        hex += hex_alphabets.charAt(int1) + hex_alphabets.charAt(int2);\n      }\n      return hex;\n    }\n  }, {\n    key: \"pointerevents_method\",\n    get: function get() {\n      var _console$error3, _console4;\n      (_console$error3 = (_console4 = console).error) === null || _console$error3 === void 0 || _console$error3.call(_console4, \"Removed and being re-integrated sorta\");\n    },\n    set: function set(v) {\n      var _console$error4, _console5;\n      (_console$error4 = (_console5 = console).error) === null || _console$error4 === void 0 || _console$error4.call(_console5, \"Removed and being re-integrated sorta\");\n    }\n  }]);\n}())();\n\n// timer that works everywhere\nif (typeof performance != \"undefined\") {\n  LiteGraph.getTime = performance.now.bind(performance);\n} else if (typeof Date != \"undefined\" && Date.now) {\n  LiteGraph.getTime = Date.now.bind(Date);\n} else if (typeof process != \"undefined\") {\n  LiteGraph.getTime = function () {\n    var t = process.hrtime();\n    return t[0] * 0.001 + t[1] * 1e-6;\n  };\n} else {\n  LiteGraph.getTime = function getTime() {\n    return new Date().getTime();\n  };\n}\nif (typeof window != \"undefined\" && !window[\"requestAnimationFrame\"]) {\n  window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {\n    window.setTimeout(callback, 1000 / 60);\n  };\n}\n\n// Expose core classes to the outside\nwindow.LiteGraph = LiteGraph;\nwindow.LLink = _llink_js__WEBPACK_IMPORTED_MODULE_0__.LLink;\nwindow.LGraph = _lgraph_js__WEBPACK_IMPORTED_MODULE_1__.LGraph;\nwindow.LGraphNode = _lgraphnode_js__WEBPACK_IMPORTED_MODULE_2__.LGraphNode;\nwindow.LGraphGroup = _lgraphgroup_js__WEBPACK_IMPORTED_MODULE_3__.LGraphGroup;\nwindow.LGraphCanvas = _lgraphcanvas_js__WEBPACK_IMPORTED_MODULE_4__.LGraphCanvas;\nwindow.DragAndScale = _dragandscale_js__WEBPACK_IMPORTED_MODULE_5__.DragAndScale;\nwindow.ContextMenu = _contextmenu_js__WEBPACK_IMPORTED_MODULE_6__.ContextMenu;\n\n//# sourceURL=webpack://LiteGraphJS/./src/litegraph.js?");

/***/ }),

/***/ "./src/llink.js":
/*!**********************!*\
  !*** ./src/llink.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LLink: () => (/* binding */ LLink)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\r\n * Class representing a link object that stores link information between two nodes.\r\n */\nvar LLink = /*#__PURE__*/function () {\n  /**\r\n   * Create a link object.\r\n   * @param {string} id - The unique identifier of the link.\r\n   * @param {string} type - The type of the link.\r\n   * @param {string} origin_id - The identifier of the origin node.\r\n   * @param {string} origin_slot - The slot of the origin node the link is connected to.\r\n   * @param {string} target_id - The identifier of the target node.\r\n   * @param {string} target_slot - The slot of the target node the link is connected to.\r\n   */\n  function LLink(id, type, origin_id, origin_slot, target_id, target_slot) {\n    _classCallCheck(this, LLink);\n    this.id = id;\n    this.type = type;\n    this.origin_id = origin_id;\n    this.origin_slot = origin_slot;\n    this.target_id = target_id;\n    this.target_slot = target_slot;\n    this._data = null;\n    this._pos = new Float32Array(2); // center\n  }\n\n  /**\r\n   * Configure the link object with new data.\r\n   * @param {Array|Object} o - An array or object containing link data to configure.\r\n   */\n  return _createClass(LLink, [{\n    key: \"configure\",\n    value: function configure(o) {\n      if (o.constructor === Array) {\n        this.id = o[0];\n        this.origin_id = o[1];\n        this.origin_slot = o[2];\n        this.target_id = o[3];\n        this.target_slot = o[4];\n        this.type = o[5];\n      } else {\n        this.id = o.id;\n        this.type = o.type;\n        this.origin_id = o.origin_id;\n        this.origin_slot = o.origin_slot;\n        this.target_id = o.target_id;\n        this.target_slot = o.target_slot;\n      }\n    }\n\n    /**\r\n     * Serialize the link object to an array.\r\n     * @returns {Array} An array containing the serialized link data.\r\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return [this.id, this.origin_id, this.origin_slot, this.target_id, this.target_slot, this.type];\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://LiteGraphJS/./src/llink.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/litegraph.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});